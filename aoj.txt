パターン検索 https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/14/ALDS1_14_C
  →h*wの文字フィールドからr*cの文字パターンを探して全て出力する
    →1<=h,w<=1000
    →1<=r,c<=1000
  →r,cが小さいと検査の係数が小さくなり、h,wの捜査が大きくなる
  →r,cが大きいと検査の係数が大きくなり、h,wの捜査が小さくなる
    →h=1000w=1000かつr=500c=500くらいが一番重くなる
      →全て出力できる場合は確実にTLE
      →全探索では不可能
        →接尾辞配列？
          →シンプルに難しい
        →使われるのは英大文字、英小文字、数字
          →これをいじる？
            →自力index比較では無理だが普通の組み込みsubstringと==を使っていけた

文字列検索　https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/14/ALDS1_14_D
  →文字列Tの中に文字列Pが出現するかどうか判定
    →これは接尾辞配列
      →suffixarrayをO(n)で構築して検索する
        →suffixarrayのサイズがでかくなりすぎてMLE
          →ライブラリ作る必要があるレベルなので後回し

お釣りの最小個数　https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/15/ALDS1_15_A 
  →1,5,10,25を使ってnを作る
    →やるだけ
    
有理ナップサック問題　https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/15/ALDS1_15_B
  →重さがwまでの範囲で自由である
    →その時の価値はvi*w'/wiとなる
  →1<=N<=10^5
  →1<=w<=10^9
  →1<=vi<=10^9
  →1<=wi<=10^9
    →これは単位当たりの価値が一番大きいものを詰められるだけ詰めていけば良さそう
      
活動選択問題　https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/15/ALDS1_15_C
  →多くの活動に参加したい
  →活動の一つはsiに始まりtiに終わる
    →スケジューリング問題
      →終わる時間が速いものから拾う
        
ハフマン符号　https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/15/ALDS1_15_D
  →英小文字の文字列からハフマン木を作ってビット文字列の長さを出力する
    →どれが何個あるかを計算するだけではある

組み合わせ最適化プラクティス
  コイン問題
    →m種類のコインを使ってn円支払う時のコインの最小枚数を求めよ
      →1<=n<=50000
      →1<=m<=20
      →1<=c1<=10000
        →貪欲
   
  ナップサック
    →何度でも同じものを選べるタイプ
      →1<=n<=100
      →1<=vi<=1000
      →1<=wi<=1000
      →1<=W<=10000
    →一次元で良さそう？
      →よい
  
  最長増加部分列
    →最長増加部分列をやるだけ
      
編集距離
  →レーベンシュタイン距離を求める
    →求めるだけ
      →微妙に忘れていたdp(i-1,j)+1,dp(i,j-1)+1,dp(i-1,j-1)+c
        
0-1 ナップザック問題 II
  →https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/1/DPL_1_F
  →1<=n<=100
  →1<=w<=1000000000
    →wが大きいため、価値と入れ替える
      
個数制限付きナップザック問題
  →https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/1/DPL_1_G
  →i個目の商品はmi個まで選べるナップサック
  →1<=mi<=10000なので愚直にみるとTLE
    →厄介なパターンが存在する
      →例えばiにおいて重さwの時の価値がa>bだった時に使用回数がa<bとなっているような時である
        →aとbのどっちから最大価値にたどり着く事が出来るか判断しにくい
          →上のような状況がほんとにあるのか検証
            →ある
        →このようなときは上から見ていくのが良い
          →まず値が入っているところを見る
            →そこからWいっぱいまでで入れられるだけ入れられるところに値を置く
              →Wの上から見て値が入っている場所-wiのところを見て-1であれば値を入れる
                →-1でなければV(i)-viとV(i-wi)の大きい方を入れる
                  →止まる地点が難しい
                    →終わりの点の位置も保持する
                  →ダメである
        →飛び地の計算は出来なくはない
          →飛び地を取れる値が複数ある時にどれをセットするのか微妙となる
  →スライド最大値なる方法を使用するとのこと
    →https://ei1333.github.io/luzhiled/snippets/dp/knapsack-limitations.html
                      
最大正方形
  https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/3/DPL_3_A
  0がきれいなタイル、1が汚れているタイル
    きれいなタイルで出来る正方形で最大のものは何か
  1<=h,w<=1400
    結構大きめのテーブルとなる
      愚直解ではすぐTLEするだろう
    累積和が使えるか？
      使えそうにないように思う
    正方形i<正方形jである時、jが作れる場合iも作れる
      ある地点から作れなくなるということで2分探索が有効
        汚れているタイルに対して累積しておけば判定はO(1)で出来る
      
コインの組み合わせ
  a,b,c,dにそれぞれn枚、合計4n枚のコインがある
    各袋から1枚、合計4枚とりだしV円にしたい
      選び方は何通りあるか
        全通りは1000^4である
      しかし半分全列挙で行けそうである
        
Dictionary
  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2630&lang=jp
  文字列siの文字がかすれて読めなくなってしまっている
    これらの文字を復元するときに
      s1<...<snが満たされるような文字列は何通りあるか
    2
    ?sum??mer
    c??a??mp
    output 703286064
    3
    snuje
    ????e
    snule
    output 1
      sample2は自明である
    ?
    ?
    となっている時、基本的には制限がないためa~yに対してそれぞれ決めていけば良いだけである
    ??
    ?
    となっている時は？これも上と同じ考え方で行ける
    ??
    ??
    となっている時は？s[0][0]=s[1][0]までは決められる
      その後ろは分岐する
        1文字目が同じである場合、1文字の時と同じようになる
        1文字目が違う場合、全てのアルファベットを取れる
      s[i][j]<s[i+1][j]である場合その後の文字列は自由となる
        サンプル1を元に考えると
          s0の最初の?がa,bである場合、後の?は完全に自由となり26^6*2となる
          s0の最初の?がcである場合、s1の2文字目がs<=?でなければならない
            sである場合は3文字目に流れるが、ここで4文字目がm>aであるため、3文字目はu<?とならなければならない
              1文字先も見ないといけないということになる
          ここまで考えると文字列s0とs1は4文字目以降は完全に自由に決められるようになっている必要があるわけだ
      各iにおいて、あるjがs[i][j]>s[i+1][j]となっている場合、その後ろの文字は自由
        ここまでであれば少し桁dpっぽい気はする 
          ここから、文字列が3つ以上について考えなければならないだろう
          前の文字列、後ろの文字列に依存するわけである
            挟まれている場合は取れる範囲が限られている
              下から見た時にその?が取れる最大値は仮決め出来る
                上の文字列がタイトでない場合は自由に取れる
                  タイトでない場合というのはs[i][j]<s[i+1][j]<s[i+2][j]となっている場合のj<'jである
                タイトな場合はi,i+1のどちらかと同じ文字を取る場合である
    制限は1<=n<=50
    文字列は1<=|si|<=20
    なので最大1000文字
      タイトでない場合はsijにおいてj<'jにおける?の数を掛ける事が出来る
      たとえばj=0に?が大量に並んでいる場合を考えると
        i-1で?が何を取ったのかを考える必要があるか？
          タイトでない場合を決めるにもi+1の状態を考えないと行けないのがネックになる
            文字列の取り方は全て?だった場合に27^(50*20)
              あるj文字目で完全に辞書順が作れた場合はその後の27^?の個数
              正味memo[50][20][27]のdpで行けないだろうか？
                全てタイトではない場合が辞書順が作れたという判定
                タイトになっている場所はだんだんとなくなっていく、最後までタイトか明らかに逆になっている場合は0となる
                  どこでタイトになっているのが全てなくなるのかも考える必要がある




