Multiples of 3 and 5
  →10未満の整数で3か5の倍数をリストした場合、3,5,6,9の要素を得る、その総和は23
    →1000未満の3か5の倍数の総和は何か
      →プログラムでやれば簡単である
      →3と5等差数列の和から15の踏査数列を引けばいい
        →{333(3+999)}/2+{199(5+995)}/2-{66(15+990)}/2=166833+99500-33165=233168

Largest palindrome product
  →2桁の2つの数字を掛けて出来る最大の回文数は9009=91*99
    →3桁の2つの数字を掛けて出来る最大の回文数を求めよ
  →91*99は3*3*7*11*13となっている
    →7*9*11*13ともいえる
      →同じように連続した数字から探せないだろうか
        →全探索すれば簡単ではあるがO(1)でも表わせそうなだけに見つけたいところ
          →1桁目が0になる事はないので10は使われない
          →偶奇が混ざる場合に10の倍数が現れることもない
        →偶数桁の場合は11が約数として現れる
          →3桁3桁の場合は6桁なので11が入る 
            →普通にループでやった
            →O(1)で解いてる人はいなかった     

Smallest multiple
  →1~20までの数で均等に割り切れる最小の数
    →1~20の最小公倍数
      →2^4*3^2*5^1*7^1*11*13*17*19=232792560
    
Sum square difference
  →最初の10個の平方数の合計は1^2+2^2...+10^2=385
  →最初の10個の数の合計の平方は(1+2+...+10)^2=55^2=3025
  →最初の10個では？
    →(100(101)/2)^2-
    →平方数の合計は1^2+2^2+3^2+...100^2
    →1/6n(n+1)(2n+1)
    
10001st prime
  →最初の6個の素数は2,3,5,7,11,13で6個目は13
  →では10001個目の素数は？
    →素直にプログラムでやるのが良いと思われる

Largest product in a series
  →1000桁の数字の中で隣接した4つの数字で作られる最大の積は5832
  →では隣接した13の数字で作られる最大の積は？
  
Special Pythagorean triplet
  →ピタゴラスの定理はa^2+b^2=c^2
  →a+b+c=1000になるa,b,cは何か
    →c=√(a^2+b^2)
    →a+b+√(a^2+b^2)=1000
    →√(a^2+b^2)=1000-a-b
    →a^2+b^2=(1000-a-b)^2=1000000-1000a-1000b-1000a+a^2+ab-1000b+2ab+b^2=1000000-2000a-2000b+2ab
     →a^2+b^2=1000000-2000a-2000b+ab+a^2+b^2
     →2000a+2000b-2ab=1000000
     
Summation of primes
  →10未満の素数の合計は2+3+5+7=17
    →2000000未満の素数の合計は？
     →素数の問題がいくつかあるので篩は取っておく
    
Largest product in a grid
  →20*20のグリッドの中で隣接した4つの数字の積の中で一番大きいのは何か
    →普通にやる

Number letter counts
  →１から5までのwordを書き出すと、one,two,three,four,fiveで3+3+5+4+4=19 letters userd in total
    →１～1000までのwordの合計は何か？
      →100=handred 
      →one,two,three,four,five,six,seven,eight,nine,ten,eleven,twelve,t
 
Maximum path sum I
  →数字がピラミッド型に積まれていて、一番上から一番下まで移動しながら通過した場所の数字を足していく
    →移動できるのは左下か右下だけ
      →総和の最大を求めよ
        →再帰でやる
        →ボトムアップでも出来る
        
Counting Sundays
  →1901/1/1を月曜日としたとき2000/12/31まで、日曜日が月の始めに割り当てられている数を数えよう
  
Factorial digit sum
  →100!の各桁の数字を足すといくつになるか？
    →doubleを使用するかググる
      →doubleでは桁がつぶれていたため、ググった
      
Amicable numbers
  →d(n)はnを割り切れる数の合計とする
    →d(a)=bかつd(b)=aとなる数を友好的な数とする
      →10000未満の数のの友好的な数の合計を求めよ
        →全探索でも良さそうではある
        
Names scores
  →
  
Non-abundant sums
  →完全数nはn以外のnを割り切れる数を足したときに同じ数字になるものをいう
    →abundant number nは割り切れる数を足したときにnより大きくなる数字
  
---難しさの壁
1000-digit Fibonacci number
  →フィボナッチ数で1000桁ある数字のうち一番最初に出現する値
    →黄金比を使用するとのこと
      →https://www.xarg.org/puzzle/project-euler/problem-25/
      
Reciprocal cycles  
  →1/d d<1000の循環小数で循環している部分の桁数の最大
    →循環している部分の判定が難しい
      →循環していない部分の存在が厄介
        →例えば1293749749299のように後ろ99が連続していたとしてそれより前のところを循環していないと判定することは出来ない
        →余りが循環したらである
          →同じ余りが出てくるところまで繰り返す最大は1000であるため10000程度の配列を用意して処理すればよい
          
Quadratic primes
  →オイラーが二次関数n^2+n+41を発見
    →この数は0<=n<=39に対して素数を作り出す
    →n^2-79n+1601は0<=n<=79に対して素数を作る
      →n^2+an+b where |a|<1000 and |b|<1000
        →上のうちnが最大となる係数は何か、その時のnを求めよ
          →素数を2000000ほど作っておいて、あとは全探索する
            →2000*2000*1000程度にはなるか？
              →そこまで係数が大きくないため大丈夫
   
Number spiral diagonals
  →1から時計回りに渦巻を作り、1辺の要素が1001になるまで処理をする
    →ななめの合計を計算する
      →1,3,5,7,..,1001の平方数が右上に来る
        →その平方数を引き算していくと四隅が計算できる
          →1001であれば1000引いた数、999であれば998引いた数といったように計算出来る
            →ここで各奇数について考えると
              →t=x^2として
                →f(x)=t+(t-(x-1))+(t-2(x-1))+(t-3(x-1))=4t-6(x-1)
                  →1+sum(i=3to1001)f(i)となる

Distinct powers
  →a^b 2<=a<=5 2<=b<=5
    →get the following sequence of 15 distinct terms
      →4,8,9,16,25,27,32,64,81,125,243,256,625,1024,3125
  →2<=a<=100 2<=b<=100
    →からはいくつ出来るか
      →素因数の数で判断出来る
        →a<bである数に対してb<aである場合にb=a^cでa^c^a=a^bになる場合にその数を省ける
          →c*b<=100であれば省ける
        →2から順番に処理していく方が楽か？
          →篩にかけられる?
            →2^2,2^3,2^4,,,,はそれぞれ、4,8,16,に変換可能
              →4^1x,4^2o,4^3o...
              →8^1x,8^2o,8^3o...
              →これで100を超えるまで処理する
                →2次元テーブルに保存できる
                →どうも乗数だけ数えても出ない
                  →素因数分解するほうが良いかもしれない
                  →乗数だけで行けるは行けるが4^51から8^34を導くのが難しい、コードを見てもよくわからないといったところである
                  →最大の100も考える範囲によって大きくなっていく
                    →2をベースに考える時、2^3だとすると200までを考え、2^4だとすると300までを考えるという風に処理される
                      →似た問題がatcoderで出た時に役に立つかもしれないが、これだったらdoubleや多倍長整数でやる方が良いだろう

Pandigital products
  →n-digit number 
    →それぞれの桁の数字が一度しか登場しないような数字
      →7254は39*186=7254となり、乗数、被乗数、積において1~9のpandigitalとなってい    る
        →このような数字の積の和を求めよ
    →考え甲斐がありそうである
      →0を含まないため、やや厄介
        →結局9!試せば良いため、400000程度、さらに*が入る位置を取っても*8程度
          →あとは全パターン探索する処理を考えるのみ
      →実は5桁以上を考える必要がない
        →全登場桁が9桁を越えるため
          →9999*9999でも多い
            →1000*10=10000で9桁を超えるため処理不要
              →同じ積が登場した時は一度だけ加算する
                →10000*10000までやってクリアできた、 処理をキャンセルしていたため、さほど重くはならなかった
                
Digit cancelling fractions
  →n=numerator,d=denominator,c=cancel
  →49/98=1/2=4/8
    →10n+c/10c+d=n/d
  →30/50=3/5
    →10n+c/10d+c=n/d

Digit factorials
  →145は1!+4!+5!の和
    →各桁の階乗の和となっている数字の和を求めよ
      →数字の制限がないため、9!をいくつか足したものよりも数字が大きくなったらうち止め
        →あくまでも和であるため、そこまで大きくならない
          
Circular primes
  →197は循環素数である、971,719もそれぞれ素数
    →1000000以下の循環素数はいくつあるか
      →1000000以下の素数を出す
        →循環させて全て素数であればカウント
          →カウントしたら対象の素数を全てカウント済にする
         
Double-base palindromes
  →585=1001001001
    →同様に1000000未満の数字で基数2，10において回文となっている数の和を求めよ
      →1000000未満であれば普通にbinaryにしても計算量は大したことない
        →ごり

Truncatable primes
  →https://projecteuler.net/problem=37
  →3797は素数、797,97,7もそれぞれ素数、同様に、379,37,3もそれぞれ素数
  →このような素数11個の和を求めよ
    →素数テーブルを作る
      →下からやってく

Pandigital　multiples
  →https://projecteuler.net/problem=38
  →192*1=192 192*2=384 192*3=576
    →product is pandigital
      →1 to 9 pandigital 9-digit number 
        →一番大きいパンデジタル数になる時の(1,2,...,n)のnは何か
          →987654321と並んでいる時なので1で達成できることは確定している
            →しかし制約が1>nなので見つけろということである
              →とりあえずごりおしで

Integer right triangles
  →https://projecteuler.net/problem=39
  →直角三角形の周囲の長さpが与えられる
    →３辺の長さはそれぞれ整数とする
      →p<=1000において３辺の長さが整数の組み合わせとなる数が一番多いのは何か？その数を求めよ
      →２辺を決めてもう1辺が整数であることを求めればよさそうではあるが
        →小数点誤差を含めると計算がやや厄介
          →a^2+b^2=c^2となるためint*int=c^2を見つければいいか

Champernowne's constant
  →https://projecteuler.net/problem=40
  →チャンパーノウン定数のd1*d10*d100*d1000*d10000*d100000*d1000000を求める
    →上の数達は全て1<=dn<=1000000の間に現れるため、単純にループ可能
      
Pandigital prime
  →https://projecteuler.net/problem=41
  →what is the largest n-digit pandigital prime that exists?
    →最大は9桁
      →素数なので末尾が2,4,5,6,8は除かれる
        →単純に9!で考えた場合でも全探索可能
        →素数判定に10^5くらいかかりそうだったが行けた
        
Coded triangle numbers
  →https://projecteuler.net/problem=42
  →triangle numbers is given by,tn=1/2n(n+1)
    →英単語のそれぞれのアルファベットの番号を足した数字がtriangle numberであればtriangle wordを呼ぶ
    →テキストの中にいくつのtriangle wordがあるか？
      →ごり

Sub-string divisibility
  →https://projecteuler.net/problem=43
  →1406357289 0to9 pandigital number
    →先頭を除いた連続する3桁ずつを考えた時に2からの素数でそれぞれ割り切れる数の総和を求める


Pentagon numbers
  →https://projecteuler.net/problem=44
  →pn=n(3n-1)/2
    →pk+pj=pn and pk-pj=pu
    →のようになるkとjのうちD=|pk-pj|が小さいものは何か
      →となり合っているものでもk,jが大きくなればそれより小さい範囲でさらに小さいものが見つかる可能性はある
        →どのような数字の増え方をするのかを見る
          →n=1000で2000000いかない程度である
          →n=1000では足りなかったので3000にして二分探索を使用
            
Triangular, pentagonal, and hexagonal
  →https://projecteuler.net/problem=45
  →Triangle ,pentagonal,hexagonal
    →t285=p165=h143=40755 
      →40755 is common
    →find the next common number 
    →とりあえず3000まで埋めてみよう
      →1000000までやってとりあえず見つけた

Goldbach's other conjecture
  →https://projecteuler.net/problem=46
  →奇数の合成数は素数と2倍した2乗の数で現わせる事を提案した
    →反例がある
      →最小の反例は何か
    →とりあえず5000000くらいまで篩にかけてみる
      →10000までやれば十分だった

Distinct primes factors
  →https://projecteuler.net/problem=47
  →4つの素数から構成されている4つの連続した数の最初の数を求めよ
    →素因数分解を行う必要がある
      →一つ一つやっていけばいいか？
      
Self powers
  →https://projecteuler.net/problem=48
  →1^1 + 2^2 + 3^3 + ... + 1000^1000.の最後の10桁は何か？
    →double で処理
    →10^10でmodを取りながら処理する

Prime permutations
  →https://projecteuler.net/problem=49
  →1487,4817,8147は3330ずつ増加している
    →3つの数字は素数である
    →1つの数字は別の数字の4桁の組み合わせ違いである
  →3桁まではこのような数字はない
    →4桁は上の数字の他にまだ同じようなシーケンスがある
      →そのような数を見つけ、12桁の連続した数字として求めよ
  →ごりおし
    →10000*10000程度になるが4桁で収めるため、5桁になってしまうような基本数と増加数の組み合わせは飛ばす
      
Consecutive prime sum
  →https://projecteuler.net/problem=50
  →41は6個の連続した素数の和で表せる
    →100未満の素数の中では一番大きい連続した素数
    →1000未満では要素数21で953が一番大きい
    →では1000000未満ではどうか？
      →実装するだけ
    →再帰で実装するほうが良さそう
      →連続した素数なので再帰では難しい
      
Prime digit replacements
  →https://projecteuler.net/problem=51
  →13,23,43,53,73,83は素数
  →56003,56113,56333,56443,56663,56773,56993は素数
    →このような素数の集まりのうち、8つの素数で構成されているもののうち最初の数は何か？
    →隣合う数字とは限らない
  →素数列の桁は同じ
    →同じ数字だけを落としていく
      →6桁程度であれば64
      →7桁ならば128
      →8桁は256
      →9桁は512
      →10桁は1024
        →ここまでは許容できそう
          →しかしエラストテネスの篩を使用する場合10^7程度までである
            →やってみよう
      →同じ数字を消していくのはダメ
        →決まったところが同じ数字で消えているものを出さないといけない
          
C - HonestOrUnkind2
  →https://atcoder.jp/contests/abc147/tasks/abc147_c
  →正直者と不親切者がいる
    →bitで決めればよい
    →bitで決めて矛盾している状態を探る
      →パターンとしては0→1、1→1、1→0、0→0
      →不親切者が言ってるのは正直か不正直かは不明
        →aがbを1と言っている場合、bが言っていることは真である必要がある
        →b不親切
      →1→2が1　2→1が1 3→2が0で最大は2
      →3が正直と仮定すると2が不親切になるため1の言っていることと矛盾
      →2が不親切だとすると1が言っていることと矛盾するため1も不親切となる
        →正直者であると仮定する場合、言われている側が1の場合は0と言われてはいけない
        →正直者全てから正直者と言われている場合は矛盾しない
          →不親切者からはどちらと言われてもよい
            
Permuted multiples
  →125874*2=251748
  →元の数字と同じ数字が違う桁に位置している
    →2x,3x,4x,5x,6xでxと同じ数字が違う桁に位置している最小値を求めよ
      →一番上の桁は1で確定
        →2にすると桁が繰り上がる
      →2番目の桁は8未満
        →6の時に繰り上がらないように
      →ここまでは単純にわかる事
        →難易度からしても単純な全探索で出来るかもしれない
          
Combinatoric selections
  →12345
  →nCr かつ1 <= n<=100で1000000を超えるものはいくつあるか
  
Poker hands
  →https://projecteuler.net/problem=54
  →ポーカーの勝敗判定処理を実装
    →必要な情報は役
    
Totient maximum
  →https://projecteuler.net/problem=69
  →Relatively Prime →互いに素
  →n未満で互いに素な数字の数を表す関数φ(n)
    →1<=n<=1000000のうちn/φ(n)が一番大きくなるのは何か
      →gcd(p,q)=1と考えると
        →φ(n)を求めるにはn-2必要である
          →すると計算量がo(n^2)になるため重い計算になってしまう
            →nを素因数分解してその組み合わせ数をnから引けばよい
              →違った、例えば6の時に4をカウント出来ていない
                →何かいい方法はあるか？
                  →nが素数の時φ(n)はn-1となる
                    →これはn/φ(n)が大きくならないため省いて良い
                  →奇数よりも偶数の方が互いに素な数は少ない
                    →奇数は省いてよい
                  →小さい素数が多ければ多いほど互いに素になる数は少なくなる
                    →素数を取り出し、最小の公約数を出す
                      →最小の公約数のサイクル内で出てこない数字は全て互いに素
                        →

Lychrel numbers
  →https://projecteuler.net/problem=55
  →47+74=121である
  →349から始まり、349+943=1292,1292+2921=4213,4213+3124=7337　
    →和を次の値として3回繰り返すと回文になる
  →10000未満の自然数
    →50回未満の繰り返し
      →やるだけ
        →大きな桁のreverseと回文チェックを扱ったので関数化
        
Powerful digit sum
  →https://projecteuler.net/problem=56
  →10^100は大きな数である
    →1の後ろに200個0がある数字。各桁の数字を足しても1である
      →a^b a,b<100 における各桁を足した時の最大値は何か
        →性質を考える
          →桁が大きすぎるため、普通に計算する事は出来ない
            →例えば22^2=484=16,23^2=529=16となる
              →33^2=1089=18,24^2=576=18,99^2=9801=18となる
                →2乗程度ではそこまで大きな差とならない
    →99^99で100^100より小さいということはdoubleでinfにならない程度の桁数のような気がしてきた
      →100^100は3桁が99回2桁ずつ増えていくということで2*99+3=201桁である
        →doubleは300桁以上扱えたはず
          →精度がだめだったのでC#でやった

Square root convergents
  →https://projecteuler.net/problem=57
  →√2=1+1/(2+1/(2+1/(2+1...))
    →1+1/2=3/2 拡張1
    →1+1/(2+1/2)=7/5 拡張2
    →...8回目の拡張では1393/985となり分母の桁数を分子が越えている
      →1000回の拡張のうち何度分母の桁数を分子が越えるかを求めよ
        →分数の分子と分母を整数で扱って再帰的に計算出来るはずである
          →計算回数も1000*1000程度でいけるだろう
            →桁数が激しく大きくなる予感がする
              →試してみよう
                →C#でやった
    
Prime pair sets
  →https://projecteuler.net/problem=60
  →3,7,109,673は素数
    →この中から二つ選択し、前後につなげた数も素数
    →この4つの素数を足した数も素数
      →上記のようなことが可能な5つの素数を探し、その和を求めよ
  →とりあえず素数を列挙する
    →nC5とした時10000を超えていると計算に時間がかかる
      →探し方に工夫が必要
        →まずペアになる素数を探す
          →2は間違いなく使用しない
            →2桁以上の素数を一つ取り出す
              →各桁で二つに分ける
                →両方が素数であればペアとする
                  →ペアの片方の要素として5回以上登場している要素を探す
                    →ペアのもう片方側の対になっている要素と照合する
                      →5個以上同じであれば候補となる
                        →これをもう片方側全てに対して行い5個残るものを探す
                          →これもかなり大きくなるので無理
       →上の4つの素数に対してあと一つ見つけるので行けるのではなかろうか？
          →かなりでかくなるので無理
       →和から考える
        →4つの素数のパターンで考えると実はそんなに大きくならない？
          →3,7は入っているものと考える
            →するとn-10を3,7以外の3つの素数に分解する
              →x+y+z=n-10 かつx<y<z
       →3つまで固定しようがかなり重い処理になるためng
        →30000まででブルートフォースするとのこと
          →限界が分からないその線引きがかなり難しい問題である
            →ただしいアルゴリズムであればあまり遅くならないように問題設定されているのかもしれない
            
Cyclical figurate numbers
  →https://projecteuler.net/problem=61
  →8128,2882,8281
    →それぞれの下２桁は次の数字上２桁と同じ
      →それぞれtriangle,square,pentagonalで現れる
        →全て4桁である
  →6cyclic 4-digit numbers,triangle,square,pentagonal,hexagonal,heptagonal,octagnal
    →これの和を求めよ
  →順番がバラバラではある
    →まず数字を集める
      →どの数字から開始しても良いのでtriangleから開始する
        →
  
Cubic permutations
  →https://projecteuler.net/problem=62
  →41063625=345^3、56623104=384^3、66430125=405^3
    →41063625を並び替えて3つのcube(3乗)が出来る
      →上は3つだが5つのcubeで使われている数字が共通している数のうち一番小さいものは何か？
        →a<b<c<d<e
      →64bit整数では処理出来ないと思われる
        →doubleも大きい数字になると精度が悪くなる
      →多倍長整数で処理するのが正解っぽいが
        →C#で処理

Odd period square roots
  →https://projecteuler.net/problem=64
  →√23=4+√(23)-4
    ・この定数は√23の整数部分であると考えられる
      ・これで確認が可能
    ・変形して4+1/(1/√23-4)=4+1/(1+(√23-3/7))
      ・これを繰り返していくと定数部分が周期的になる
        ・この周期が奇数になっているものが√n n<=10000にいくつあるのかを求めよ
    ・変形をループに落とし込む
      ・1/(√n-x)=c+(√n-p/q)の変形方法
        ・１．分母の有理化をしている
        ・２
  ・後回しにする

Diophantine equation
  ・https://projecteuler.net/problem=66
  ・x^2-Dy^2=1
    ・ax+bx=1のように求められるか
      ・1x^2-Dy^2=1のようになっている
      ・2乗であるため、Dがsquareの場合は1になれない
        ・xとyが最小を取る場合のうち、D<=7ではD=5の時にxが一番大きくなる
          ・上のケースでD<=1000までで最大のxを求めよ
    ・blute forceか
      ・2乗を求めておく
        ・あるdについてx^2-1=Dy^2 ∴ (x^2-1)/D=y^2
          ・これを順に求める
      ・2乗の桁が大きくなりすぎるため考える
        ・(x^2-1)/y^2=dでもある
        ・(x+1)(x-1)/y=yd
        ・(x+1)/y=yd/(x-1)
        ・(x+1)/y^2=d/(x-1)
        ・(x-1)/d=y^2/(x+1)
          ・これでは有理数を扱う必要があるため、考え直し
          ・dとyからxを求める方が小さな数で済む
            ・dy^2+1=x^2
            ・連分数の繰り返しの数で求めるらしい
                ・最初に√の連分数をライブラリ化する必要がある
                
