arc002_3 コマンド入力
  →ABXYで作られた文字列
  →LとRに連続した２つのボタン入力を割り当てられる
  →最小入力回数を求める
  →1<=N<=1000
  →全部で16*16パターン96+160=256,256*1000しかないため全探索で処理可能

arc001_3 パズルのお手伝い
  →8クイーンで３マス埋まっている状態が初期値
  →8^5試せばよいだけであるため、そこまで計算量が大きくはならない
  →行ったり来たりする必要はないように思う

agc003_c BBuBBBlesort!
  →数列をソートする
  →操作１、連続する２つの数字を選び反転
  →操作２、連続する３つの数字を選び反転
  →ソートする為に必要な操作１の最小回数はいくつか
  →1<=n<=10^5
  →0<=Ai<=10^9
  →3つの数字を反転するということは真ん中の数字の位置は変わらず、一つ飛ばしで値が入れ替わるだけ
  →となると1の操作が必要なのはソート後の位置と奇数分位置が異なっている場合のみ
  →奇数個異なる箇所は偶数個ある
  →奇数個異なる数字の個数/2が答え
  →解説より、奇数番目と偶数番目がひっくり返っているということであるため、片方で奇数番目に現れて、片方で偶数番目に現れる数を数えるで奇数個異なる数字の個数/2と同じになる

arc005_3　器物損壊！高橋君
  →グリッドグラフ、コストは1、通れない場所をコスト2分までなら通れる、スタートからゴールまで行けるか
  →1 <= h,w <= 500
  →途中に通れない場所がない→Yes
  →スタートからBFSでマスを埋めていき通れないところまで到達させる
    →通れないところまで来たらなんらかの値を仮で入れる
      →行けるところ全て終わったら終了
  →ゴールからBFSして通れないところまで到達させる
    →通れないところまで来たらなんらかの値を仮で入れる
      →行けるところ全て終わったら終了
  →何らかの値が縦か横に二個連続しているところがあればYes、なければNo
  →二個連続しているところでは、通れる場所が離れていてなおかつ到達できる場合を満たすことが出来ない
    →それでもなんらかの値を仮で入れた箇所を通ってSからgまでたどり着ければ問題ない

arc006_3 積み重ね
  →トラックから積み荷を降ろす、それぞれの荷物は重さが定義されている。
    →積み荷を重ねることが出来るが、上に乗せた荷物が重い場合、下の荷物がつぶれてしまう→NG
  →全ての荷物を降ろした時に積まれている山の数を最小にしたい。
  →1<=n<=50
  →全部逆順で出てきたときは最大値となる
    →1,2,3,4,5,6,7,....
  →転倒数？
    →5 4 7 6→2
  →最長部分増加列？
    →5 3 4 7 6 8のパターンが反例
  →i,i+1を比較してでかいとき？
    →10 3 4 7 2 6のパターンが反例
  →サイズが50なのでシミュレーションでも行けそう→却下
  →後ろから見る
    →an<a(n-1)が増加している場合は同じ山に配置出来る
      →サイズが50なので取り出したところはフラグを立ててもう一度取らないようにする
        →処理出来る数字がなくなるまでの回数が答え

arc007_3　節約生活
  →oxの配列→o視聴可能な時間、x視聴不可能な時間
    →テレビをつけると視聴パターンが無限に繰り返される、テレビはつけると消せない
      →全ての時間視聴するための最低限なテレビの数を求めよ
  →1<=N<=10
  →少なくともoは一つ含まれる
  →最大10台用意
  →全部の時間に配置して、抜き取って良い場所を抜き取る？
  →1<<10だから全パターン試しても間に合う
  →全てのテレビをつけるまでに視聴出来ない時間があってもいいが、付けたら視聴出来ない時間があってはならない
    →2周目までに全て決まるはず
    →1周目に配置しても２周目に配置してもその次の周の見える時間は変わらないため、１周目のみに全て配置する事を考える
  →1個目は埋まっているためn-1の全パターンでも良さそう

agc040_b Two Contests 難易度青のくせにまだピンと来ていない
  →左端の最大と右端の最小がクロスしているかどうかで答えが変わってくる
    →しかし解説を読むと場合分けせずに答えが出るということらしい。
  →それぞれのコンテストを集合、問題iを解ける人の範囲を区間i、コンテストの楽しさを含まれる区間の共通部分の長さとする
    →半開区間にすることで区間の長さをr-lで表すことが出来る
  →ポイントとしては左側の最大と右側の最大を軸に考えることが出来れば意外とシンプルになる、そこに気が付かないとクリアは難しい
  →あとは解説の通り一つの区間と残りの区間の共通部分を取る(左側の最大と右側の最大が一つの集合に含まれている場合はこれで最大値が得られる)
  →ri-左側の最大=sと右側の最小-li=tをそれぞれ計算してtの昇順、タイブレークはsの降順でソートする
    →すると、この集合を一つ一つ処理していくと、sがだんだん小さく、tがだんだん大きくなっていく、ここでs+tの最大を取る

arc011_3 ダブレット
  →ある単語を別のある単語に変換する。人もずつ変換する過程で別の単語を経由していく、その最小手数を求める
    →最初と最後の単語、1<=N<=1000の経由出来る単語が与えられる
      →変換与えられた単語を経由して変換不可能である場合-1を出力する
  →グラフ化出来ないか？グラフ化出来るならダイクストラで対応可能
    →n^2は可能であるため、一文字違いの単語を全探索してグラフ化することは可能である。
      →グラフはインデックスに置き換えれば良い
      →作られたグラフで最初の単語から最後の単語までの最短路が答えとなる
      
  

