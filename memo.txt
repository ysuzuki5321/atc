arc002_3 コマンド入力
  →ABXYで作られた文字列
  →LとRに連続した２つのボタン入力を割り当てられる
  →最小入力回数を求める
  →1<=N<=1000
  →全部で16*16パターン96+160=256,256*1000しかないため全探索で処理可能

arc001_3 パズルのお手伝い
  →8クイーンで３マス埋まっている状態が初期値
  →8^5試せばよいだけであるため、そこまで計算量が大きくはならない
  →行ったり来たりする必要はないように思う

agc003_c BBuBBBlesort!
  →数列をソートする
  →操作１、連続する２つの数字を選び反転
  →操作２、連続する３つの数字を選び反転
  →ソートする為に必要な操作１の最小回数はいくつか
  →1<=n<=10^5
  →0<=Ai<=10^9
  →3つの数字を反転するということは真ん中の数字の位置は変わらず、一つ飛ばしで値が入れ替わるだけ
  →となると1の操作が必要なのはソート後の位置と奇数分位置が異なっている場合のみ
  →奇数個異なる箇所は偶数個ある
  →奇数個異なる数字の個数/2が答え
  →解説より、奇数番目と偶数番目がひっくり返っているということであるため、片方で奇数番目に現れて、片方で偶数番目に現れる数を数えるで奇数個異なる数字の個数/2と同じになる

arc005_3　器物損壊！高橋君
  →グリッドグラフ、コストは1、通れない場所をコスト2分までなら通れる、スタートからゴールまで行けるか
  →1 <= h,w <= 500
  →途中に通れない場所がない→Yes
  →スタートからBFSでマスを埋めていき通れないところまで到達させる
    →通れないところまで来たらなんらかの値を仮で入れる
      →行けるところ全て終わったら終了
  →ゴールからBFSして通れないところまで到達させる
    →通れないところまで来たらなんらかの値を仮で入れる
      →行けるところ全て終わったら終了
  →何らかの値が縦か横に二個連続しているところがあればYes、なければNo
  →二個連続しているところでは、通れる場所が離れていてなおかつ到達できる場合を満たすことが出来ない
    →それでもなんらかの値を仮で入れた箇所を通ってSからgまでたどり着ければ問題ない

arc006_3 積み重ね
  →トラックから積み荷を降ろす、それぞれの荷物は重さが定義されている。
    →積み荷を重ねることが出来るが、上に乗せた荷物が重い場合、下の荷物がつぶれてしまう→NG
  →全ての荷物を降ろした時に積まれている山の数を最小にしたい。
  →1<=n<=50
  →全部逆順で出てきたときは最大値となる
    →1,2,3,4,5,6,7,....
  →転倒数？
    →5 4 7 6→2
  →最長部分増加列？
    →5 3 4 7 6 8のパターンが反例
  →i,i+1を比較してでかいとき？
    →10 3 4 7 2 6のパターンが反例
  →サイズが50なのでシミュレーションでも行けそう→却下
  →後ろから見る
    →an<a(n-1)が増加している場合は同じ山に配置出来る
      →サイズが50なので取り出したところはフラグを立ててもう一度取らないようにする
        →処理出来る数字がなくなるまでの回数が答え

arc007_3　節約生活
  →oxの配列→o視聴可能な時間、x視聴不可能な時間
    →テレビをつけると視聴パターンが無限に繰り返される、テレビはつけると消せない
      →全ての時間視聴するための最低限なテレビの数を求めよ
  →1<=N<=10
  →少なくともoは一つ含まれる
  →最大10台用意
  →全部の時間に配置して、抜き取って良い場所を抜き取る？
  →1<<10だから全パターン試しても間に合う
  →全てのテレビをつけるまでに視聴出来ない時間があってもいいが、付けたら視聴出来ない時間があってはならない
    →2周目までに全て決まるはず
    →1周目に配置しても２周目に配置してもその次の周の見える時間は変わらないため、１周目のみに全て配置する事を考える
  →1個目は埋まっているためn-1の全パターンでも良さそう

agc040_b Two Contests 難易度青のくせにまだピンと来ていない
  →左端の最大と右端の最小がクロスしているかどうかで答えが変わってくる
    →しかし解説を読むと場合分けせずに答えが出るということらしい。
  →それぞれのコンテストを集合、問題iを解ける人の範囲を区間i、コンテストの楽しさを含まれる区間の共通部分の長さとする
    →半開区間にすることで区間の長さをr-lで表すことが出来る
  →ポイントとしては左側の最大と右側の最大を軸に考えることが出来れば意外とシンプルになる、そこに気が付かないとクリアは難しい
  →あとは解説の通り一つの区間と残りの区間の共通部分を取る(左側の最大と右側の最大が一つの集合に含まれている場合はこれで最大値が得られる)
  →ri-左側の最大=sと右側の最小-li=tをそれぞれ計算してtの昇順、タイブレークはsの降順でソートする
    →すると、この集合を一つ一つ処理していくと、sがだんだん小さく、tがだんだん大きくなっていく、ここでs+tの最大を取る

arc011_3 ダブレット
  →ある単語を別のある単語に変換する。人もずつ変換する過程で別の単語を経由していく、その最小手数を求める
    →最初と最後の単語、1<=N<=1000の経由出来る単語が与えられる
      →変換与えられた単語を経由して変換不可能である場合-1を出力する
  →グラフ化出来ないか？グラフ化出来るならダイクストラで対応可能
    →n^2は可能であるため、一文字違いの単語を全探索してグラフ化することは可能である。
      →グラフはインデックスに置き換えれば良い
      →作られたグラフで最初の単語から最後の単語までの最短路が答えとなる
      
agc024_c Sequence Growing Easy
  →長さNの数列Xがあり最初は全ての要素が0,Xのi項目をxiで表す。長さNの数列Aが与えられる、Aのi項目はAi、以下の操作を行い、XとAを等しく出来るか
    →1<=i<=N-1なる整数iを選ぶ。X(i+1)の値をXiの値に1を足したもので置き換える
  →先頭は0以外ありえないため0でなければ-1
    →先頭の次は0~1以外ありえないためそれ以外なら-1
      →上のように各iのmaxは決定している。
  →前後で2以上の開きがある場合も-1
  →1になっている箇所はその前のところを0の時に操作したものである、
    →例えば011となっている場合前からやると連続しているところで012となってしまうため、後ろから操作する
    →011012212の前の状態は011011010→011012212からは011012332など作成可能
  →各数字から先頭になっている場所を特定することは出来る。しかもその数が操作の回数となっている
    →前の数字と比較して+1されている時は+1、前の数字と比較して=の時は+Ai
    →前の数字と比較して-されている時は+ai
      →以上で反例はないと思われる。
      
codefestival_2016_qualB_d　Greedy customers
  →N人の人が1列に並んでいて、i番目の人の所持金はAi。品物を選んで価格Pを設定し、前の人から順にその品物を見せていく、各ひとは品物を見せられた時、その価格Pがその人の所持金以下だったと気品物を購入しその人の所持金がP減少する
    →出来るだけ多くの品物を売りたい、しかし売った人の所持金が0になるとその人は帰れない。
      →所持金を0にしないように、最大でいくつの品物を売ることが出来るか求める。
  →1<=n<=100000,1<=ai<=1000000000
  →全部1にすると先頭の人から後ろに行かない→×
    →先に先頭を1にして大きい数を後ろに回す？
      →前から考えられる、先頭は1になるまで削る、先頭以外はa(i-1) + 1< aiである場合、最低値段をa(i-1)+1として販売可能
        →割り切れる場合は0になってしまうため、ai/(a(i-1)+1)で割り切れる場合は-1する。（実は先頭も同じ）この和が答え
        
jsc2019_qual_c Cell Inversion コンテスト中に解けなかったやつ
  →2N個のマスが並んでいる、B,Wで埋まっていてBは黒、Wは白を表す。異なる2マスを選んで色を反転する。同じマスは２回以上選べない
    →N回の操作終了後全てのマスを白色にする方法が何通りあるかを確かめる
  →解説では選ばれた２マスが左側か、右側かというのは各マスについてどちらか定まるということである。
    →まず、各マスが左側になるのか右側になるのかを探る
      →BWWBの場合はLLRRとなる
        →この例を見る限り二つ同じものが並んでいる場合は左右決まりそうな気がする
          →BWWWBとなると真ん中は選べないため上の考え方はダメ
        →BWWWBとなった時、LLXRRとなる
        →BWWWWBとなると、LLRLRRとなる
    →左右の端がWの場合はXとなる、つまりB......Bというパターンのみ考えれば良い
    →偶数個並んでいる場合はLRLRLR...とおける
    →奇数個並んでいる場合は..LLXRR..となる？
      →BBBWWWBBBとなるとLXRLXRLXRとなるか？→OK
      →BBBBBの時、LXXXR以外は成立しない→NO
        →LRLXRかLXRLRがある
          →BBBBBBBの時は？LRLRLXR,LRLXRLR,LXRLRLR等が可能、len(m) / 2パターンがある
            →奇数になっているところを集めて後でまとめて掛け算可能
       →BWWBのように挟んでいる場合、対岸がRになる
        →BWWBWWBは?→LLRXLRRで行ける
          →全体を通して偶奇を取る必要がある？
            →BWWBWWBWWBの時はLLRRLRLLRRである
              →BBWWBWWBBは？LRLRLLRXR,LXLRRLRLRとなる、LRのパターンが変わる
      →LRのパターンは一意ではない、LRが決まればそこから求められる組み合わせは一意になる
      →LRからの処理順の計算方法
        →LLRRで考える→1つ目が選べるRは２つある、2つめが選べるRは1つだけになる
          →LRLRLRで考えると1つめが選べるのは3つある、2つめを選んだ場合、3つ目のLが選べるのは２つ、4つめを選んだ場合、3つ目のLが選べるのは１つだけとなる
          →LRLRLRLRで考えると組み合わせはLRLRLRLRとLXXRLXXRとLXXRLRLRとLXXXXRLRとLXXXXXXRとLRLXXRLRとLRLXXXXRとLRLRLXXRがある。
            →奇数の時と合わせると結構な組み合わせの数になる
            →さらに順番も計算する必要がある
          →組み合わせとしては、全てWにするために必要なLRのペア数がそれぞれいくつあるか分かれば、それぞれを階乗倍すれば答えは出る
            →計算量が大きい
  →操作手順は無視できるということ、それはわかるが
    →操作をN回行うということを忘れていた
      →この制約ならばそれはN!一択である、N回までに、であれば難易度は相当上がる(というか不可能？)
        →考えなおし
          
 agc033_c Removing Coins
  →木を用いて二人でゲーム、最適な行動
    →1<=N<=200000
    →N頂点、1~Nが割り振られている、N-1本の辺のうちi本目の辺は頂点aiと頂点biを結んでいる
      →各頂点にコインが一枚ずつ置いてある、操作を行えなくなった方が負け
        →操作、コインが置いてある頂点を一つ選び、その頂点vにおいてあるコインをすべて取り除く
          →その後、木上に残っているコインをすべて、今置いてある頂点に隣接する頂点のうちvに一番近い頂点に移動させる
    →1 2,2 3,2 4で、1を取り除いた場合に頂点１に1枚、頂点2のコインが2枚になる
      →2を取り除くと２にコインが3枚ある状態になる
    →grundy数の問題？
    →コインが置かれている頂点は常に連続している、つまり、コインを取る場所により残りのコインの枚数が変わるのが肝となる
      →端を取るとコインが置かれている場所が一つ減る
      →複数の辺が接続している場所を取るとその分コインが置かれている場所が減る
        →端を取るとその頂点にコインが集まるように移動する
        →端以外を取った場合は、全て同じ盤面になる
          →ある頂点から延びる枝が2以上であり、全ての枝の頂点数が同じである場合、端を取った場合は、その頂点がある辺のみ長さが変わらず、その他の辺は長さが１減る
            →一番長い頂点数を持つ辺の長さ分はゲームが可能？
            →頂点間が一番長い辺でゲームをしているのと変わらない？
              →DFSで一番長い頂点間は求められる
    →枝の伸びている方向を考える 
      →1,2のみであればsecond、1,2,3であればfirst、1,2,3,4の場合は残り2か所にするか3か所にするか選べる
        →残り2か所に出来るのでfirstとなる
      →1 2,2 3,2 4,4 6,6 5の場合はsecondとなる
        →Nは偶数、処理としては、一手目が終わった後、残りの石の位置は1,2,4,5、2,4,5、2,4,5、2,4,5、2,4,5,6となる
          →3になるか4になるかであるため、secondが勝てる
      →1,2,3,4,5の場合、4にするか5にするかを選べる、
       
nikkei2019_2_final_a Count Triplets
  →a1,a2,....anのNの要素
    →ai<aj>akを満たす(i,j,k)の組の個数を求める
      →座圧して1<=ai<=5000の範囲にしてしまう
        →累積和で左と右それぞれからl[5000][5000]、r[5000][5000]の範囲で累積和を取る
          →あとはj=2~n-1までajを処理して、その和を求める
   
nikkei2019_2_final_b NIKKEI String
  →文字列sを6分割して分割後のs1,s2,s3,s4,s5,s6がNIKKEI型(s2=s6,s3=s4)となっている個数を求めよ
    →6≤|s|≤500
    →s1を前からとs6を後ろからの2重ループを軸に考える
      →s6のindexでs1+1~s1+1+indexでs2も作れる
        →s2=s6の時にs5を後ろから取っていく
          →残りの文字列を半分にして同じ文字列が二つ作れればNIKKEI型
            →いちいちsubstringを使うのも計算量的に微妙であるため、500*500のstring配列に事前に格納しておく
            
nikkei2019_2_final_c Largest N
  →H行W列のマス目があり、それぞれのマスは黒または白で塗られている
    →マス(ai,bi)は白で塗られていて、他は黒で塗られている
      →自然数kに対してマス目がサイズkの'N'を含むとは、次の条件を満たすi,jが存在する
        →マス(i+t,j)(0<=t<k)が全て黒
        →マス(i+t,j+t)(0<=t<k)が全て黒
        →マス(i+t,j+k-1)(0<=t<k)が全て黒
      →このマス目に含まれる'N'のサイズの最大値を求める
    →黒マスがNの形になっている箇所を探す、形は全て正方形と考えて良い
      →サイズは3000*3000=9000000
        →正方形の数は
      →サイズa,bがありa<bの場合にaで作れず、bで作れる場合が存在する
        →2分探索では不可能
      →縦、斜めで尺取りを行い、黒で埋まっている範囲を出す、スタート地点のindexで最後まで埋める。
        →それぞれのテーブルを作って事前計算しておく
    →探索は縦か斜めに行えばいい
      →数は？まずスタート地点となるのが3000*3000箇所ある、それぞれに対して3000箇所考えられる→ストレートにやるとTLE
        →Nの最大を常に持っておけば、それ以下の範囲で探索は不要となる
        →縦、横、斜めそれぞれの最大の最小値がNの最大値となる
        →白始まりは存在しないため、白であれば探索は飛ばす
          →配置によってはTLEになりそう
            →Nの左上には情報が下の最大と斜め下の最大の情報が集められる、その小さい方がその左上から作れる最大N
            →Nの右下にもが集められるかもしれないが、不要である
              →探索の範囲は狭まったが、どうしても内部でループをする必要があるところまでしか削れない
              →実はNの左上にNの右側棒の情報が集められる気がする
                →ダメである、ループが必要となる
                  →始点と終点がある限り、これは難しい
                  →上の考え方で処理を作ってみよう

agc005_c　Tree Restoring
  →長さNの数列a1,a2,a3....an
    →頂点iと最も遠い頂点の距離がaiとなる木
      →存在すればPossible,しなければImpossible
    →1<=N<=100
    →出来ないパターンN=3の時1,1,1、N=3の時は1,2,2しか存在出来ない
      →各頂点iはあまり関係なし
      →一番aiが短い所により最大の距離も決まる
        →一番短い所は木の中心となる
          →最大の長さを取る頂点maは確定で二つ以上存在する
            →なければImpossible
          →maが2つ以上存在する時は確実に一つの中心を通っている
            →maが4つ以上の場合に二つの完全な中心が存在すると仮定すると、木なので、maの距離が伸びることになる
          →中心となるのはmaが偶数の場合二つ(どの枝も通る完全な中心は一つ)、奇数の場合一つ
            →完全な中心は一つと仮定して組み立てて良い
    →maの片方をまず配置する
      →次はma-1を一つ選ぶ
        →次はma-2を一つ選ぶ
          →中心oまで来たら、maが偶数の場合、oを選び、奇数の場合、o+1を選ぶ
            →maまで到達する
              →残りの頂点をai-1の場所に追加していく
                →完成すればPossible
    →maが奇数の場合、中心は二つ
    →maが偶数の場合、中心は一つ
      →このパターン以外はImpossible
    →あとは中心より上～maまでが2つ以上あり、中心未満が０個であればPossible
   
agc008_c Tetromino Tiling
  →7種類のテトリミノがある、
    →そのうちK個を組み合わせ縦2マス、横２Kマスの長方形を作ろうとしている。
      →縦横逆でも同じである
    →それぞれのミノが接する部分と偶奇を考える
      →すると数を減らせる
        →ミノは全て使う必要はない
          →T,S,Zは使うと長方形に出来ない？
            →I,O,L,Jのみで考えれば良い？
        →全パターン処理可能となる
          →I型が奇数の場合、J,Lがそれぞれ一つ必要になる
            →I,J,Lが3,2,2となっている場合、I,J,Lで3、I*2で2=5となる→×
              →I*2,j*2,L*2でとると6になる
              →I,j,L*2でも6となる
            →I,J,Lが3,3,2となっている場合、I,J,Lで3,I*2で2,J*2で7となる
              →I*2,j*2,L*2だと6の為上の場合はI,J,Lを取る方が正しい
            →可能な限りI,J,Lの組み合わせでとるのが正しい？      
              →I,J,Lを2個作るのはそれぞれを２個づつ作るのと同じ
                →I,J,Lを一つ作るか０個作るかで場合分けして終わり

agc014_c　Closed Rooms
  →魔法を１回使うと部屋をK回移動できる、また、K個の部屋を開く事が出来る
    →K個の部屋を開く事が出来るので、最初に移動できる範囲で外に一番近い所に移動出来れば良い？
    
agc014_b Unplanned Queries
  →木構造のデータに対してM個のクエリを流す
    →クエリはai,biとして頂点ai~bi上頂点の数字を1増やす
      →最終的に木の数字が全て偶数になっているかチェックする
  →2<=N<=100000,1<=M<=100000
    →共通の親が分かればそこからトップダウン的に処理できる
      →ダブリングしてみよう
    →親子関係があればそのまま処理出来る
      →木が存在するかどうかである、最初から木があるわけではないのでダブリング等は出来ない
    →クエリで偶数回出てきているかどうか？
      →例えば2,2で1 2,1 2の場合は真
      →例えば3,3で1 2,1 3,2 3である場合も真
        →正直Nで出てきていない頂点は考える必要がない
      →例えば4,4で1 2,2 3,3 4,1 4である場合も真
  →解説を見る
    →(ai,bi)の時ルートまで通ってからそれぞれのところまで行くという風に考えると(r,ai),(r,bi)と考えることが出来る
      →(r,ai),(r,bi)を見たときに(ai,bi)のLCMをPとすると(r,P)は２回通るため、(r,ai),(r,bi)としたときに全く同じ状態となる
        →木構造である場所から別の場所に行くときにルートを通るようにするという考え方はまた出てくる可能性がある
  
agc026_c String Coloring
  →2Nの小文字からなる文字列Sが与えられる
    →各文字を赤か青に塗り分ける
      →赤に塗った文字列を左から右、青に塗った文字列を右から左に読んだ文字列が同じ
        →これがいくつあるか
  →1<=N<=18であるため、全探索でも出来る
    →文字列は2*Nであるため、無理
  →32bit整数で表せないこともあるため、普通にカウントするのも無理とわかる
    →最初の文字を赤か青に固定して考える
      →最終的には×2になるためOK
        →文字もそれぞれ２つずつないとだめ
      →違う色の最初の文字は同じ文字になる
        →後ろから探して違う色の最初の文字を見つける
          →そこが違う色の最初の文字になるとは限らない
          →そこが違う色になるとは限らないが、それより右側の文字を反転したものはは違う色が全て持っている文字列にならないとならない
        →それぞれの文字がどの文字と反転しあうかを調べる？ 
          →abccbaであれば1,5の組み合わせ、2,4の組み合わせで行ける
            →1,2,3 1,2,4 1,3,5, 2,3,6 2,4,6 3,5,6がそれぞれ使える
          →abcbcaとなるとacbとcbaの組み合わせが作れる
            →1,3,4 3,4,6のみ
            →文字列が反転している状態であれば、組み合わせはかなり作れる 
          →abbccaだと組み合わせは出来ない
        →aaaaを考える
          →1,2 3,4
          →1,3 2,4
          →1,4 2,3
            →に分けられる
        →baaaabを考える
          →1,2,3 4,5,6
          →1,3,5 2,4,6
          →1,2,4 3,5,6
          →1,4,5 2,3,6
          →1,2,5 3,4,6
          →1,3,4 2,5,6
            →に分けられる
            →aaaaとの違いは開始地点を変えられないところ
        →bbaabbaaを考える
          →1,2,7,8 3,4,5,6
          →以上となる
        →同じ文字が連続しているところはそれぞれ入れ替わる事が出来る
          →baaaabを再度考える
            →1,2,3 だが、これは2,5 3,4を入れ替えることが出来る
            →1,2,5 は2,3 4,5を入れ替えることが出来る
              →しかし1,2,3の入れ替えで1,2,4 1,3,5は出ているため、掛け算するとアウトとなる
              →つまり別の考え方が必要
                →600点程度かつ青パフォ問題ではあるのでもっとシンプルに考える方法があるのではないか？
                  →見落としてる何かはないか？
                    →bbacacbbとなっている時に右側の先頭文字は変えられるか？
                      →1,2,4,5
                      →1,4,5,8で出来る
                        →これは対称になっていて同じ位置に存在する場合、入れ替えが可能ということを示す
                          →上の例では頭から取ると
                            →bbca,bbcaと並ぶ
                              →このbの位置は先頭か後ろへと入れ替わる事が出来る
                                →bcab,cabb
                                →では内部で同じような連続しているところがある場合はどうか
                                  →baaccaab
                                    →baac,baca,bcaaが取れる
                                  →挟んでいて同じ位置にある連続した文字は、挟んでいる文字を軸に位置を入れ替えることが出来る
                            →bbaabbaaはどうなるだろう
                              →bbaa,bbaaとなりaを挟んでいるが...  
                                →挟まれているaは片方にしか存在していない
                                  →bbaaaabbの場合は挟まれているaはどちらにも存在している
  →解説見た
    →やはり600点なのに上のような方法で解くような問題ではなかった
      →文字列を半分にし、文字列の組み合わせを全列挙する
        →そこでマッチングしてクリアである
          →やはりN<18くらいだと全列挙が基本的なアイデアであって、そのまま処理出来るように出来ている
                              
agc037_c Numbers on a Circle                            
  →１～Nの番号がついている、i番目の数はai、i番目の生成数がbiとなるようにしたい
    →1<=i<=Nなる整数iを一つ選ぶ
    →i-1,i,i+1番目の数をそれぞれa,b,cとしたとき、i番目の数をa+b+cに置き換える
      →操作が出来るか判定し、可能である場合は操作解消として考えられる最小の値を求める
  →1<=N<=2*10^5
  →1<=aiなのでiを操作するとき、2<=p増える
    →小さい所から処理していかないと、bにすることは出来ない
      →b1<b2として、b2を先行した場合、b1<a1+b2となるためNGとなる
        →なので小さい数から組み立てると考えてよい
    →効率的な数字の増やし方を求める
      →biはaiが持っている数字からしか組み立てることが出来ない
        →そのため、操作を繰り返すことによりどのような組み合わせになるのかを考える
          →入力例3の 5 6 5 でb2を何回か操作することを考えると 16 26 36 となる 5,5,6 5,5,5,5,6 5,5,5,5,5,5,6と言った風に組み合わせられている
            →5 6 5 2 をb2,b3と操作する 5 16 5 2,5 16 23 2 
            →5 6 5 2 をb3,b2と操作する 5 6 13 2,5 24 13 2
              →もちろん順番が変わると数字が変わる
    →整数系の問題である
      →AGCなのでひらめきで解ける系の問題だと思う
        →操作を行う回数がそこまで大きくならない
          →ai,ai+1を交互に操作するとすぐに数字が大きくなる
            →手続きさえわかればシミュレート可能？
              →手続きが難しい
            →一番数字がでかい所は前の一手は自分のところ-両隣となる
              →そこから逆にシミュレート出来る？
                →逆シミュレートで大丈夫だった
    
arc033_3 データ構造    
  →数の集合Sに対する以下のクエリを処理
    →1.Sに数Xを追加
    →2.Sに含まれる数のうちX番目に小さい数を答え、その数をSから削除
  →1<=Q<=200000
    →セグ木、平方分割、等で可能なように感じる
      →BITはどうだろう？
        →これも行けそうな気がする
          →いいプラクティスになりそうなので全て実装するのもありのように思う
          
arc008_3 THE☆たこ焼き祭り2012
  →参加者含めてN人、たこ焼きをN個持っている、全員に一人一個
    →たこ焼きを投げる
      →座標と速度が与えられる
        →参加者1<=N<=1000
          →お互いの距離が与えられる
            →グラフに出来る
              →受け取る速度の上限、投げる速度の上限が与えられているので、それと距離を考えて辺のコストを求められる
          →一秒に一回しか投げられないため、その対処をする
            →参加者の元にたこ焼きが届くのは一秒に一回である
              →最初の地点からは1秒おきにしか投げられないので、最短距離で届いた場合、もう一個が届くのは同じ最短距離を通るため１秒後になる
              →別なルートから同時に届くといった場合、最短距離がそっちだったということになる
                →順序が入れ替わるとそれぞれが別の秒で起こるだけ
            →最短距離から組み換えを行う、最短距離が長いを早く投げた方が得である
              →貪欲？
                →降順ソートしてそれぞれに秒を加算してその最大を答えとする
                  →あってたけど、0人目も計算に入れててWAになっていたため悩んでいた
                
arc012_3 五目並べチェッカー
  →盤面が異常になっていないかどうかチェック
    →1どちらかのプレイヤーの勝利条件を満たしているのに、もう片方のプレイヤーがさらに碁石を置いている
    →2お互いが置いた個数がありえない状態になっている
      →注意点→oが黒、xが白
      →ななめもある
  →個数が２個以上離れているか、１個違いで白が多く置かれているのはだめ、2に反する
  →9個が並んでいる状態まではありえる
    →同じ色で5個~9並んでいる状態が二つ以上存在するのはおかしい
      →が、縦横斜めが重なっているところならあり得る
        →重なっているところを最後に置く想定
   →両方が勝利している状態はダメ
   →黒が勝っている状態で白がもう一手打っている
   →白が勝っている状態で黒がもう一手打っている
    →手数を数えてあれば分かる
  →ようやくAC出来たが、最後に打った一手を除いた時に勝っていればおかしいという判定で行けると分かった
    →上のやり方がごり押ししたがif文の嵐で死ねる

arc077_c guruguru 
  →1以上m以下の整数、aiの明るさにしたい
    →1.明るさを+1する
    →2.お気に入りの明るさxにする
  →ボタンを押す回数の最小を求めよ
    →1<=N,M<=100000
      →順送りしか出来ない
        →順送りのみした時どれだけ押すか？
      →M*2の配列を作る
        →前後でポイントする
          →累積和を取る
            →増えたり減ったりする特殊な累積和
              
arc063_c 木と整数 / Integers on a Tree
  →木が与えられる
    →木のいくつかの頂点に数字が与えられる
      →辺でつながっている２頂点の差が1になるように全ての頂点に数字を入れられるか
    →1<=N<=100000
  →ある数字が入っている頂点aから別の数字の入っている頂点bに到達する場合
    →a+間の頂点数+1<bかa-間の頂点数-1>bになっている場合はNO
    →aからbに到達するために辺の数の偶奇と場合、aとbの差の偶奇は同じでなければならない
  →頂点数が多いため、O(NlogN)程度で処理する必要がある
    →数字が入っている頂点からスタートする
      →DFSで各頂点に対して、どの数字が入っている頂点に到達するかを集める
        →数字が入っている頂点に到達したら、距離をチェックする
          →ダメな場合はNG
          →OKであればその地点の距離を0にしてさらに進む
            →到達可能な範囲内で、偶奇が合っているかのチェックは出来た
      →二つ以上の頂点から到達する事はないため、親子関係のみ考えれば良い
      →子の距離を戻り値として受け取る
        →複数存在する場合でもその頂点の数字からはそれぞれの子の距離は独立して考えてよい
          →端まで行っても数字が入っている頂点がない場合は増加させ続けるか減少させ続ければ良い

abc147_e Balanced Path
  →グリッドのマスを赤か青で塗る
    →そのあとマス(1,1)から(H,W)まで移動する
      →一回の行動でマス(i,j)から(i+1,j)もしくは(i,j+1)に動く事が出来る
        →経路上のマスの赤く塗られた数の和と経路上のマスの青く塗られた数の和の差の絶対値を偏りと呼ぶ
          →偏りの最小値を求めよ
  →2<=80<=H,2<=W<=80、0<=Aij<=80、0<=Bij<=80
    →制約上はO(max(H,W)^4)まで可能
      →本番中は赤グラフ青グラフで分けるようにして対応したことを思い出した。
        →それで最短距離を求めたがWAである
          →各頂点は+-(Aij-Bij)となる
            →取れる範囲がだんだんと広がっていくタイプの問題である
              →dp[80][80][12800]で各マスを埋めて行けば良い

arc034_3　約数かつ倍数
  →2個の正整数A,Bが与えられる、A!の約数でありB!の倍数でもあるような正整数の個数をINFで割ったあまりを求めよ
    →1<=B<=A<=10^9,A-B<=100
      →整数の問題(苦手なのでちょうどよい)
        →対象の数xはB!<=x<=A!であり、B!の倍数でありA!の約数
          →B!とA!はそれぞれ確実に含まれる、(A!=B!である場合は1)
            →間の数を素因数分解し、それぞれの因数がB~Aの間にどれくらい含まれているか求める
              →Aの含め方が難しい
                →計算間違えてただけで合っていた。4!を18と計算して混乱していただけ
                  →4!=24,3!=6で4!=2*2*3*2として3!=3*2となれば、2*3*2も2*2*3*2もA!の約数でありB!の倍数である。
                →プラクティスとしてはなかなか良問             
          
arc036_c 偶然ジェネレータ
  →乱数表を作る、0,1のみで構成されるNの数列
    →0の個数と1の個数の差がK以下
      →このような乱数表がいくつあるか求めよ
    →1<=N<=300,1<=k<=N
      →0,1,?のみ
    →1を+方向、0をマイナス方向とした範囲を持ったdpで行けるのでは？
      →300を起点として動かす
        →?は各点を+か-に動かす
    →問題を勘違いしていた、乱数表からどのような連続する部分列を取り出しても、その部分列に含まれる0の個数と1の個数の差がk以下でなければならない
      →なので問題としては一段難しい
        →9 4 ?011?1110の場合は2個目の?に対して1は入れられない
          →そのため、ある?は1か0に決まってしまう場合がありえる
        →一つの変更が全区間に及ぶのが難しい
          →総数をINFで割った余りを出すため、全探索は無理
            →各iから以前の状態を見るのは可能
              →ある?を0にするか1にするかを考える
                →その?を含むそれより前の区間を見ると、各iに対して範囲が取れる、それでkを越えた場所は切り捨てる
                  →各始点から開始した場合をマージするのが難しい
                    →i=1~nでの区間全体での結果を残す=>'1
                    →i=2~nの結果は'1の結果を-(s(i=1))した状態になる
                      →111である場合+3になる11であれば+2となる
                      →101であれば+1で01であれば+0となる
                      →1010であれば0となり010であれば-1となる
                      →??である場合2=1,0=2,-2=1にある状態、?だと1=1,1=1にある状態
                        →?が来た時にさらに外側に行くことは？
                        →途中の状態が見えないため、このやり方では出来ない
         →さすがにあきらめて、検索したが、解けるレベルのDPではなかった
          →https://blog.en30.net/2015/04/07/003011/
            →上の例では基準未満0に行かないように処理をし、kを越えたところでアウトとしている、またDPはメモ化再帰で行っている
              →この遷移は初めて出会ったと言えるレベル
             
arc042_c　おやつ
  →P円までのおやつを持っていくことが出来る
    →どのおやつについてもそのおやつがなければP円以下になるのであれば許してくれる
      →N種類のおやつに値段と満足度がある
        →それぞれのおやつについて最大でも1つしか持っていけない
          →満足度が最も大きくなるように選んだ時の満足度
  →1<=N<=5000,1<=P<=5000
  →1<=ai<=100,1<=bi<=100値段と満足度
    →ナップサックチックな感じを受ける、最大値がP以下になるようになるため
    →組み合わせる値段の最小値1<=M<=5000をdpのパラメータに入れる？
      →5000^3のループになるため、難しい
      →ソートして小さいやつから見ていく
        →これも5000^3になる
          →ならない値段の最大は100である
            →dp[5000][5000] = (満足度の最大,最小値段の最大)
              →で対応可能ではないか？
                →対応可能ではない、各値段における満足度の最大を取れるものが総合的に最大になるとは限らない
                  →最小値をdpのパラメータにするとTLEとなる
            →半分全列挙？
            →貪欲？
            →(最小値段の最大,満足度の最大)にしてみる？
              →これはダメ
       →ソートして大きいやつから見ていく？
        →AC
          →aiが大きいやつから見ていくことによって、範囲を大きめに取ったものが優先的に処理される
          →aiが小さくて満足度が大きいものも適正に処理される

arc060_c　高橋君とホテル / Tak and Hotels
  →N軒のホテルが一直線上に並んでいる、それぞれ座標xiに位置している
    →一日の移動距離はLを越えない
    →野宿をしない、一日の終わりには必ずいずれかのホテルにいなければならない
  →Q個のクエリが与えられる、aj,bjが与えられる、各クエリについてホテルajからbjに移動するために必要な最小日数を求めよ
    →2<=N<=10^5
    →1<=L<=10^9
    →1<=Q<=10^5
    →1<=x1<x2<x3<x4...<10^9
  →事前計算系かセグ木か
    →単純に難しい問題である
      →ある地点をスタートとして別の地点まで到達できるかどうかは一見独立しているように見える
        →事前計算はO(n)もしくはO(nlogn)で処理出来る必要があるし、queryはO(1)もしくはO(logn)で処理出来なければならない
        →各地点から到達出来る範囲の最大の場所は事前にキャッシュ可能
          →2分探索で求められる
        →各地点から何日でどこまで到達可能かはキャッシュ不可能
          →メモリがでかくなりすぎる
        →グラフにする？
          →ある地点からLの範囲内で一番遠い場所に辺を貼る
          →すると一番奥に集まる
            →枝が分かれている場合に複雑になる
              →両方に辺を貼る方法も考えたが、どうしてもai→biまでO(n)かかる方法しか思い浮かばない
                →
        →aiとbiを逆にしても同じ
          →片方向のみ考えれば良い
            →
      →自明なこと
        →どこまで行けるのかで対象の場所を越えてたらその日に到着をする
        →各地点からは明らかに一日で移動できる最大のところまで移動するのが最適
      →問題点
        →aiからbiまでを順番に辿る以外に処理方法が見つからない
          →事前計算としては
        →1.x1から2分探索してxiに到達可能とする、xiにはx1から何日かかったかとx1からスタートして到達したことを保持する
          →1.で処理されなかったxpから上と同じ手順を行う、すでにデータが保持されているところまで到達したら終了する
            →xpはx(p-1)にすでにデータが保持されているはずなので、それを+1した日数とする
            →この事前処理はO(nlogn)で可能
              →ai~biはbiに入っている日数からaiに入っている日数を引き算する
      →解説から
        →ダブリングを使用する
          →全然使ってないため、まったく発想になかった。

arc041_c うさぎ跳び
  →L個のマスが横一列に並んでいる。N匹のウサギがいる
    →i(1<=i<=N)番目のウサギはxi番目のマスにいる。
      →左または右向きになっている
      →自分の前のマスが存在し、ウサギがいなければジャンプして自分の１つ前のマスへ移動できる
        →ジャンプする順番を自由に選べる時、ジャンプの総回数の最大値を求めよ
  →貪欲な戦略で行ける気がする？
    →R...Lでどうやっても3になる
    →R.R.Lで？
      →Rのみを動かした時3となる、Lを動かすと2になる
    →R.R.L.Lの時
      →4となる
    →RとLが向き合っている範囲を考えればよさそうである
    →グループ分けをする
      →それぞれのグループの要素数をgとする
      →最初がRでない場合X0にR、最後がLでない場合Xn+1にLを配置するとする
      →Lが連続した後、Rが来たらそこでグループを区切る
      →それぞれの位置で境界となるRとLの位置を取る
        →境界となるRを動かす場合とLを動かす場合で大きい方を取る
          →他のウサギを境界に近い方から動かす
            →O(g)で可能
      →OK
      
arc028_3 高橋王国の分割統治
  →N個の町がありどの町からどの町にでもいくつかの道を通っていけるN-1本の道がある
    →木
    →バランス値を計算する
      →バランス値は首都とする町vを通らずに相互に通行可能である町の集合の最大の大きさ
  →1<=N<=100000
    →町iを首都としたときのバランス値を表す
  →それぞれの道に対して方向を定める
    →道に対して方向a,bを考える時、方向aのバランス値をdfsで決める
      →全ての道の方向a,bに対してバランス値を前計算する
        →すでにバランス値が入っていればそこから先の処理は不要である
    →道に対してバランス値を保持する配列を用意し、枝にはそのindexを持たせる、頂点には持たせない
      →TLEする、計算に同じループを何回も通るからと思われる
        →道が一本しかない場合に関して、バランス値を事前に代入してしまう
          →ウニグラフになっている場合はこれで処理可能
          →来た道が既にいくつのバランス値を持っているかわかる場合はn-b-1でそこから先のバランス値を取る事が出来る
            →http://kmjp.hatenablog.jp/entry/2014/09/01/0930
              →片道だけで考え、頂点の大きい方から処理する事により再帰を使う必要もなくなり、さらに高速化が出来る
                →頂点の小さい方にぶら下がる形で考えられるからである
                →この考え方は木であり、この形式の問題に対して応用が利く
      
arc027_3　最高のトッピングにしような
  →N種類のトッピング、トッピングiはti枚のチケットと交換できる
    →同じトッピングを複数回は入手出来ない
    →スペシャルチケットと通常チケットは区別なく使えるが、各トッピングごとにスペシャルチケットが1枚以上含まれていないといけない
    →トッピングにはうれしさという正の整数hiが決められている
      →入手したトッピングのうれしさの合計を最大化する
    →スペシャルチケット1<=X<=300,通常チケット1<=Y<=300
    →トッピングの種類数1<=N<=300
  →一見ナップサック的な感じである
    →チケットをこれだけ使った時の最大幸福数という風に考えるのであれば
      →dp[300][300][300]のような雰囲気のdpテーブルになるが
        →メモリ的にdp[2][300][300]が正解で、全ループで計算量も27000000であるので行けそうな気はする
          →あとは処理順で最大値が変わらないかとかが気になるところである
            →コーナーケースが見つからない
              →普通にdpの比較対象を間違えてただけだった、永久に更新されないcurrentと比較していたため、上書きされまくった

arc071_c TrBBnsformBBtion 
  →文字列FをTに出来るか
    →出来る操作は
      →1.A→BB,B→AA
      →2.AAAかBBBであるような部分文字列を選び、消す
  →サンプルから考える
    →ABAをBBBAに出来るか
      →1文字目をBBに変換すればよい
    →ABAをBBBBに出来るか
      →出来ないABA→BB BA→BBB BB→BBBB AA→BBBB BB A→BBBBBB BB→BBBBB 
        →ループする
          →AかBにすべてを変換を変換してしまうと考えると、シンプルになりそう
      →A→BB→AAB→AAAA
        →同じ文字は3つずつ増やせる
      →A→BB→AAB→BBBBB
        →別の文字にする場合は2から3つずつ増やせる
    →ABAをBBBBB
    →AABとBAA→BAA
    →2,1,2と1,2,2
    
m_solutions2019_c C - Best-of-(2n-1)
  →a,tのどちらかがn回勝つまでゲームを繰り返し行う
    →1回ゲームを行った時、それぞれの勝つ確率をA,B、引き分けになる確率をCとする
      →ゲームが行われる回数の期待値を求める
        →出力は互いに素な整数P,Qを用いてP/Qとあらわせる
          →R*Q≡P(mod 10^9+7)となる0以上10^9+6以下のRを出力する
      →1<=N<=1000000
        →どちらかがN回勝つまでの期待値は？   
          →まずN回勝つまでの期待値の計算が出来ないため、ここを抑える
            →http://drken1215.hatenablog.com/entry/2019/03/23/214500
        →解説を確認
          →引き分けがない場合を考える
            →X(M)でゲームがちょうどM回行われる確率を表す
              →M<=N-1,2N<=Mの場合はX(M)=0
              →そうでない時、M回ゲームが行われるのはM-1回目までで片方がN-1勝し、M回目のゲームでもその片方が勝つ場合
                →X(M)=m-1Cn-1((A/100)^N(B/100)^(M-N)+(A/100)^(M-N)(B/100))
                  →最後の一つは固定される為、m-1Cn-1で良い
          →引き分けについて考える
            →引き分けでないゲームがM回行われるまでに（引き分けを含めて）ゲームが行われる回数の期待値をY(M)とする
              →Y(M)=M*(100/(100-C))
                →証明
                  →Y(0)=0
                  →Y(M)=1+(C/100)Y(M)+((100-C)/100)Y(M-1)
                  →((100-C)/100)Y(M)=((100-C)/100)Y(M-1)+1
                  →Y(M)=Y(M-1)+100/(100-C)
                    →となるため、漸化式によりY(M)=M*100/(100-C)となる
          →答えはsum(M=Nto2N-1)X(M)Y(M)=sum(M=Nto2N-1)m-1Cn-1((A^nB^(m-n)+A^(m-n)B^n)M/100^(n-1)(100-C))
     →この問題の難しいところはM回ゲームが行われるための期待値を求めてCを計算に組み込んでいるところである
      →最初の発想としてどうしても勝ち、負け、引き分けを同列に考えてしまう
        →M回[引き分けではないゲーム]が行われる上で、引き分けが起こる確率を考慮するとMはこのような回数行われることになるだろうという期待値の算出に使用
      →Mの取る範囲内で処理をするという考え方もまだまだ出来ないし、期待値の計算が弱い
        →確率を考える系の問題として定期的にやるローテーションに組み込もう
          →この問題の解説としてhttps://www.creativ.xyz/best-of-2n-1-1080/を参照

arc076_c
  →R*Cの長方形の盤面 
    →1からNまでの整数が２つずつ書かれている
      →整数iが書かれている座標は
        →(xi1,yi1)と(xi2,yi2)
      →1からNまでの全ての整数に対し、同じ整数の書かれている座標同士を曲線で結ぶこと
        →曲線が長方形の外に出たり、互いに交わったりしてはいけない
          →このようなことが可能かどうか判定する
    →R*Cであるが、0も含まれるため盤面のマス数は(R+1)*(C+1)ある
      →1<=R,C<=10^8
      →1<=N<=10^5
    →通れないのはエリアを左右に横断するような通り方をしている線に対して
      →上エリアから下エリアの端に通るような場合が一つ
        →上下と左右を入れ替えた場合も同じ
          →押し出されなければよい
            →まず、横断するような点を全て拾う
              →これに対して縦断するような点がある場合はout
            →クロスしていても端に到達していない場合は線を引ける
              →いくらクロスしていてもok
      →線と線で比較出来れば良いが、それをやるとO(n^2)になるためtle
        →端から端に行く線だけを見ればよい
          →エリアを分割して保存できないか？
            →5角形等になるため難しい
          →縦と横でクロスしてた場合はそもそもoutであるため、エリアを考える必要はなさそう
            →横のみ、縦のみで構成されている場合もさほど難しくない
              →4点保存出来るため
            →面倒なのは斜めが入っている場合
              →x軸とy軸で独立して考えられる？
                →pllで保存出来る
                  →例えばr=10の時に5,0に配置された場合(0,10)を(0,5),(5,10)に分けることが出来る
                    →setに保存することで2分探索で捜査可能
                      →新しくできたエリアはエリア番号を発番する
                        →r=10,c=10で(5,0)(7,10)に同じ数が生まれた場合
                          →c=0は(0,5,0)(5,10,1)とc=10は(0,7,0)(7,10,1)
                            →といった形で分ける
                              →この場合横断する形である
                                →r=10は(0,10,1)となる
                          →そして(3,0)(8,10)に同じ数がある場合、2分探索で違うエリアを拾うことになる
                          →エリアは数の大きい方に増える
                            →実装がめちゃくちゃめんどくさい


arc053_c C - 魔法使い高橋君
  →N個の魔法を使え、魔法は1からNまで番号が振られている
    →i番目の魔法を唱えると気温がai度だけ上がった後bi度だけ下がる
      →全ての魔法をちょうど１回ずつ唱える
        →気温の最大値Xを最小化する
  →1<=N<=10^5
    →1<=ai,bi<=10^9
  →Nの範囲から行くとo(n)もしくはo(nlogn)
    →上昇値が小さく下降値が大きいものを優先的に使う？
      →そのように使っていきたいがただ単に上昇値が小さいものを優先的に使用しようとすると上昇値>下降値のものを使用してしまう
      →一番最初に使うものとしては上昇値が一番小さく下降値が一番大きいもので良い
        →次に使用するものが難しい
          →上昇値uがmax-uを越えない範囲のものがあれば下降値dが大きいものを使用したい
            →超えない範囲のものは二分探索で出せはする
              →となると配列を二つに分ける
                →u>dの配列aとu<=dの配列bである
                  →まずbをmaxu-curdで二分探索する
                    →見つかったものよりも小さいものがあればbの中から使用しその要素を削除する
                      →最初は全てこっちから使うのがよいだろう
                        →bを全て使用したらaを使用する
                          →最小の位置になっているため、ここからはbの大きいものから使用していった方が良いように思える
                            →0に決めた状態で
                              →30,10 10,0を順番に使用する場合1,2では最大値は30、2,1では最大値が40になる
                              →30,10 30,20を順番に使用する場合,2,1が小さくなる
                              →30,20 40,20を順番に使用する場合,1,2は50, 2,1でも50となる
                            →この方針で実装してみよう
                              →waである
                                →反例は何か？
                                  →実装が間違っていたaの配列を降順でソートしていなかった
                                    →AC


https://atcoder.jp/contests/cf16-final/tasks/codefestival_2016_final_d
  →D - Pair Cards
  →N枚のカード
    →2<=N<=10^5
    →1<=M<=10^5
    →1<=xi<=10^5
    →xiが書かれている
      →2枚組をなるべくたくさん作る
        →2枚のカードに書かれた整数が同じ
        →2枚のカードに書かれた整数の和がMの倍数
    →作る事の出来る組の個数の最大値を求めよ
      →最大で200000
      →x1=x2 x3<x4 x1+x3=M 可換性があるか
        →M=5 x1=2 x1=x2 x3=3<x4=7 
        →x1+x3=5　x2+x4=9
        →この場合x1,x2 x3,x4のペアの方がよい
          →和がMの倍数組み合わせで両方共ペアがないものはそのままくっつける
            →データの分け方を考える
              →同じペアの偶数個に関してはそのまま処理する
                →残った1個ずつだけを考えれば良い
                →違う、2,2,2,2,2,2,3,8みたいなときに3,8を使った方がより多くのペアが作れる
                →割った余りを集めるのが先
                  →処理優先度が高いのは奇数枚同士残っている数字
                  →次に高いのは奇数枚残っている数字
                  →最後に偶数

D - Five, Five Everywhere
  →https://atcoder.jp/contests/abc096/tasks/abc096_d
  →長さNの数列を一つ出力する
    →aiは55555以下の素数
    →a1,a2,a3...anの値は全て異なる
    →どの異なる5個の整数を選んでもこの合計は合成数になる
  →奇数と奇数を足せば偶数になるため合成数になる
    →5個選ばないといけないため少し工夫が必要
      →下一桁が1の素数を選ぶ
        →5個で5になるため5の倍数になる
  →5<=N<=55
      →やるだけ
  
B - Fusing Slimes
  https://atcoder.jp/contests/dwacon6th-prelims/tasks/dwacon6th_prelims_b
  n匹のスライム
    昇順に並んでいる
  操作をn-1回行う
    1以上n-i以下の整数を問う確率で選ぶ
      kとする
    左からk番目にいるスライムを右隣りにいるスライムの位置まで移動させる
      1匹のスライムにする
  スライムが移動した距離の総和の期待値に(n-1)!を掛けた値を10^+7で割った余りを求めよ
  2<=n<=10^5
  1<=xi<=10^9
    1以上n-i以下の整数を問う確率で選ぶ
      左からn-i番目までのスライムは常に存在する
        というかどれかスライムを一体選んで隣のスライムにくっつけるでも同じ意味である
      右隣にしか移動出来ない
        確率の分母は(n-i)!
          例えばnとn-1が確率は100%
          n-2とn-1がくっつく確率はn-2よりも先にn-1が選ばれない場合の数
            1/2である1/2の確率でx(n-1)-x(n-2)が起こる
              さらに1/2の隔離でxn-x(n-2)が起こる
          n-3について
            n-2の位置まで移動する確率は1/2である
              むしろ100%の確率でx(n-2)-x(n-3)が発生する
                そのうえでn-3からx(n-1)-x(n-2)が発生する確率は何か
                  xn-x(n-1)も同様に求められそうであるが
          むしろx1から考えた方がシンプルになりそうな気もする
            x2-x1は全てのパターンで起こる
              x3-x2は全てのパターンで起こるがx3-x1が含まれるパターンは
                x2が先に選ばれてx1が後から選ばれる場合の数
                  (n-1)!/2*(x3-x2)である
              x4-x3において
                x4-x2が選ばれるパターンは(n-1)!/2*(x4-x3)である
                  全ての間隔でこれが行われる
                    全体sから考えsは(n-1)!で起こり
                      s-x1は(n-1)!/2で起こる
               ならばs-x2はどうか
                連続した4つを見た時に、右3つが先に選ばれるパターンである
                  左が一番最後に選ばれるパターンともいえる
                    4!/4であるということは上の
      1 2 3で考えてみると
        2-1は重複して起こらないため、2*1
        3-2は全体パターンより2*1、先に2を選んだパターンより1*1で合計5である
      AC　期待値の問題を自力でさばけたのはなかなかうれしい
        もう少し考察を詰めておきたい
          各区間が現れる確率の総和であることは間違いない
            連続したx個を選んで一つだけ位置を固定して並び替える場合の数は
              x!がx個を並び変える数
                一つだけ固定するので
                  (x-1)!となるつまり(x-1)!=x!/x
                これをn個の中の連続したx個のうち一番左を固定した数ということになると
                例えば4個のうち2個で考えると
                  4!=24 1 2,2 3,3 4のいずれかが固定されるパターンは
                    1,2,3,4
                    1,2,4,3
                    1,3,2,4
                    1,3,4,2
                    2,1,3,4
                    2,3,4,1
                    3,1,2,4
                    3,2,1,4
                    3,4,1,2
                    3,4,2,1
                    4,1,2,3
                    4,3,1,2
                    の12パターンである
                      いずれか2個が固定されるというのは
                        逆になっているのを省くということである
                          どれか2個を考える時にx<yになっている場合と
                            y<xになっているのは同じだけ登場するため
                                全体の場合/2で求められる
                      式はn!/x*v1+n!/x*v2,....,となっているため
                        n!/x*(v1+v2,...,vn)となり間隔の総和となる
                      
C - k-DMC
  →https://atcoder.jp/contests/dwacon5th-prelims/tasks/dwacon5th_prelims_c
  →dpまではやった、あとはkの範囲で考える
    愚直にやるとTLEである
      あ、Qが75である
        愚直解でも間に合うのではないだろうか
          全体でdpとるとお亡くなりになる
            これはk毎にdpを取るのが正解ではないだろうか
      あるiに対してs[i]='C'のときi-kの範囲内にa<bはいくつあるかという問題である
        'D'が現れた時にdp[0]を増やす、i-k-1に'D'が現れた時にdp[0]を減らす
          dp[1]が問題である、'D'が一つ減った時にdp[1]はiからi-k-1に存在しているM分減る
          i-k-1にMが現れ、消える時は、このMに対するDは全て償却されているからdp[1]の数字は変わらない
            
D - Forest 
  https://atcoder.jp/contests/apc001/tasks/apc001_d
  森が与えられる
    各頂点にはコストが与えられている
    森を連結して木にする
      連結は森の頂点同士を辺でつなぐ、その時にv1+v2のコストがかかる
        一度連結で使用した辺は再度使用する事は出来ない
        連結出来る場合は最低コストを求める
        連結出来ない場合はImpossibleを出力する
    Impossibleのパターン
      同じ頂点を二度以上連結しないと木に出来ない時
    頂点数が多いため、効率的に処理する必要がある
      n^2が計算出来ないため、気を付ける必要がある
        組み合わせは重要ではない
          例えばv1,v2とv3,v4をそれぞれ連結したとする
            この時v1+v2,v3+v4が発生するがそれぞれを入れ替えたとしても最終の和は変わらない
              つまり使う頂点だけ選べばいい
                つなげる先はどこでも良い
                  まだつながっていない木と一つの大きな木がある状態となる
                    木が3つ以上ある時に頂点の数が1同士を連結すると手詰まりとなる
        頂点数が最も多いものを中心に集めるのが良い
          使える頂点をpriority_queueに入れていく
            unionfound木である必要がない
              
F - Engines
  https://atcoder.jp/contests/abc139/tasks/abc139_f
  エンジンをいくつか使用し、原点からの最大距離を求める
  1<=N<=100
    ベクトルで考える
      (x,y)+(a,b)=(x+a,y+b)に到達出来る
    あるベクトルvを使用するときに、そのvを中心として原点から遠くに点を打ちたいのであれば
      貪欲に探せるのではないだろうか
        nは100しかないため、それぞれのベクトルに対して処理すれば良い
          偏角ソートを使用して、あるベクトルvからv-πの範囲にいるベクトルを足していくという形でも行けそうである
            atan2(x,y)を使用する
              大3象限まで求められる
                ソートが完了したら配列を2倍にする、
                  n+1~2nまではπを足しておく
                    対象のベクトルから+πまでの範囲を足す
                      いや、i,jの角度2/πを超えるとベクトル的にマイナスになる
                        そのため2/πまでを見る
          
        
