arc002_3 コマンド入力
  →ABXYで作られた文字列
  →LとRに連続した２つのボタン入力を割り当てられる
  →最小入力回数を求める
  →1<=N<=1000
  →全部で16*16パターン96+160=256,256*1000しかないため全探索で処理可能

arc001_3 パズルのお手伝い
  →8クイーンで３マス埋まっている状態が初期値
  →8^5試せばよいだけであるため、そこまで計算量が大きくはならない
  →行ったり来たりする必要はないように思う

agc003_c BBuBBBlesort!
  →数列をソートする
  →操作１、連続する２つの数字を選び反転
  →操作２、連続する３つの数字を選び反転
  →ソートする為に必要な操作１の最小回数はいくつか
  →1<=n<=10^5
  →0<=Ai<=10^9
  →3つの数字を反転するということは真ん中の数字の位置は変わらず、一つ飛ばしで値が入れ替わるだけ
  →となると1の操作が必要なのはソート後の位置と奇数分位置が異なっている場合のみ
  →奇数個異なる箇所は偶数個ある
  →奇数個異なる数字の個数/2が答え
  →解説より、奇数番目と偶数番目がひっくり返っているということであるため、片方で奇数番目に現れて、片方で偶数番目に現れる数を数えるで奇数個異なる数字の個数/2と同じになる

arc005_3　器物損壊！高橋君
  →グリッドグラフ、コストは1、通れない場所をコスト2分までなら通れる、スタートからゴールまで行けるか
  →1 <= h,w <= 500
  →途中に通れない場所がない→Yes
  →スタートからBFSでマスを埋めていき通れないところまで到達させる
    →通れないところまで来たらなんらかの値を仮で入れる
      →行けるところ全て終わったら終了
  →ゴールからBFSして通れないところまで到達させる
    →通れないところまで来たらなんらかの値を仮で入れる
      →行けるところ全て終わったら終了
  →何らかの値が縦か横に二個連続しているところがあればYes、なければNo
  →二個連続しているところでは、通れる場所が離れていてなおかつ到達できる場合を満たすことが出来ない
    →それでもなんらかの値を仮で入れた箇所を通ってSからgまでたどり着ければ問題ない

arc006_3 積み重ね
  →トラックから積み荷を降ろす、それぞれの荷物は重さが定義されている。
    →積み荷を重ねることが出来るが、上に乗せた荷物が重い場合、下の荷物がつぶれてしまう→NG
  →全ての荷物を降ろした時に積まれている山の数を最小にしたい。
  →1<=n<=50
  →全部逆順で出てきたときは最大値となる
    →1,2,3,4,5,6,7,....
  →転倒数？
    →5 4 7 6→2
  →最長部分増加列？
    →5 3 4 7 6 8のパターンが反例
  →i,i+1を比較してでかいとき？
    →10 3 4 7 2 6のパターンが反例
  →サイズが50なのでシミュレーションでも行けそう→却下
  →後ろから見る
    →an<a(n-1)が増加している場合は同じ山に配置出来る
      →サイズが50なので取り出したところはフラグを立ててもう一度取らないようにする
        →処理出来る数字がなくなるまでの回数が答え

arc007_3　節約生活
  →oxの配列→o視聴可能な時間、x視聴不可能な時間
    →テレビをつけると視聴パターンが無限に繰り返される、テレビはつけると消せない
      →全ての時間視聴するための最低限なテレビの数を求めよ
  →1<=N<=10
  →少なくともoは一つ含まれる
  →最大10台用意
  →全部の時間に配置して、抜き取って良い場所を抜き取る？
  →1<<10だから全パターン試しても間に合う
  →全てのテレビをつけるまでに視聴出来ない時間があってもいいが、付けたら視聴出来ない時間があってはならない
    →2周目までに全て決まるはず
    →1周目に配置しても２周目に配置してもその次の周の見える時間は変わらないため、１周目のみに全て配置する事を考える
  →1個目は埋まっているためn-1の全パターンでも良さそう

agc040_b Two Contests 難易度青のくせにまだピンと来ていない
  →左端の最大と右端の最小がクロスしているかどうかで答えが変わってくる
    →しかし解説を読むと場合分けせずに答えが出るということらしい。
  →それぞれのコンテストを集合、問題iを解ける人の範囲を区間i、コンテストの楽しさを含まれる区間の共通部分の長さとする
    →半開区間にすることで区間の長さをr-lで表すことが出来る
  →ポイントとしては左側の最大と右側の最大を軸に考えることが出来れば意外とシンプルになる、そこに気が付かないとクリアは難しい
  →あとは解説の通り一つの区間と残りの区間の共通部分を取る(左側の最大と右側の最大が一つの集合に含まれている場合はこれで最大値が得られる)
  →ri-左側の最大=sと右側の最小-li=tをそれぞれ計算してtの昇順、タイブレークはsの降順でソートする
    →すると、この集合を一つ一つ処理していくと、sがだんだん小さく、tがだんだん大きくなっていく、ここでs+tの最大を取る

arc011_3 ダブレット
  →ある単語を別のある単語に変換する。人もずつ変換する過程で別の単語を経由していく、その最小手数を求める
    →最初と最後の単語、1<=N<=1000の経由出来る単語が与えられる
      →変換与えられた単語を経由して変換不可能である場合-1を出力する
  →グラフ化出来ないか？グラフ化出来るならダイクストラで対応可能
    →n^2は可能であるため、一文字違いの単語を全探索してグラフ化することは可能である。
      →グラフはインデックスに置き換えれば良い
      →作られたグラフで最初の単語から最後の単語までの最短路が答えとなる
      
agc024_c Sequence Growing Easy
  →長さNの数列Xがあり最初は全ての要素が0,Xのi項目をxiで表す。長さNの数列Aが与えられる、Aのi項目はAi、以下の操作を行い、XとAを等しく出来るか
    →1<=i<=N-1なる整数iを選ぶ。X(i+1)の値をXiの値に1を足したもので置き換える
  →先頭は0以外ありえないため0でなければ-1
    →先頭の次は0~1以外ありえないためそれ以外なら-1
      →上のように各iのmaxは決定している。
  →前後で2以上の開きがある場合も-1
  →1になっている箇所はその前のところを0の時に操作したものである、
    →例えば011となっている場合前からやると連続しているところで012となってしまうため、後ろから操作する
    →011012212の前の状態は011011010→011012212からは011012332など作成可能
  →各数字から先頭になっている場所を特定することは出来る。しかもその数が操作の回数となっている
    →前の数字と比較して+1されている時は+1、前の数字と比較して=の時は+Ai
    →前の数字と比較して-されている時は+ai
      →以上で反例はないと思われる。
      
codefestival_2016_qualB_d　Greedy customers
  →N人の人が1列に並んでいて、i番目の人の所持金はAi。品物を選んで価格Pを設定し、前の人から順にその品物を見せていく、各ひとは品物を見せられた時、その価格Pがその人の所持金以下だったと気品物を購入しその人の所持金がP減少する
    →出来るだけ多くの品物を売りたい、しかし売った人の所持金が0になるとその人は帰れない。
      →所持金を0にしないように、最大でいくつの品物を売ることが出来るか求める。
  →1<=n<=100000,1<=ai<=1000000000
  →全部1にすると先頭の人から後ろに行かない→×
    →先に先頭を1にして大きい数を後ろに回す？
      →前から考えられる、先頭は1になるまで削る、先頭以外はa(i-1) + 1< aiである場合、最低値段をa(i-1)+1として販売可能
        →割り切れる場合は0になってしまうため、ai/(a(i-1)+1)で割り切れる場合は-1する。（実は先頭も同じ）この和が答え
        
jsc2019_qual_c Cell Inversion コンテスト中に解けなかったやつ
  →2N個のマスが並んでいる、B,Wで埋まっていてBは黒、Wは白を表す。異なる2マスを選んで色を反転する。同じマスは２回以上選べない
    →N回の操作終了後全てのマスを白色にする方法が何通りあるかを確かめる
  →解説では選ばれた２マスが左側か、右側かというのは各マスについてどちらか定まるということである。
    →まず、各マスが左側になるのか右側になるのかを探る
      →BWWBの場合はLLRRとなる
        →この例を見る限り二つ同じものが並んでいる場合は左右決まりそうな気がする
          →BWWWBとなると真ん中は選べないため上の考え方はダメ
        →BWWWBとなった時、LLXRRとなる
        →BWWWWBとなると、LLRLRRとなる
    →左右の端がWの場合はXとなる、つまりB......Bというパターンのみ考えれば良い
    →偶数個並んでいる場合はLRLRLR...とおける
    →奇数個並んでいる場合は..LLXRR..となる？
      →BBBWWWBBBとなるとLXRLXRLXRとなるか？→OK
      →BBBBBの時、LXXXR以外は成立しない→NO
        →LRLXRかLXRLRがある
          →BBBBBBBの時は？LRLRLXR,LRLXRLR,LXRLRLR等が可能、len(m) / 2パターンがある
            →奇数になっているところを集めて後でまとめて掛け算可能
       →BWWBのように挟んでいる場合、対岸がRになる
        →BWWBWWBは?→LLRXLRRで行ける
          →全体を通して偶奇を取る必要がある？
            →BWWBWWBWWBの時はLLRRLRLLRRである
              →BBWWBWWBBは？LRLRLLRXR,LXLRRLRLRとなる、LRのパターンが変わる
      →LRのパターンは一意ではない、LRが決まればそこから求められる組み合わせは一意になる
      →LRからの処理順の計算方法
        →LLRRで考える→1つ目が選べるRは２つある、2つめが選べるRは1つだけになる
          →LRLRLRで考えると1つめが選べるのは3つある、2つめを選んだ場合、3つ目のLが選べるのは２つ、4つめを選んだ場合、3つ目のLが選べるのは１つだけとなる
          →LRLRLRLRで考えると組み合わせはLRLRLRLRとLXXRLXXRとLXXRLRLRとLXXXXRLRとLXXXXXXRとLRLXXRLRとLRLXXXXRとLRLRLXXRがある。
            →奇数の時と合わせると結構な組み合わせの数になる
            →さらに順番も計算する必要がある
          →組み合わせとしては、全てWにするために必要なLRのペア数がそれぞれいくつあるか分かれば、それぞれを階乗倍すれば答えは出る
            →計算量が大きい
  →操作手順は無視できるということ、それはわかるが
    →操作をN回行うということを忘れていた
      →この制約ならばそれはN!一択である、N回までに、であれば難易度は相当上がる(というか不可能？)
        →考えなおし
          
 agc033_c Removing Coins
  →木を用いて二人でゲーム、最適な行動
    →1<=N<=200000
    →N頂点、1~Nが割り振られている、N-1本の辺のうちi本目の辺は頂点aiと頂点biを結んでいる
      →各頂点にコインが一枚ずつ置いてある、操作を行えなくなった方が負け
        →操作、コインが置いてある頂点を一つ選び、その頂点vにおいてあるコインをすべて取り除く
          →その後、木上に残っているコインをすべて、今置いてある頂点に隣接する頂点のうちvに一番近い頂点に移動させる
    →1 2,2 3,2 4で、1を取り除いた場合に頂点１に1枚、頂点2のコインが2枚になる
      →2を取り除くと２にコインが3枚ある状態になる
    →grundy数の問題？
    →コインが置かれている頂点は常に連続している、つまり、コインを取る場所により残りのコインの枚数が変わるのが肝となる
      →端を取るとコインが置かれている場所が一つ減る
      →複数の辺が接続している場所を取るとその分コインが置かれている場所が減る
        →端を取るとその頂点にコインが集まるように移動する
        →端以外を取った場合は、全て同じ盤面になる
          →ある頂点から延びる枝が2以上であり、全ての枝の頂点数が同じである場合、端を取った場合は、その頂点がある辺のみ長さが変わらず、その他の辺は長さが１減る
            →一番長い頂点数を持つ辺の長さ分はゲームが可能？
            →頂点間が一番長い辺でゲームをしているのと変わらない？
              →DFSで一番長い頂点間は求められる
    →枝の伸びている方向を考える 
      →1,2のみであればsecond、1,2,3であればfirst、1,2,3,4の場合は残り2か所にするか3か所にするか選べる
        →残り2か所に出来るのでfirstとなる
      →1 2,2 3,2 4,4 6,6 5の場合はsecondとなる
        →Nは偶数、処理としては、一手目が終わった後、残りの石の位置は1,2,4,5、2,4,5、2,4,5、2,4,5、2,4,5,6となる
          →3になるか4になるかであるため、secondが勝てる
      →1,2,3,4,5の場合、4にするか5にするかを選べる、
       
nikkei2019_2_final_a Count Triplets
  →a1,a2,....anのNの要素
    →ai<aj>akを満たす(i,j,k)の組の個数を求める
      →座圧して1<=ai<=5000の範囲にしてしまう
        →累積和で左と右それぞれからl[5000][5000]、r[5000][5000]の範囲で累積和を取る
          →あとはj=2~n-1までajを処理して、その和を求める
   
nikkei2019_2_final_b NIKKEI String
  →文字列sを6分割して分割後のs1,s2,s3,s4,s5,s6がNIKKEI型(s2=s6,s3=s4)となっている個数を求めよ
    →6≤|s|≤500
    →s1を前からとs6を後ろからの2重ループを軸に考える
      →s6のindexでs1+1~s1+1+indexでs2も作れる
        →s2=s6の時にs5を後ろから取っていく
          →残りの文字列を半分にして同じ文字列が二つ作れればNIKKEI型
            →いちいちsubstringを使うのも計算量的に微妙であるため、500*500のstring配列に事前に格納しておく
            
nikkei2019_2_final_c Largest N
  →H行W列のマス目があり、それぞれのマスは黒または白で塗られている
    →マス(ai,bi)は白で塗られていて、他は黒で塗られている
      →自然数kに対してマス目がサイズkの'N'を含むとは、次の条件を満たすi,jが存在する
        →マス(i+t,j)(0<=t<k)が全て黒
        →マス(i+t,j+t)(0<=t<k)が全て黒
        →マス(i+t,j+k-1)(0<=t<k)が全て黒
      →このマス目に含まれる'N'のサイズの最大値を求める
    →黒マスがNの形になっている箇所を探す、形は全て正方形と考えて良い
      →サイズは3000*3000=9000000
        →正方形の数は
      →サイズa,bがありa<bの場合にaで作れず、bで作れる場合が存在する
        →2分探索では不可能
      →縦、斜めで尺取りを行い、黒で埋まっている範囲を出す、スタート地点のindexで最後まで埋める。
        →それぞれのテーブルを作って事前計算しておく
    →探索は縦か斜めに行えばいい
      →数は？まずスタート地点となるのが3000*3000箇所ある、それぞれに対して3000箇所考えられる→ストレートにやるとTLE
        →Nの最大を常に持っておけば、それ以下の範囲で探索は不要となる
        →縦、横、斜めそれぞれの最大の最小値がNの最大値となる
        →白始まりは存在しないため、白であれば探索は飛ばす
          →配置によってはTLEになりそう
            →Nの左上には情報が下の最大と斜め下の最大の情報が集められる、その小さい方がその左上から作れる最大N
            →Nの右下にもが集められるかもしれないが、不要である
              →探索の範囲は狭まったが、どうしても内部でループをする必要があるところまでしか削れない
              →実はNの左上にNの右側棒の情報が集められる気がする
                →ダメである、ループが必要となる
                  →始点と終点がある限り、これは難しい
                  →上の考え方で処理を作ってみよう

agc005_c　Tree Restoring
  →長さNの数列a1,a2,a3....an
    →頂点iと最も遠い頂点の距離がaiとなる木
      →存在すればPossible,しなければImpossible
    →1<=N<=100
    →出来ないパターンN=3の時1,1,1、N=3の時は1,2,2しか存在出来ない
      →各頂点iはあまり関係なし
      →一番aiが短い所により最大の距離も決まる
        →一番短い所は木の中心となる
          →最大の長さを取る頂点maは確定で二つ以上存在する
            →なければImpossible
          →maが2つ以上存在する時は確実に一つの中心を通っている
            →maが4つ以上の場合に二つの完全な中心が存在すると仮定すると、木なので、maの距離が伸びることになる
          →中心となるのはmaが偶数の場合二つ(どの枝も通る完全な中心は一つ)、奇数の場合一つ
            →完全な中心は一つと仮定して組み立てて良い
    →maの片方をまず配置する
      →次はma-1を一つ選ぶ
        →次はma-2を一つ選ぶ
          →中心oまで来たら、maが偶数の場合、oを選び、奇数の場合、o+1を選ぶ
            →maまで到達する
              →残りの頂点をai-1の場所に追加していく
                →完成すればPossible
    →maが奇数の場合、中心は二つ
    →maが偶数の場合、中心は一つ
      →このパターン以外はImpossible
    →あとは中心より上～maまでが2つ以上あり、中心未満が０個であればPossible
   
agc008_c Tetromino Tiling
  →7種類のテトリミノがある、
    →そのうちK個を組み合わせ縦2マス、横２Kマスの長方形を作ろうとしている。
      →縦横逆でも同じである
    →それぞれのミノが接する部分と偶奇を考える
      →すると数を減らせる
        →ミノは全て使う必要はない
          →T,S,Zは使うと長方形に出来ない？
            →I,O,L,Jのみで考えれば良い？
        →全パターン処理可能となる
          →I型が奇数の場合、J,Lがそれぞれ一つ必要になる
            →I,J,Lが3,2,2となっている場合、I,J,Lで3、I*2で2=5となる→×
              →I*2,j*2,L*2でとると6になる
              →I,j,L*2でも6となる
            →I,J,Lが3,3,2となっている場合、I,J,Lで3,I*2で2,J*2で7となる
              →I*2,j*2,L*2だと6の為上の場合はI,J,Lを取る方が正しい
            →可能な限りI,J,Lの組み合わせでとるのが正しい？      
              →I,J,Lを2個作るのはそれぞれを２個づつ作るのと同じ
                →I,J,Lを一つ作るか０個作るかで場合分けして終わり

agc014_c　Closed Rooms
  →魔法を１回使うと部屋をK回移動できる、また、K個の部屋を開く事が出来る
    →K個の部屋を開く事が出来るので、最初に移動できる範囲で外に一番近い所に移動出来れば良い？
    
agc014_b Unplanned Queries
  →木構造のデータに対してM個のクエリを流す
    →クエリはai,biとして頂点ai~bi上頂点の数字を1増やす
      →最終的に木の数字が全て偶数になっているかチェックする
  →2<=N<=100000,1<=M<=100000
    →共通の親が分かればそこからトップダウン的に処理できる
      →ダブリングしてみよう
    →親子関係があればそのまま処理出来る
      →木が存在するかどうかである、最初から木があるわけではないのでダブリング等は出来ない
    →クエリで偶数回出てきているかどうか？
      →例えば2,2で1 2,1 2の場合は真
      →例えば3,3で1 2,1 3,2 3である場合も真
        →正直Nで出てきていない頂点は考える必要がない
      →例えば4,4で1 2,2 3,3 4,1 4である場合も真
  →解説を見る
    →(ai,bi)の時ルートまで通ってからそれぞれのところまで行くという風に考えると(r,ai),(r,bi)と考えることが出来る
      →(r,ai),(r,bi)を見たときに(ai,bi)のLCMをPとすると(r,P)は２回通るため、(r,ai),(r,bi)としたときに全く同じ状態となる
        →木構造である場所から別の場所に行くときにルートを通るようにするという考え方はまた出てくる可能性がある
  
agc026_c String Coloring
  →2Nの小文字からなる文字列Sが与えられる
    →各文字を赤か青に塗り分ける
      →赤に塗った文字列を左から右、青に塗った文字列を右から左に読んだ文字列が同じ
        →これがいくつあるか
  →1<=N<=18であるため、全探索でも出来る
    →文字列は2*Nであるため、無理
  →32bit整数で表せないこともあるため、普通にカウントするのも無理とわかる
    →最初の文字を赤か青に固定して考える
      →最終的には×2になるためOK
        →文字もそれぞれ２つずつないとだめ
      →違う色の最初の文字は同じ文字になる
        →後ろから探して違う色の最初の文字を見つける
          →そこが違う色の最初の文字になるとは限らない
          →そこが違う色になるとは限らないが、それより右側の文字を反転したものはは違う色が全て持っている文字列にならないとならない
        →それぞれの文字がどの文字と反転しあうかを調べる？ 
          →abccbaであれば1,5の組み合わせ、2,4の組み合わせで行ける
            →1,2,3 1,2,4 1,3,5, 2,3,6 2,4,6 3,5,6がそれぞれ使える
          →abcbcaとなるとacbとcbaの組み合わせが作れる
            →1,3,4 3,4,6のみ
            →文字列が反転している状態であれば、組み合わせはかなり作れる 
          →abbccaだと組み合わせは出来ない
        →aaaaを考える
          →1,2 3,4
          →1,3 2,4
          →1,4 2,3
            →に分けられる
        →baaaabを考える
          →1,2,3 4,5,6
          →1,3,5 2,4,6
          →1,2,4 3,5,6
          →1,4,5 2,3,6
          →1,2,5 3,4,6
          →1,3,4 2,5,6
            →に分けられる
            →aaaaとの違いは開始地点を変えられないところ
        →bbaabbaaを考える
          →1,2,7,8 3,4,5,6
          →以上となる
        →同じ文字が連続しているところはそれぞれ入れ替わる事が出来る
          →baaaabを再度考える
            →1,2,3 だが、これは2,5 3,4を入れ替えることが出来る
            →1,2,5 は2,3 4,5を入れ替えることが出来る
              →しかし1,2,3の入れ替えで1,2,4 1,3,5は出ているため、掛け算するとアウトとなる
              →つまり別の考え方が必要
                →600点程度かつ青パフォ問題ではあるのでもっとシンプルに考える方法があるのではないか？
                  →見落としてる何かはないか？
                    →bbacacbbとなっている時に右側の先頭文字は変えられるか？
                      →1,2,4,5
                      →1,4,5,8で出来る
                        →これは対称になっていて同じ位置に存在する場合、入れ替えが可能ということを示す
                          →上の例では頭から取ると
                            →bbca,bbcaと並ぶ
                              →このbの位置は先頭か後ろへと入れ替わる事が出来る
                                →bcab,cabb
                                →では内部で同じような連続しているところがある場合はどうか
                                  →baaccaab
                                    →baac,baca,bcaaが取れる
                                  →挟んでいて同じ位置にある連続した文字は、挟んでいる文字を軸に位置を入れ替えることが出来る
                            →bbaabbaaはどうなるだろう
                              →bbaa,bbaaとなりaを挟んでいるが...  
                                →挟まれているaは片方にしか存在していない
                                  →bbaaaabbの場合は挟まれているaはどちらにも存在している
  →解説見た
    →やはり600点なのに上のような方法で解くような問題ではなかった
      →文字列を半分にし、文字列の組み合わせを全列挙する
        →そこでマッチングしてクリアである
          →やはりN<18くらいだと全列挙が基本的なアイデアであって、そのまま処理出来るように出来ている
                              
agc037_c Numbers on a Circle                            
  →１～Nの番号がついている、i番目の数はai、i番目の生成数がbiとなるようにしたい
    →1<=i<=Nなる整数iを一つ選ぶ
    →i-1,i,i+1番目の数をそれぞれa,b,cとしたとき、i番目の数をa+b+cに置き換える
      →操作が出来るか判定し、可能である場合は操作解消として考えられる最小の値を求める
  →1<=N<=2*10^5
  →1<=aiなのでiを操作するとき、2<=p増える
    →小さい所から処理していかないと、bにすることは出来ない
      →b1<b2として、b2を先行した場合、b1<a1+b2となるためNGとなる
        →なので小さい数から組み立てると考えてよい
    →効率的な数字の増やし方を求める
      →biはaiが持っている数字からしか組み立てることが出来ない
        →そのため、操作を繰り返すことによりどのような組み合わせになるのかを考える
          →入力例3の 5 6 5 でb2を何回か操作することを考えると 16 26 36 となる 5,5,6 5,5,5,5,6 5,5,5,5,5,5,6と言った風に組み合わせられている
            →5 6 5 2 をb2,b3と操作する 5 16 5 2,5 16 23 2 
            →5 6 5 2 をb3,b2と操作する 5 6 13 2,5 24 13 2
              →もちろん順番が変わると数字が変わる
    →整数系の問題である
      →AGCなのでひらめきで解ける系の問題だと思う
        →操作を行う回数がそこまで大きくならない
          →ai,ai+1を交互に操作するとすぐに数字が大きくなる
            →手続きさえわかればシミュレート可能？
              →手続きが難しい
            →一番数字がでかい所は前の一手は自分のところ-両隣となる
              →そこから逆にシミュレート出来る？
                →逆シミュレートで大丈夫だった
    
arc033_3 データ構造    
  →数の集合Sに対する以下のクエリを処理
    →1.Sに数Xを追加
    →2.Sに含まれる数のうちX番目に小さい数を答え、その数をSから削除
  →1<=Q<=200000
    →セグ木、平方分割、等で可能なように感じる
      →BITはどうだろう？
        →これも行けそうな気がする
          →いいプラクティスになりそうなので全て実装するのもありのように思う
          
arc008_3 THE☆たこ焼き祭り2012
  →参加者含めてN人、たこ焼きをN個持っている、全員に一人一個
    →たこ焼きを投げる
      →座標と速度が与えられる
        →参加者1<=N<=1000
          →お互いの距離が与えられる
            →グラフに出来る
              →受け取る速度の上限、投げる速度の上限が与えられているので、それと距離を考えて辺のコストを求められる
          →一秒に一回しか投げられないため、その対処をする
            →参加者の元にたこ焼きが届くのは一秒に一回である
              →最初の地点からは1秒おきにしか投げられないので、最短距離で届いた場合、もう一個が届くのは同じ最短距離を通るため１秒後になる
              →別なルートから同時に届くといった場合、最短距離がそっちだったということになる
                →順序が入れ替わるとそれぞれが別の秒で起こるだけ
            →最短距離から組み換えを行う、最短距離が長いを早く投げた方が得である
              →貪欲？
                →降順ソートしてそれぞれに秒を加算してその最大を答えとする
                  →あってたけど、0人目も計算に入れててWAになっていたため悩んでいた
                
arc012_3 五目並べチェッカー
  →盤面が異常になっていないかどうかチェック
    →1どちらかのプレイヤーの勝利条件を満たしているのに、もう片方のプレイヤーがさらに碁石を置いている
    →2お互いが置いた個数がありえない状態になっている
      →注意点→oが黒、xが白
      →ななめもある
  →個数が２個以上離れているか、１個違いで白が多く置かれているのはだめ、2に反する
  →9個が並んでいる状態まではありえる
    →同じ色で5個~9並んでいる状態が二つ以上存在するのはおかしい
      →が、縦横斜めが重なっているところならあり得る
        →重なっているところを最後に置く想定
   →両方が勝利している状態はダメ
   →黒が勝っている状態で白がもう一手打っている
   →白が勝っている状態で黒がもう一手打っている
    →手数を数えてあれば分かる
  →ようやくAC出来たが、最後に打った一手を除いた時に勝っていればおかしいという判定で行けると分かった
    →上のやり方がごり押ししたがif文の嵐で死ねる

arc077_c guruguru 
  →1以上m以下の整数、aiの明るさにしたい
    →1.明るさを+1する
    →2.お気に入りの明るさxにする
  →ボタンを押す回数の最小を求めよ
    →1<=N,M<=100000
      →順送りしか出来ない
        →順送りのみした時どれだけ押すか？
      →M*2の配列を作る
        →前後でポイントする
          →累積和を取る
            →増えたり減ったりする特殊な累積和
              
arc063_c 木と整数 / Integers on a Tree
  →木が与えられる
    →木のいくつかの頂点に数字が与えられる
      →辺でつながっている２頂点の差が1になるように全ての頂点に数字を入れられるか
    →1<=N<=100000
  →ある数字が入っている頂点aから別の数字の入っている頂点bに到達する場合
    →a+間の頂点数+1<bかa-間の頂点数-1>bになっている場合はNO
    →aからbに到達するために辺の数の偶奇と場合、aとbの差の偶奇は同じでなければならない
  →頂点数が多いため、O(NlogN)程度で処理する必要がある
    →数字が入っている頂点からスタートする
      →DFSで各頂点に対して、どの数字が入っている頂点に到達するかを集める
        →数字が入っている頂点に到達したら、距離をチェックする
          →ダメな場合はNG
          →OKであればその地点の距離を0にしてさらに進む
            →到達可能な範囲内で、偶奇が合っているかのチェックは出来た
      →二つ以上の頂点から到達する事はないため、親子関係のみ考えれば良い
      →子の距離を戻り値として受け取る
        →複数存在する場合でもその頂点の数字からはそれぞれの子の距離は独立して考えてよい
          →端まで行っても数字が入っている頂点がない場合は増加させ続けるか減少させ続ければ良い

abc147_e Balanced Path
  →グリッドのマスを赤か青で塗る
    →そのあとマス(1,1)から(H,W)まで移動する
      →一回の行動でマス(i,j)から(i+1,j)もしくは(i,j+1)に動く事が出来る
        →経路上のマスの赤く塗られた数の和と経路上のマスの青く塗られた数の和の差の絶対値を偏りと呼ぶ
          →偏りの最小値を求めよ
  →2<=80<=H,2<=W<=80、0<=Aij<=80、0<=Bij<=80
    →制約上はO(max(H,W)^4)まで可能
      →本番中は赤グラフ青グラフで分けるようにして対応したことを思い出した。
        →それで最短距離を求めたがWAである
          →各頂点は+-(Aij-Bij)となる
            →取れる範囲がだんだんと広がっていくタイプの問題である
              →dp[80][80][12800]で各マスを埋めて行けば良い

arc034_3　約数かつ倍数
  →2個の正整数A,Bが与えられる、A!の約数でありB!の倍数でもあるような正整数の個数をINFで割ったあまりを求めよ
    →1<=B<=A<=10^9,A-B<=100
      →整数の問題(苦手なのでちょうどよい)
        →対象の数xはB!<=x<=A!であり、B!の倍数でありA!の約数
          →B!とA!はそれぞれ確実に含まれる、(A!=B!である場合は1)
            →間の数を素因数分解し、それぞれの因数がB~Aの間にどれくらい含まれているか求める
              →Aの含め方が難しい
                →計算間違えてただけで合っていた。4!を18と計算して混乱していただけ
                  →4!=24,3!=6で4!=2*2*3*2として3!=3*2となれば、2*3*2も2*2*3*2もA!の約数でありB!の倍数である。
                →プラクティスとしてはなかなか良問             
          
arc036_c 偶然ジェネレータ
  →乱数表を作る、0,1のみで構成されるNの数列
    →0の個数と1の個数の差がK以下
      →このような乱数表がいくつあるか求めよ
    →1<=N<=300,1<=k<=N
      →0,1,?のみ
    →1を+方向、0をマイナス方向とした範囲を持ったdpで行けるのでは？
      →300を起点として動かす
        →?は各点を+か-に動かす
    →問題を勘違いしていた、乱数表からどのような連続する部分列を取り出しても、その部分列に含まれる0の個数と1の個数の差がk以下でなければならない
      →なので問題としては一段難しい
        →9 4 ?011?1110の場合は2個目の?に対して1は入れられない
          →そのため、ある?は1か0に決まってしまう場合がありえる
        →一つの変更が全区間に及ぶのが難しい
          →総数をINFで割った余りを出すため、全探索は無理
            →各iから以前の状態を見るのは可能
              →ある?を0にするか1にするかを考える
                →その?を含むそれより前の区間を見ると、各iに対して範囲が取れる、それでkを越えた場所は切り捨てる
                  →各始点から開始した場合をマージするのが難しい
                    →i=1~nでの区間全体での結果を残す=>'1
                    →i=2~nの結果は'1の結果を-(s(i=1))した状態になる
                      →111である場合+3になる11であれば+2となる
                      →101であれば+1で01であれば+0となる
                      →1010であれば0となり010であれば-1となる
                      →??である場合2=1,0=2,-2=1にある状態、?だと1=1,1=1にある状態
                        →?が来た時にさらに外側に行くことは？
                        →途中の状態が見えないため、このやり方では出来ない
         →さすがにあきらめて、検索したが、解けるレベルのDPではなかった
          →https://blog.en30.net/2015/04/07/003011/
            →上の例では基準未満0に行かないように処理をし、kを越えたところでアウトとしている、またDPはメモ化再帰で行っている
              →この遷移は初めて出会ったと言えるレベル
             
arc042_c　おやつ
  →P円までのおやつを持っていくことが出来る
    →どのおやつについてもそのおやつがなければP円以下になるのであれば許してくれる
      →N種類のおやつに値段と満足度がある
        →それぞれのおやつについて最大でも1つしか持っていけない
          →満足度が最も大きくなるように選んだ時の満足度
  →1<=N<=5000,1<=P<=5000
  →1<=ai<=100,1<=bi<=100値段と満足度
    →ナップサックチックな感じを受ける、最大値がP以下になるようになるため
    →組み合わせる値段の最小値1<=M<=5000をdpのパラメータに入れる？
      →5000^3のループになるため、難しい
      →ソートして小さいやつから見ていく
        →これも5000^3になる
          →ならない値段の最大は100である
            →dp[5000][5000] = (満足度の最大,最小値段の最大)
              →で対応可能ではないか？
                →対応可能ではない、各値段における満足度の最大を取れるものが総合的に最大になるとは限らない
                  →最小値をdpのパラメータにするとTLEとなる
            →半分全列挙？
            →貪欲？
            →(最小値段の最大,満足度の最大)にしてみる？
              →これはダメ
       →ソートして大きいやつから見ていく？
        →AC
          →aiが大きいやつから見ていくことによって、範囲を大きめに取ったものが優先的に処理される
          →aiが小さくて満足度が大きいものも適正に処理される

arc060_c　高橋君とホテル / Tak and Hotels
  →N軒のホテルが一直線上に並んでいる、それぞれ座標xiに位置している
    →一日の移動距離はLを越えない
    →野宿をしない、一日の終わりには必ずいずれかのホテルにいなければならない
  →Q個のクエリが与えられる、aj,bjが与えられる、各クエリについてホテルajからbjに移動するために必要な最小日数を求めよ
    →2<=N<=10^5
    →1<=L<=10^9
    →1<=Q<=10^5
    →1<=x1<x2<x3<x4...<10^9
  →事前計算系かセグ木か
    →単純に難しい問題である
      →ある地点をスタートとして別の地点まで到達できるかどうかは一見独立しているように見える
        →事前計算はO(n)もしくはO(nlogn)で処理出来る必要があるし、queryはO(1)もしくはO(logn)で処理出来なければならない
        →各地点から到達出来る範囲の最大の場所は事前にキャッシュ可能
          →2分探索で求められる
        →各地点から何日でどこまで到達可能かはキャッシュ不可能
          →メモリがでかくなりすぎる
        →グラフにする？
          →ある地点からLの範囲内で一番遠い場所に辺を貼る
          →すると一番奥に集まる
            →枝が分かれている場合に複雑になる
              →両方に辺を貼る方法も考えたが、どうしてもai→biまでO(n)かかる方法しか思い浮かばない
                →
        →aiとbiを逆にしても同じ
          →片方向のみ考えれば良い
            →
      →自明なこと
        →どこまで行けるのかで対象の場所を越えてたらその日に到着をする
        →各地点からは明らかに一日で移動できる最大のところまで移動するのが最適
      →問題点
        →aiからbiまでを順番に辿る以外に処理方法が見つからない
          →事前計算としては
        →1.x1から2分探索してxiに到達可能とする、xiにはx1から何日かかったかとx1からスタートして到達したことを保持する
          →1.で処理されなかったxpから上と同じ手順を行う、すでにデータが保持されているところまで到達したら終了する
            →xpはx(p-1)にすでにデータが保持されているはずなので、それを+1した日数とする
            →この事前処理はO(nlogn)で可能
              →ai~biはbiに入っている日数からaiに入っている日数を引き算する
      →解説から
        →ダブリングを使用する
          →全然使ってないため、まったく発想になかった。

arc041_c うさぎ跳び
  →L個のマスが横一列に並んでいる。N匹のウサギがいる
    →i(1<=i<=N)番目のウサギはxi番目のマスにいる。
      →左または右向きになっている
      →自分の前のマスが存在し、ウサギがいなければジャンプして自分の１つ前のマスへ移動できる
        →ジャンプする順番を自由に選べる時、ジャンプの総回数の最大値を求めよ
  →貪欲な戦略で行ける気がする？
    →R...Lでどうやっても3になる
    →R.R.Lで？
      →Rのみを動かした時3となる、Lを動かすと2になる
    →R.R.L.Lの時
      →4となる
    →RとLが向き合っている範囲を考えればよさそうである
    →グループ分けをする
      →それぞれのグループの要素数をgとする
      →最初がRでない場合X0にR、最後がLでない場合Xn+1にLを配置するとする
      →Lが連続した後、Rが来たらそこでグループを区切る
      →それぞれの位置で境界となるRとLの位置を取る
        →境界となるRを動かす場合とLを動かす場合で大きい方を取る
          →他のウサギを境界に近い方から動かす
            →O(g)で可能
      →OK
      
arc028_3 高橋王国の分割統治
  →N個の町がありどの町からどの町にでもいくつかの道を通っていけるN-1本の道がある
    →木
    →バランス値を計算する
      →バランス値は首都とする町vを通らずに相互に通行可能である町の集合の最大の大きさ
  →1<=N<=100000
    →町iを首都としたときのバランス値を表す
  →それぞれの道に対して方向を定める
    →道に対して方向a,bを考える時、方向aのバランス値をdfsで決める
      →全ての道の方向a,bに対してバランス値を前計算する
        →すでにバランス値が入っていればそこから先の処理は不要である
    →道に対してバランス値を保持する配列を用意し、枝にはそのindexを持たせる、頂点には持たせない
      →TLEする、計算に同じループを何回も通るからと思われる
        →道が一本しかない場合に関して、バランス値を事前に代入してしまう
          →ウニグラフになっている場合はこれで処理可能
          →来た道が既にいくつのバランス値を持っているかわかる場合はn-b-1でそこから先のバランス値を取る事が出来る
            →http://kmjp.hatenablog.jp/entry/2014/09/01/0930
              →片道だけで考え、頂点の大きい方から処理する事により再帰を使う必要もなくなり、さらに高速化が出来る
                →頂点の小さい方にぶら下がる形で考えられるからである
                →この考え方は木であり、この形式の問題に対して応用が利く
      
arc027_3　最高のトッピングにしような
  →N種類のトッピング、トッピングiはti枚のチケットと交換できる
    →同じトッピングを複数回は入手出来ない
    →スペシャルチケットと通常チケットは区別なく使えるが、各トッピングごとにスペシャルチケットが1枚以上含まれていないといけない
    →トッピングにはうれしさという正の整数hiが決められている
      →入手したトッピングのうれしさの合計を最大化する
    →スペシャルチケット1<=X<=300,通常チケット1<=Y<=300
    →トッピングの種類数1<=N<=300
  →一見ナップサック的な感じである
    →チケットをこれだけ使った時の最大幸福数という風に考えるのであれば
      →dp[300][300][300]のような雰囲気のdpテーブルになるが
        →メモリ的にdp[2][300][300]が正解で、全ループで計算量も27000000であるので行けそうな気はする
          →あとは処理順で最大値が変わらないかとかが気になるところである
            →コーナーケースが見つからない
              →普通にdpの比較対象を間違えてただけだった、永久に更新されないcurrentと比較していたため、上書きされまくった

arc071_c TrBBnsformBBtion 
  →文字列FをTに出来るか
    →出来る操作は
      →1.A→BB,B→AA
      →2.AAAかBBBであるような部分文字列を選び、消す
  →サンプルから考える
    →ABAをBBBAに出来るか
      →1文字目をBBに変換すればよい
    →ABAをBBBBに出来るか
      →出来ないABA→BB BA→BBB BB→BBBB AA→BBBB BB A→BBBBBB BB→BBBBB 
        →ループする
          →AかBにすべてを変換を変換してしまうと考えると、シンプルになりそう
      →A→BB→AAB→AAAA
        →同じ文字は3つずつ増やせる
      →A→BB→AAB→BBBBB
        →別の文字にする場合は2から3つずつ増やせる
    →ABAをBBBBB
    →AABとBAA→BAA
    →2,1,2と1,2,2
    
m_solutions2019_c C - Best-of-(2n-1)
  →a,tのどちらかがn回勝つまでゲームを繰り返し行う
    →1回ゲームを行った時、それぞれの勝つ確率をA,B、引き分けになる確率をCとする
      →ゲームが行われる回数の期待値を求める
        →出力は互いに素な整数P,Qを用いてP/Qとあらわせる
          →R*Q≡P(mod 10^9+7)となる0以上10^9+6以下のRを出力する
      →1<=N<=1000000
        →どちらかがN回勝つまでの期待値は？   
          →まずN回勝つまでの期待値の計算が出来ないため、ここを抑える
            →http://drken1215.hatenablog.com/entry/2019/03/23/214500
        →解説を確認
          →引き分けがない場合を考える
            →X(M)でゲームがちょうどM回行われる確率を表す
              →M<=N-1,2N<=Mの場合はX(M)=0
              →そうでない時、M回ゲームが行われるのはM-1回目までで片方がN-1勝し、M回目のゲームでもその片方が勝つ場合
                →X(M)=m-1Cn-1((A/100)^N(B/100)^(M-N)+(A/100)^(M-N)(B/100))
                  →最後の一つは固定される為、m-1Cn-1で良い
          →引き分けについて考える
            →引き分けでないゲームがM回行われるまでに（引き分けを含めて）ゲームが行われる回数の期待値をY(M)とする
              →Y(M)=M*(100/(100-C))
                →証明
                  →Y(0)=0
                  →Y(M)=1+(C/100)Y(M)+((100-C)/100)Y(M-1)
                  →((100-C)/100)Y(M)=((100-C)/100)Y(M-1)+1
                  →Y(M)=Y(M-1)+100/(100-C)
                    →となるため、漸化式によりY(M)=M*100/(100-C)となる
          →答えはsum(M=Nto2N-1)X(M)Y(M)=sum(M=Nto2N-1)m-1Cn-1((A^nB^(m-n)+A^(m-n)B^n)M/100^(n-1)(100-C))
     →この問題の難しいところはM回ゲームが行われるための期待値を求めてCを計算に組み込んでいるところである
      →最初の発想としてどうしても勝ち、負け、引き分けを同列に考えてしまう
        →M回[引き分けではないゲーム]が行われる上で、引き分けが起こる確率を考慮するとMはこのような回数行われることになるだろうという期待値の算出に使用
      →Mの取る範囲内で処理をするという考え方もまだまだ出来ないし、期待値の計算が弱い
        →確率を考える系の問題として定期的にやるローテーションに組み込もう
          →この問題の解説としてhttps://www.creativ.xyz/best-of-2n-1-1080/を参照

arc076_c
  →R*Cの長方形の盤面 
    →1からNまでの整数が２つずつ書かれている
      →整数iが書かれている座標は
        →(xi1,yi1)と(xi2,yi2)
      →1からNまでの全ての整数に対し、同じ整数の書かれている座標同士を曲線で結ぶこと
        →曲線が長方形の外に出たり、互いに交わったりしてはいけない
          →このようなことが可能かどうか判定する
    →R*Cであるが、0も含まれるため盤面のマス数は(R+1)*(C+1)ある
      →1<=R,C<=10^8
      →1<=N<=10^5
    →通れないのはエリアを左右に横断するような通り方をしている線に対して
      →上エリアから下エリアの端に通るような場合が一つ
        →上下と左右を入れ替えた場合も同じ
          →押し出されなければよい
            →まず、横断するような点を全て拾う
              →これに対して縦断するような点がある場合はout
            →クロスしていても端に到達していない場合は線を引ける
              →いくらクロスしていてもok
      →線と線で比較出来れば良いが、それをやるとO(n^2)になるためtle
        →端から端に行く線だけを見ればよい
          →エリアを分割して保存できないか？
            →5角形等になるため難しい
          →縦と横でクロスしてた場合はそもそもoutであるため、エリアを考える必要はなさそう
            →横のみ、縦のみで構成されている場合もさほど難しくない
              →4点保存出来るため
            →面倒なのは斜めが入っている場合
              →x軸とy軸で独立して考えられる？
                →pllで保存出来る
                  →例えばr=10の時に5,0に配置された場合(0,10)を(0,5),(5,10)に分けることが出来る
                    →setに保存することで2分探索で捜査可能
                      →新しくできたエリアはエリア番号を発番する
                        →r=10,c=10で(5,0)(7,10)に同じ数が生まれた場合
                          →c=0は(0,5,0)(5,10,1)とc=10は(0,7,0)(7,10,1)
                            →といった形で分ける
                              →この場合横断する形である
                                →r=10は(0,10,1)となる
                          →そして(3,0)(8,10)に同じ数がある場合、2分探索で違うエリアを拾うことになる
                          →エリアは数の大きい方に増える
                            →実装がめちゃくちゃめんどくさい


arc053_c C - 魔法使い高橋君
  →N個の魔法を使え、魔法は1からNまで番号が振られている
    →i番目の魔法を唱えると気温がai度だけ上がった後bi度だけ下がる
      →全ての魔法をちょうど１回ずつ唱える
        →気温の最大値Xを最小化する
  →1<=N<=10^5
    →1<=ai,bi<=10^9
  →Nの範囲から行くとo(n)もしくはo(nlogn)
    →上昇値が小さく下降値が大きいものを優先的に使う？
      →そのように使っていきたいがただ単に上昇値が小さいものを優先的に使用しようとすると上昇値>下降値のものを使用してしまう
      →一番最初に使うものとしては上昇値が一番小さく下降値が一番大きいもので良い
        →次に使用するものが難しい
          →上昇値uがmax-uを越えない範囲のものがあれば下降値dが大きいものを使用したい
            →超えない範囲のものは二分探索で出せはする
              →となると配列を二つに分ける
                →u>dの配列aとu<=dの配列bである
                  →まずbをmaxu-curdで二分探索する
                    →見つかったものよりも小さいものがあればbの中から使用しその要素を削除する
                      →最初は全てこっちから使うのがよいだろう
                        →bを全て使用したらaを使用する
                          →最小の位置になっているため、ここからはbの大きいものから使用していった方が良いように思える
                            →0に決めた状態で
                              →30,10 10,0を順番に使用する場合1,2では最大値は30、2,1では最大値が40になる
                              →30,10 30,20を順番に使用する場合,2,1が小さくなる
                              →30,20 40,20を順番に使用する場合,1,2は50, 2,1でも50となる
                            →この方針で実装してみよう
                              →waである
                                →反例は何か？
                                  →実装が間違っていたaの配列を降順でソートしていなかった
                                    →AC


https://atcoder.jp/contests/cf16-final/tasks/codefestival_2016_final_d
  →D - Pair Cards
  →N枚のカード
    →2<=N<=10^5
    →1<=M<=10^5
    →1<=xi<=10^5
    →xiが書かれている
      →2枚組をなるべくたくさん作る
        →2枚のカードに書かれた整数が同じ
        →2枚のカードに書かれた整数の和がMの倍数
    →作る事の出来る組の個数の最大値を求めよ
      →最大で200000
      →x1=x2 x3<x4 x1+x3=M 可換性があるか
        →M=5 x1=2 x1=x2 x3=3<x4=7 
        →x1+x3=5　x2+x4=9
        →この場合x1,x2 x3,x4のペアの方がよい
          →和がMの倍数組み合わせで両方共ペアがないものはそのままくっつける
            →データの分け方を考える
              →同じペアの偶数個に関してはそのまま処理する
                →残った1個ずつだけを考えれば良い
                →違う、2,2,2,2,2,2,3,8みたいなときに3,8を使った方がより多くのペアが作れる
                →割った余りを集めるのが先
                  →処理優先度が高いのは奇数枚同士残っている数字
                  →次に高いのは奇数枚残っている数字
                  →最後に偶数

D - Five, Five Everywhere
  →https://atcoder.jp/contests/abc096/tasks/abc096_d
  →長さNの数列を一つ出力する
    →aiは55555以下の素数
    →a1,a2,a3...anの値は全て異なる
    →どの異なる5個の整数を選んでもこの合計は合成数になる
  →奇数と奇数を足せば偶数になるため合成数になる
    →5個選ばないといけないため少し工夫が必要
      →下一桁が1の素数を選ぶ
        →5個で5になるため5の倍数になる
  →5<=N<=55
      →やるだけ
  
B - Fusing Slimes
  https://atcoder.jp/contests/dwacon6th-prelims/tasks/dwacon6th_prelims_b
  n匹のスライム
    昇順に並んでいる
  操作をn-1回行う
    1以上n-i以下の整数を問う確率で選ぶ
      kとする
    左からk番目にいるスライムを右隣りにいるスライムの位置まで移動させる
      1匹のスライムにする
  スライムが移動した距離の総和の期待値に(n-1)!を掛けた値を10^+7で割った余りを求めよ
  2<=n<=10^5
  1<=xi<=10^9
    1以上n-i以下の整数を問う確率で選ぶ
      左からn-i番目までのスライムは常に存在する
        というかどれかスライムを一体選んで隣のスライムにくっつけるでも同じ意味である
      右隣にしか移動出来ない
        確率の分母は(n-i)!
          例えばnとn-1が確率は100%
          n-2とn-1がくっつく確率はn-2よりも先にn-1が選ばれない場合の数
            1/2である1/2の確率でx(n-1)-x(n-2)が起こる
              さらに1/2の隔離でxn-x(n-2)が起こる
          n-3について
            n-2の位置まで移動する確率は1/2である
              むしろ100%の確率でx(n-2)-x(n-3)が発生する
                そのうえでn-3からx(n-1)-x(n-2)が発生する確率は何か
                  xn-x(n-1)も同様に求められそうであるが
          むしろx1から考えた方がシンプルになりそうな気もする
            x2-x1は全てのパターンで起こる
              x3-x2は全てのパターンで起こるがx3-x1が含まれるパターンは
                x2が先に選ばれてx1が後から選ばれる場合の数
                  (n-1)!/2*(x3-x2)である
              x4-x3において
                x4-x2が選ばれるパターンは(n-1)!/2*(x4-x3)である
                  全ての間隔でこれが行われる
                    全体sから考えsは(n-1)!で起こり
                      s-x1は(n-1)!/2で起こる
               ならばs-x2はどうか
                連続した4つを見た時に、右3つが先に選ばれるパターンである
                  左が一番最後に選ばれるパターンともいえる
                    4!/4であるということは上の
      1 2 3で考えてみると
        2-1は重複して起こらないため、2*1
        3-2は全体パターンより2*1、先に2を選んだパターンより1*1で合計5である
      AC　期待値の問題を自力でさばけたのはなかなかうれしい
        もう少し考察を詰めておきたい
          各区間が現れる確率の総和であることは間違いない
            連続したx個を選んで一つだけ位置を固定して並び替える場合の数は
              x!がx個を並び変える数
                一つだけ固定するので
                  (x-1)!となるつまり(x-1)!=x!/x
                これをn個の中の連続したx個のうち一番左を固定した数ということになると
                例えば4個のうち2個で考えると
                  4!=24 1 2,2 3,3 4のいずれかが固定されるパターンは
                    1,2,3,4
                    1,2,4,3
                    1,3,2,4
                    1,3,4,2
                    2,1,3,4
                    2,3,4,1
                    3,1,2,4
                    3,2,1,4
                    3,4,1,2
                    3,4,2,1
                    4,1,2,3
                    4,3,1,2
                    の12パターンである
                      いずれか2個が固定されるというのは
                        逆になっているのを省くということである
                          どれか2個を考える時にx<yになっている場合と
                            y<xになっているのは同じだけ登場するため
                                全体の場合/2で求められる
                      式はn!/x*v1+n!/x*v2,....,となっているため
                        n!/x*(v1+v2,...,vn)となり間隔の総和となる
                      
C - k-DMC
  →https://atcoder.jp/contests/dwacon5th-prelims/tasks/dwacon5th_prelims_c
  →dpまではやった、あとはkの範囲で考える
    愚直にやるとTLEである
      あ、Qが75である
        愚直解でも間に合うのではないだろうか
          全体でdpとるとお亡くなりになる
            これはk毎にdpを取るのが正解ではないだろうか
      あるiに対してs[i]='C'のときi-kの範囲内にa<bはいくつあるかという問題である
        'D'が現れた時にdp[0]を増やす、i-k-1に'D'が現れた時にdp[0]を減らす
          dp[1]が問題である、'D'が一つ減った時にdp[1]はiからi-k-1に存在しているM分減る
          i-k-1にMが現れ、消える時は、このMに対するDは全て償却されているからdp[1]の数字は変わらない
            
D - Forest 
  https://atcoder.jp/contests/apc001/tasks/apc001_d
  森が与えられる
    各頂点にはコストが与えられている
    森を連結して木にする
      連結は森の頂点同士を辺でつなぐ、その時にv1+v2のコストがかかる
        一度連結で使用した辺は再度使用する事は出来ない
        連結出来る場合は最低コストを求める
        連結出来ない場合はImpossibleを出力する
    Impossibleのパターン
      同じ頂点を二度以上連結しないと木に出来ない時
    頂点数が多いため、効率的に処理する必要がある
      n^2が計算出来ないため、気を付ける必要がある
        組み合わせは重要ではない
          例えばv1,v2とv3,v4をそれぞれ連結したとする
            この時v1+v2,v3+v4が発生するがそれぞれを入れ替えたとしても最終の和は変わらない
              つまり使う頂点だけ選べばいい
                つなげる先はどこでも良い
                  まだつながっていない木と一つの大きな木がある状態となる
                    木が3つ以上ある時に頂点の数が1同士を連結すると手詰まりとなる
        頂点数が最も多いものを中心に集めるのが良い
          使える頂点をpriority_queueに入れていく
            unionfound木である必要がない
              
F - Engines
  https://atcoder.jp/contests/abc139/tasks/abc139_f
  エンジンをいくつか使用し、原点からの最大距離を求める
  1<=N<=100
    ベクトルで考える
      (x,y)+(a,b)=(x+a,y+b)に到達出来る
    あるベクトルvを使用するときに、そのvを中心として原点から遠くに点を打ちたいのであれば
      貪欲に探せるのではないだろうか
        nは100しかないため、それぞれのベクトルに対して処理すれば良い
          偏角ソートを使用して、あるベクトルvからv-πの範囲にいるベクトルを足していくという形でも行けそうである
            atan2(x,y)を使用する
              大3象限まで求められる
                ソートが完了したら配列を2倍にする、
                  n+1~2nまではπを足しておく
                    対象のベクトルから+πまでの範囲を足す
                      いや、i,jの角度2/πを超えるとベクトル的にマイナスになる
                        そのため2/πまでを見る
          
F - Frog Jump
  https://atcoder.jp/contests/abc128/tasks/abc128_f
  0からn-1に到達したい
    数値a,bがあり
    現在の場所xに対してx+a,x+bを繰り返す
      各マスには数字が決められていて、その数字分現在のスコアが増加する
        n-1に到達した時のスコアを最大化せよ
  1<=n<=10^5
    n-1%(a+b)=0もしくは
    n-1%(a+b)=aにする必要がある
      a,bは正の整数であるため1以上を指定する必要がある
  考えたのは全探索である
    約数の数は余り多くならないからだ
      一番多いのは(n-1)%(a+b)=0の時であるがこの時でもさほど大きくはならない
        n-1%(a+b)=aは約数をcとしたときにc > aとなる状態のものしか使用できないためaが大きくなるほど計算がすぐ終わるようになる
          やってみよう
            移動の仕方を間違っていた
              x+a,x-bを繰り返すという操作であった、間違えていたので考え直し
                しかし順番は正直x+a,x+bの形に直しても同じである
                  0→3→1→4という移動も
                    0→1→3→1と移動しているのと変わらない
                      少し厄介なのは
                        0→2→4は0→4で終わりになるため成り立たないというところである
              もう一つ見逃していたが、xにある蓮は消すのである、つまり同じところに2度着地は出来ない
                そうなると試行回数が全然変わってくる
                  aで飛んだ箇所にbが来るような組み合わせは出来ない
                    (n-1-a)の約数分だけパターンが作れる
                      n-1/2>aでなければならない
                        やはり約数の数で行けるであろう
                          累積和が使えそうである
                            累積和使わないとTLE
                          
C - Ordinary Beauty
  https://atcoder.jp/contests/soundhound2018-summer-qual/tasks/soundhound2018_summer_qual_c
  多分解けていない問題
    数列(a1,...,an)の美しさを隣り合う2項の組であって差の絶対値がdであるものの個数として定義
      1<=x<=n
      1<=m<=10^9
        n^m通り数列が存在する、美しさの平均を求めよ
  単純に差がdになっている個数を求めてそれをn^mで割る
    ai,a(i+1)の差がdなのである2つがそうなる個数は
      2*(n-d)*n^(m-2)
        である
        これがm-1あるのでm-1をかける
      (m-1)(2*(n-d)*n^(m-2))
        そしてn^mで割る
      (m-1)(2*(n-d)*n^(m-2))/n^m
      =(m-1)(2*(m-d))/n^2
  今であれば簡単である、当時は出来てなかった
    2はdが0の時に1にする必要がある

D - No Need
  https://atcoder.jp/contests/abc056/tasks/arc070_b
  既に前にACしてから半年以上経過している、良い復習のタイミングである
  1<=N<=5000
  1<=K<=5000
    カードの総和がk以上
      いずれかの場合で必須になるならaiは必要
        難易度は黄色弱
          一度解いているが全く覚えていないため、もう一度最初からといった感じである
    k=6 1,4,3とある時に、1が必須になる状態は作れない
      {3,4}を組み合わせると6を超える
        これがどういうことかを考える
          全体集合Sがあり
            ある数の集合s<kが存在する時にsに属さない数の集合tがあるとする
            tのいずれかの要素をsに追加した時にs>=kとなる場合そのtは必須となる
        そのような集合を全列挙するのがメモリ制限、時間制限的に難しい
      もう一つの発見としてはあるaiが必須となる場合ai<xとなるxは全て必須になる
      また不要な数は全て足してもkに届かないという特徴もある
        ここで考えるの大きい数から使用し、dpでk未満となるパターンを出す
          あるiを考えた時に1<=p<=iとなるようなsum(ap)は常に求められる
            k未満の数max(li)+sum(ap)がk以上とならない場合、そのようなiまでの数は全て不要となる
              書かれたコードからも去年の6月は越えていると思う

C - 菱型カウント
  https://atcoder.jp/contests/abc018/tasks/abc018_3
  r*cの長方形領域
    ひし形はいくつはまるかを求めよ
      縦横の長さは決まっている
        ある点からk-1までカバーされる
          ある点からひし形がつくれるか高速に検査出来ればそれで良いとは思うが、そこまで単純ではない
    最大は500*500*50程度か
      余裕である
        それぞれの行に対して入った出た、を考えれば良いだけ
          kが大きくなればなるほど調べる範囲が狭くなり計算量が減る
            前回やった時は累積和を取っている、えらかった
              なるほどね

C - ハイスコア
  https://atcoder.jp/contests/abc017/tasks/abc017_3
  n個の遺跡
    1<=n<=100000
  m種類の宝石
    1<=m<=100000
  li riの範囲の宝石を全て獲得する
    li riの範囲には得点siがついている
  重複する範囲を取ると得点が0になる
    重複しない範囲を上手いこと取って得点の最大化をしたい
      rでソート、対応するli-1を見てその地点の最大値を得るようにする
        問題読み間違えてた、全ての宝石を１つ以上獲得するとだめというルールを読み間違えてた
    これならば、どこかに穴が空くような取り方をすれば良い感じになる
      各宝石に対しての得点を出すように処理する
    
D - バレンタインデー 
  https://atcoder.jp/contests/abc018/tasks/abc018_4
  p人とq人というところで結局1<<18*1<<18となってしまう
    最大マッチングでもない
      どっちかを軸に考える必要がありそうである
    1<<18*1<<18というのは嘘である
    mcp*ncq
      18c9*18c9が最大だ
        どちらにしろ無理
          片方の決めたかはランダムでやるのでよしとする
        もう片方をどう決めるかが問題
          貪欲に決められるのでは？
            18c9*nで終わる
    
D - 高橋くんの苦悩
  https://atcoder.jp/contests/abc015/tasks/abc015_4
  Wを超えない範囲で最大化したいというところでdpだが、これ青パフォか？
    
C - 双子と○×ゲーム
  https://atcoder.jp/contests/abc025/tasks/abc025_c
  全パターン9!
    可能なので、後はmin-max法で処理する
      調べる場所は4方向で良い

D - 高橋君ボール1号
  https://atcoder.jp/contests/abc026/tasks/abc026_d
  A*t+B*sin(C*t*π)=100になるtを探す
  計算式は100-A*t=B*sin(C*t*π)
    C*t*πは振動する
      B*sin(C*t*π)=pとしたときに
      -B<=p<=Bの範囲を取り続ける
      100-A*t<-B && B<100-A*tとなる範囲は調べる必要がない
        このタイプで調べられるのは2分探索もしくは3分探索だが
          (100-A*t)-B*sin(C*t*π)=0になるような場所を探せば良い
            100-A*tは単調減少でB*sin(C*t*π)は振動
            (100-A*t)/B-sin(C*t*π)=0
            こうすると-1<=p<=1の範囲で良くなる
              sin(C*t*π)=x
              (100-A*t)/B=x
              (100-A*t)=xB
              -A*t=xB-100
              A*t=100-xB
              t=(100-xB)/A
              sin(C*(100-xB)/A*π)
      A*t=100-B*sin(C*t*π)
      A*t=x
      100-B*sin(C*t*π)=x
      t=x/A
      100-B*sin(C*x/A*π)=x
        となった時にxを入れた時にxが出てくるx/Aが正解である

C - 倍々ゲーム
  https://atcoder.jp/contests/abc027/tasks/abc027_c
  xの値を2xまたは2x+1に置き換える
    置き換えた値がNを超える場合、その時の手番の人が負ける
      最大と最小で考えられる
      次第に範囲が広くなる
      最小がnを越えてしまう手番の人が負け
        例えば10の時
        1 2 4 8
          3 7 15
          t a t
      値の増え方を考える
        1 
        2 3
        4 5 6 7
        8 9 10 11 12 13 14 15
        16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
        結局全ての数がカバーされるわけである
        これは半分で考えられる
          例えば2であればtは2を取る3であれば2,3両方ok
          4となるとき先手は3を取る
          5となるときも3を取る
          6となる時先手は2,3両方負ける
          7となる時先手は2,3両方負ける
          8となる時先手は負ける
          9となる時先手は負ける
          10となる時先手は最初に2を取り勝つ
          11となる時先手は最初に2を取り勝つ
          12となる時先手は最初に２を取り勝つ
          13となる時先手は最初に2を取り勝つ
          結局数字は全て被らない為、
            自分の手番の時にどうしても越えてしまう数字以外は勝てるのである
            後手の場合は            
        前回は横一列に書いていったのであろう解き方をしていた
          そのような解き方もたまには役に立つ

D - 1
  https://atcoder.jp/contests/abc029/tasks/abc029_d
  １以上n以下の数を10進表記で並べた時に1は全部でいくつあるか？
  桁dp、1が出た時にカウントする

D - へんてこ辞書
  https://atcoder.jp/contests/abc030/tasks/abc030_d
  単語aを調べようとしてからkステップ経った時調べようとしている単語の番号は何か？
  6 4
  5
  2 3 1 2 6 5
  out 3
  1<=k<=10^100000
  ループに入るまでのステップ数、ループ内での一周辺りのステップ数
    で、前回は無理やり求めた気がする
      10^100000をどうしたかがいまいち思い出せないが
        文字列に対する割り算をした余りを求めるだけである
    ループの最初の位置、最後の位置に関しては配列に収めることが出来
    割り算をした余りに対してどこに配置されるか出す
      その位置からループに入るまでのステップ数を減らす
      ループに入るまでのステップ数>ループ一周のステップ数を考えるとめんどくさい
      というかkが1000000程度であれば普通にやってしまえば良い
        k>1000000を超える時は上の計算を行う、確実にループに入るまでのステップ数よりもループに入ってからのステップ数の方が多いからである

D - 語呂合わせ
  https://atcoder.jp/contests/abc031/tasks/abc031_d
  1<=|si|<=3
    1~kに対応する文字列を逆算して求めて出力する
    文字列は全て小文字
      全探索は26^27となるため不可能
      文字列を全てつなげて整合性取る方が楽そうである
        1<=n<=50
        50*27=1350
        1~3文字ずつ取るように進んでいくので、最終的な数が足りない場合は戻すか増やす
        ある文字が初登場であれば３文字までセットする
        再登場であれば既にセットされている文字と同じ文字数取って検査する
        結局26文字分見た後は場合分けが不要である
          一番後ろまで行けたものが答えとなる
             あ、つなげると文字列をまたいだものもokになってしまう場合があるため、だめ
<<<<<<< HEAD
=======
        
D - Worst Case
  https://atcoder.jp/contests/abc093/tasks/arc094_b
  x*yより小さい数を表すx'*y' かつx!=x' y!=y'の組み合わせは最大いくつあるか
    人数の増え方は一意に決められる
      1~10,1~10の組み合わせを考える時
        1*10,2*9,3*8,4*7,5*6,6*5,7*4,8*3,9*2,10*1が一番最大値を抑えられる
          順位が4,10である場合、スコアは40になる
          この時
            x'<4,y'<10にハマる組み合わせは全て40未満の組み合わせとなる
              むしろy'<=4かつx'<10またはy'<4かつx'<=10でもいい、
  4*4=16,3*5=15,2*6=12
   対象の数がxの平方数である場合、x'<xなる2*x'が作れる最大のスコアの小さい人の数となる
    というかこれは片方ずつ決められるのではないだろうか？
    10,5の場合x'<10を考えると9は4,8は6,7は7,6は8....といったように全ての数が決められる
    y'<5の場合は4は12,3は、、、、といったように全て決められる
      しかし最大数が12となっている、、、、何が違うのか？
        9*6が行けないためである
     2分探索でx'*y+1<x*yのようなx'<xを探せば終わりかと思ったが以下のような理由により数が多く出てしまう
      もちろん10,5の場合のように8*6=48,7*7=49,6*8=48,5*9=45のような形で山なりになる場合もあるため、理想的な線が単調現象になるというわけではない
        しかしこれを探すのは時間がかかってしまう、と思ったが1<=q<=100である
          
        x'*y+1<x*yのようなx'<xがあり
        x'-1*y+2>x*yのような場合の対応が出来ていない
            このような現象はx>yの大きい方を対象としたときに発生する
              22,40であれば38*23は22*40を超えず、23*38はその山の両端となる22*39=858,876となり23以下は下降線となる
                頂点は(23+38)/2=30.5となり、31,30で31*30=930となることが分かる
                  880は大分超えている
                    38*23=874を考えたときにたった5だけしか入る数字はないが、24*36=864なので、使える数字を全てピックアップすると874より小さい数字になるため、単純に880と874の間の数字で考える事は出来ない
                      24*36=864,25*35=875,26*34=884なのでx,26*33=858,
                      なんとなくグラフはジグザグになっている感じである
                        27*32,28*31,29*30,となりここで交差する、片側は7、交差して7である、14+22=36
                      もう片方が21であるため、57となる
>>>>>>> cd543f920ee697621abc4164ff8df3e2645259de

E - Colorful Hats 2
  https://atcoder.jp/contests/sumitrust2019/tasks/sumitb2019_e
  the 数え上げな問題
    基本的には掛け合わせて行けばよい
      自分より前に自分と同じ色の帽子を被っている人が何人いるかが与えられる
        同じ色の帽子を被っている人の最大値が分かる
          ある数が来た時にその数+1になれる色はいくつあるのかで分岐するわけだ
            その数を元に処理すれば良い

D - Blue and Red Balls
  https://atcoder.jp/contests/abc132/tasks/abc132_d
  n個のボールを一列に並べる
    kこの青いボールのみを回収する
      k個の青いボールを回収するのにかかる操作の最小回数
      k個の青いボールを回収する為にi回操作をする必要があるボールの並べ方は何通りか
        1<=i<=kを満たすiについて計算する
  1<=k<=n<=2000
    青いボールに仕切りを入れる方法
    赤いボールの間に青いボールを入れる場所
      これの積
    赤いボールの方が青いボールより少ない場合もある
      仕切りの個数は赤いボールの数が限界である
        青いボールの間の仕切りはk-1個ある
          k-1C(i-1)となる
        赤いボールのどこに配置するかは
          赤いボールの外側にも配置出来る為
            r+1
          青いボールはi個に分割されているが、r+1より大きくなっている場合も考えると
            しかし常に最小になるように取っていくため、同じところに複数並んでいた場合、それを分割して取る事はないだろう、つまり0通りとなるのでは？
              
E - Common Subsequence
  https://atcoder.jp/contests/abc130/tasks/abc130_e
  整数列sとtが与えられる
  s,tの部分列の組であって、整数列として等しいような組は何通りあるか？
    要素数は2*10^3
      ２重ループは可能である
    1以上10^以下からなるということであるが
      部分列は元の順序を保っている状態
        編集距離っぽい？
          1 1
        1 1 2
        1 2 5
          1 1
        1 1 1 2
        1 1 2 3 
          2 3
        3 0 1 1
        2 1 0 1
          3 4
        3 1 0 1 
        4 0 3 4 
        (),(3,3)(4,4)(34,34)
          3 4 5 6
        3 1 1 1 1 1
        4 1 3 3 3 3
        5 1 3 7 7 7
        6 1 3 7 15 15
      この考え方ではカウントが出来ていないパターンが発生する
          3 4 5 6
        3 1 1 1 1 1
        4 0 2 2 2 2
        5 0 0 4 4 4
        6 0 0 0 8 8
          3 4 5 6
        3 1 1 1 1
        4 0 3 3 3
        5 0 0 7 7
        6 0 0 0 15
          3 4 3 4
        3 1 1 2 2
        4 0 3 3 8
        

          3 4 5 6
        3 1 1 1 1 
        4 1 3 3 3 
        5 1 3 7 7 
        6 1 3 7 15 

          1 2 1 3
        1 1 1 2 2
        1 1 1 2 2
          1 2 1 3
        1 1 1 2 2 2
        1 1 1 2 2
    左からくるものを累積、上から来るものは下ろすという形で組み立てた
      このように数をまとめながら更新していくみたいなやり方はまだまだ不慣れということである
        しかし、整理しながら考えることに関して少し鍛えられた
          
B - Voting Judges
  https://atcoder.jp/contests/agc041/tasks/agc041_b
  2<=n<=10^5
  m人がv問選び問題のスコアを1上げる
    n問の問題がスコアの降順に最初のp問がコンテストの問題セットとなる
    タイブレーク時の順序は任意
      スコアは最初から与えられている
        採用される可能性を持つ問題は何問あるか？
        採用されない可能性を持つ問題が何問あるか？とも言い換えられる
      かなりとっかかりが難しい
        採用される可能性が1通りでもあればそれは結果に含まれる
          最初にソートを行う
            まず全員が採用したい1問に全力でvoteする
              vとpの関係も重要である
            ソート後配列
              a1<a2<a3<a4<a5となっている場合
              p<vである場合
              投票者が1の場合a1が使えるということはあり得ない
                v分voteしないといけない為
                  a1を含むいかなる種類の組み合わせで投票した場合でも
                  a1は上からp内に含まれない
              しかし投票者数、vとnの関係によっては無理とも言い切れない
                最初から上位pまでの数は調査不要
                ある数以下は使用されないという形になるので、2分探索な気もする
                  ある数を考える時
                    1.ある数にmを足す=a
                    2.a以下の数に使えるだけmを足す
                      vを使い切っていて、かつpに含まれている場合はok
                    3.aを越えている数にmを足す、この時点でp未満であればアウト
                    4.残りを考える
                      4.1.残りのvについて
                        どうしても上側に余りが出るようになる
                          例えば階段状になっていて、その残りのテスト数/2=vであり、a-t=m-1であれば全て同じ数に出来る
                            このならしの処理がキモである
                              はみ出るのであれば一番はみ出るところにm分投票させる
                                はみ出ないところまでこれを繰り返す感じとなるだろう

                    その数未満の数について最初にその数を超えない範囲で投票権を使用する
                    投票者の人数は最大10^9
                      m=5,v=5 
                      4 3 2 1 の場合は全部埋まる
                      m=5,v=5
                      4 4 3 3 2 2 1 1の場合
                      埋めて行くと
                      4に4使い1余る
                      4に余り1を使いさらに3使い、2余る
                      3に余り2を使いさらに1使い、4余る
                      3に余り4のうち3使い、1余る
                      2に余り1使い4余る、という感じでスライドさせて行ける
                      この総和がm*vを下回っている場合は使用していくしかない
                      m=5,v=3
                      4 4 3 3 2 2になった時に初めて下回る
                      これも2分探索出来るのでは？

B - よんてん
  https://atcoder.jp/contests/tenka1-2012-final/tasks/tenka1_2012_final_b
  3点が1直線に並んでいない４点の選び方を求める
  1<=n<=10000
  0<=xi<=99
  0<=yi<=99
    nC4が選び方の全通りである
    範囲がさほど広くないのがポイントだろうか？
      3点並んでいる場合でも全探索は計算量が多くなる
        10000*9999*9998で間に合わない
          そもそも2点を選べないということに気が付く
        つまりxi,yiの制限の方から処理するのである
          ある直線状に乗っている点の数を全てカウント出来れば計算可能
            2点を考えるだけでも100*100*100*100となるのである
              0<=xi<=99,0<=yi<=99のなかで3点以上を取れる直線は
                最大99のうち素数同士の組み合わせとなる
                  0~99の素数は25
                    となると25*25で、yは下降分もあるので25*50
                      1250でそれを10000と考えると12500000となる
                        重複を省けばかなり少なくはなるだろう
                          あ、(1,4)なる点の取り方がある事を気づいた
                            合成数も全然ありうる
                              ただし、2,8は含まないわけである
                                y=ax+bを考えるとa,bの組み合わせに対してどれだけ属しているかを取れば良いだけなのだが
                              一番急だと思われる0=99x+bを考える、x=98まで対応出来るのだがb=-(99*98)となるわけだ
                                bが結局10000近くなる
                                  aは最大99でbは最大30000ぐらい、ここに集めるのであれば。。。
                                    bの取る範囲が整数ではなくなる事に気が付いた、これではdpが成り立たない
                                      ある2点に対してxの昇順にソートする
                                        xの小さい方から大きい方への直線で考える
                                          起点よりxの大きいある点を拾い、gcdを取り、その直線の先を見る、既に見ているかどうかmapに保存する
                                          それでも10000*9999-2000000程度になる
                                            これも厳しい
                                              どうしても(x,y)の組み合わせをこのiが既に処理したかのチェックが行われてしまう
                                                つまり10000*10000の組み合わせとなる
                                              ああ、3点並ぶ場合に、格子を考えると(0,0)~(1,49)~(2,98)など2点目が最大でも50を超えない場所に出てこないと行けない
                                                このような範囲の限定方法を思いつくことが出来ないのが数学力の低さであるが、一つ賢くなったとも言える
                                                  xは最大49,yは-49~49の範囲となるため
                                                    5000程度となる
                                                      50*100*100*100であれば間に合う
        条件について考え切れていないのである
          この問題であれば
            0<=xi<=99,0<=yi<=99で3点を取るための一次関数の範囲とは？
              について考えていない、ここに気が付けばaが50を超えないということにも気が付けたであろう
                気が付くということに関して一つ勉強になった
        
J - Color Ball
  https://atcoder.jp/contests/wupc2019/tasks/wupc2019_j
  数え上げ
  1<=n<=2000
  1<=m<=2000
    同じ色のボール同士は区別されないがボールの色の順番は区別される
    ボールの数は変わらないようにする
    　制約がさほど大きくないとは言え結構な難しさ
    dpで決められるか？
      全パターンの入れ方を試すのは無理
        数と順番の条件がかなりきつい
          何色がどれだけ残っているのかを管理するのは現実的ではない
        数を考えなければn-1^mで終わる話である
          mが最大2000というところから崩せる？
          余事象で考える？
            そもそも全体が分からない
              一度自分の所に入れる場合も考えて考えてみる
                順番を意識するということは全体で考えるとm!/a1!,....,an!,となる
          
C - Count Order
  https://atcoder.jp/contests/abc150/tasks/abc150_c
  順列nがあり、p,qはそれぞれnを並べ替えた時のa番目に小さい順列、b番目に小さい順列となっている
  この時|a-b|を求めよ
    1<=n<=8なので全探索でも可能は可能
      next_permutationで処理してしまうのが速いだろう

A - Irreversible operation
  https://atcoder.jp/contests/agc029/tasks/agc029_a
  黒白の順番で並んでいる所を白黒にする
  最大何回この操作を行うことが出来るか
    右から考えると、黒が見つかった時に残りの白の数だけ交換出来る
      以上

B - Evilator
  https://atcoder.jp/contests/agc015/tasks/agc015_b
  iからjに行くときのエレベーターの乗る最小値の合計を求める
    2<=|s|<=10^5
  上の階化へ行くときと下の階に行くときで場合分け出来る
    s1はu,snはdである
      ある階siから下に向かう時、siがdであれば各回に一度で行けるuであれば各階に二度で行ける
        移動コストではなくエレベーターに乗る最小回数であるため、そのままである

D - Double Landscape
  https://atcoder.jp/contests/keyence2019/tasks/keyence2019_d
  n*m
    i行目に書かれている最大の値はai
    j列目に書かれている最大の値はbi
      書き込み方の個数を求めよ
        上限ではなくあくまでも最大値であるため、ai,biで登場するものに関しては確実にそこに書かれている必要がある
      最大値は確実に決まっているはず
        小さい数から決めていくのがいいのだろうか？
          あるaiに対してy1~ynはai<=y1~ynと配置される必要がある
            このような状態はありえるか？
                 4 8 12 16
              7  4 7 5  6
              8  3 8 x
              12 2   12
              16 1      16
              8の列に配置出来なくなる
            あとは好きに配置できるパターン
                 13 14 15 16
              13 13 
              14    14
              15       15
              16          16
            これも条件を考えると結構シンプルになるのではないだろうか
              小さい順に見ていくとある場所でこれだけの数字が使えるというのが分かるわけだが、
              2行目において既に使える数字が尽きている状態となっている
                まだ使用されていない使える数字が縦横で尽きてしまった場合は0通りとなる
            小さい数字から使用していく
              下のパターンであれば
                13は縦横ぶつかる場所にある為、残り12個中6個を自由に使用出来る
                  12p6
                次の14も縦横ぶつかる、残りの場所は6-2で4箇所であり残りの数は6となっているので
                  6p4
                次は15も縦横ぶつかる、残りの場所は6-4となっており残りの数は2となっているので
                  2p2
                  これは結局12!となるがこのように求めていくのが良いだろう
                    3*3程度で試せるものは全て試す
                    最初に3を指定できる作りにしてみる
                      3 3
                        3 9 7
                      5 3 4 5
                      8 2 8 6
                      9 1 9 7
                      3 3
                      3 9 7
                      5 8 9
                      で3!*2!*2! で6*2*2=24
                        合っている
                    最初に4を指定できる作り
                      3 3
                        4 8 9
                      5 1 5 3
                      7 2 7 6
                      9 4 8 9
                        3*3p2*2*1p1*2*1p1*1*0p0*1*0p0
                        18*2*2=72
                        3 3
                        4 8 9
                        5 7 9
                  出来た、前よりもスマートに出来た気はする
                    
B - Fusing Slimes
  https://atcoder.jp/contests/dwacon6th-prelims/tasks/dwacon6th_prelims_b
  2<=n<=10^5
    n-1回の操作をする
      移動した距離の総和の期待値に(n-1)!を掛けた値を求める
    ある区間が1度使われるのはどうだこうだみたいなやり方で解いた気がする
      それにとらわれるとはまりそう
        1 2 3 を考えるとき
          全パターンは1,2か2,1
            1→2が使用されるのは2回
            2→3が使用されるのは3回である
              (n-1)!を掛けるというのは期待値の総和の分母を消すということなので、分子についてのみ考えれば良い
        分子だけで考えると
          2*1+2*1+1*1
          これを全体で直すと
          2*(1+1)+1*1
        1 2 3 4で考えれば
          3!であり
          2→3が2度発生するのは
          (2 3 1)
          (2 1 3)
          (3 2 1)
          の3パターン
            左側が選ばれるより早く選ばれるということである
              となると
              3!/2!,3つめとなると3!/3!
            3番目が2回通るのは
            (2 3 1)
            (1 3 2)
            (3 1 2)
            の3パターン
            3番目が3回通るのは
            (3 2 1)
            の1パターンのみ
          6*(1+1+1)+3*(1+1)+1*(1)
        これを増やせば終わる
        1 2 3 4 5
          で2→3が2回通るのは？
          (2 1 3 4) 
          (2 1 4 3) 
          (2 4 1 3) 
          (2 3 1 4) 
          (2 3 4 1)  
          (2 4 3 1)
          (3 2 1 4) 
          (3 2 4 1) 
          (3 4 2 1)  
          (4 2 1 3)
          (4 2 3 1)
          (4 3 2 1)
            の12パターン
            全部で4!なので4!/2!である
          で3→4が2回通るのは？
          (1 3 2 4)
          (1 3 4 2)
          (1 4 3 2)
          (1 4 3 2)
          (2 3 1 4)
          (2 3 4 1)
          (2 4 3 1)
          (3 1 2 4)
          (3 1 4 2)
          (3 4 1 2)
          (4 1 3 2)
          (4 3 1 2)
            の12パターン
            合ってるはずだが、サンプル2が合わない
              何だろう
                finvではなくinvを使用した

D - 11
  https://atcoder.jp/contests/abc066/tasks/arc077_b
  部分列の個数をカウントする、同じ物は1通りにする
  1<=n<=10^5
  1<=k<=n+1
    1 1 2 3で考えた時
      k=1 1
      k=2 4
      k=3 3
      k=4 1
    末尾が何かを意識しながらやるならdpなのだが、数字の範囲的にそれは難しい
      よく考えたら割るだけ？
        というか引くだけ？
      全体を求めるとまず(n+1)ck
        ここまでは問題ない
          同じ数が出てきたとき、前に同じ数が出てきたときに持っている組み合わせ数を省くのだが、今回は長さに制限がある
        しかもk毎にループが出来ない
          制約をよく見ていなかった
            どの整数も必ず一回以上出現する、である
              つまり同じ数が存在する数は一つだけである
                それであれば簡単、重複している数aの左側、右側において作られる場合の数を減らす
                  外側にある数tとする
                    aの位置は固定なので
                      tCk-1
                      (n+1)Ckからこれを引けば良い
                    t<kとなったタイミングでこれは0となる

F - Many Many Paths
  https://atcoder.jp/contests/abc154/tasks/abc154_f
  
D - Equals
  https://atcoder.jp/contests/abc097/tasks/arc097_b
  UnionFindを使う問題であるが、どうやったか覚えていないので解きなおし
    自分の番号の所に自分が入れるかどうかを考えるわけであるが
    基本的には同じグループ内であればどこにでも動ける
      自分のグループと自分の番号の場所にいる番号のグループが同じであれば良いのだ
        以上

C - Switches
  https://atcoder.jp/contests/abc128/tasks/abc128_c
  n個のスイッチとm個の電球がある
    それぞれに番号が振られている
      電球iはki個のスイッチにつながっている、スイッチsi1,si2,...,sikiのうちonになっているスイッチの個数を2で割った余りがpiに等しい時に店頭する
        全ての電球が転倒するようなスイッチのon/off状態の組み合わせは何通りあるか？
    スイッチは高々10個であるため、全探索
      1<<10
        チェックは10*10=
      1<<10*100で100000程度
  
C - HonestOrUnkind2
  https://atcoder.jp/contests/abc147/tasks/abc147_c
  n人の人がいる
    正直者か不親切な人
      yij=1の時、人xijは正直者である
      yij=0の時、人xijは不親切な人である
    n人の中には最大で何人の正直者が存在し得るか？
      ある人iが正直者であると仮定する
        iが正直者である場合
        ほかの正直者から正直者であると言われている
          このチェックを行えば良い

B - RGB Boxes
  https://atcoder.jp/contests/diverta2019/tasks/diverta2019_b
  
D - Lucky PIN
  https://atcoder.jp/contests/sumitrust2019/tasks/sumitb2019_d
  bool ex[10][10][10]
    1<i<n-1について考えれば良い

A - 勇者ビ太郎 (Bitaro the Brave)
  https://atcoder.jp/contests/joi2019ho/tasks/joi2019ho_a
  h*w
  (i,j)=J,(i,l)=O,(k,j)=Iの(i,j,k,l)の個数が魔法の威力
  1<=h<=3000
  1<=w<=3000
    i,jが共通している 
      縦横で情報を集めておけば掛け算出来る
        横のO,縦のIの個数
          i<k,j<lなので
            (i,j)よりも右側、下側にある個数を掛ける

D - 新入生歓迎数列 2
  https://atcoder.jp/contests/tkppc4-2/tasks/tkppc4_2_d
  長さnの数列Aをプレゼントすることにした。
  人気の整数が２つあり、これがpとqであるという情報を入手した
  次の条件を全て満たす整数(x,y,z)の組がどれだけあるかを数えようとした
    Aは与えられる
      (Ax+Ay+Az)=pかつ(Ax-Ay-Az)=q
    真ん中を固定する？
  1<=n<=10^5
  -10^9<=P,Q<=10^9
  -10^9<=Ai<=10^9
    種類を考えるにしろ10^9なのでmapを使う必要が出てくる
      二つの数の組み合わせを作るのも難しい
        p-(Ax+Az)=p-Ax-Az=Ay
        q-(Ax-Az)=q-Ax+Az=Ay
      (p+q)-2Ax=2Ay
      (p+q)/2-Ax=Ay
      p-Ay-Az=Ax
      q-(-Ay-Az)=Ax
      (p+q)/2=Ax
        となり、Axは一意に定まる
          するとAy,Azも一意に定まる
      p-(Ax+Ay)=p-Ax-Ay=Az
      q-(Ax-Ay)=q-Ax+Ay=-Az
      p+q-2Ax=0
        こうするとAy,Azは0になってしまう
        Ayを考えた時
          Az=p-Ax-Ay
          -Az=p-Ax+Ay の数が分かれば良い
        mapで間に合うだろうか？

D - Factorization
  https://atcoder.jp/contests/abc110/tasks/abc110_d
  Mになる倍数の組み合わせを、長さnの数列で表現する
    最初にMを素因数分解する
      それぞれの倍数の数cをn個の箱に分配するのである
        つまり重複組み合わせ
          柵の数はn-1
            c+n-1Ccで後は掛け合わせる

B - 難易度
  https://atcoder.jp/contests/arc043/tasks/arc043_b
  n個の問題から4つ選ぶ
    この時
      i問目はi-1問目の2倍以上の難易度である必要がある
    累積出来そうな気がする
    昇順にソートしているという前提で
      あるiを選べる場合はi+1も選ぶ事が可能
        それらは独立に２倍以上の数を選べる
          なのでiにi+1の組み合わせを足しても重複はしないため、累積可能
      ある数以上の組み合わせ数に関してはこれで求められる
        そしてこれは3つの組み合わせまでであればO(n)で求められるということを示す
          ここから4つの組み合わせをどうするか考える
            dpで深さを指定していく、深さは最大4

D - Blue and Red Balls
  https://atcoder.jp/contests/abc132/tasks/abc132_d
  高橋君がi回操作する必要があるボールの並べ方は何通りあるか？
    i回操作するということは青のi箇所に仕切りを入れるということ
      k-1Ci-1
    赤色のボールの数のパターン数だけ掛け算する
      パターン数は赤色のボールの並びに仕切りを入れる数
        red+1Ci

C - Best-of-(2n-1)
  https://atcoder.jp/contests/m-solutions2019/tasks/m_solutions2019_c
  x回でどちらかが勝つとなると
    x回のうち
      それぞれの試行回数は
        x-1Cn-1*(A^n*B(x-n)+A^(x-n)*B^n)
        これの合計が全体回数となる
      (x/c)*(x-1Cn-1*(A^n*B(x-n)+A^(x-n)*B^n) / 全体の回数)
      なのでsum(x = 1:n*2 - 1)(x/c)* (x-1Cn-1*(A^n*B(x-n)+A^(x-n)*B^n)
        をそれで割る
          

