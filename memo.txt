arc002_3 コマンド入力
  →ABXYで作られた文字列
  →LとRに連続した２つのボタン入力を割り当てられる
  →最小入力回数を求める
  →1<=N<=1000
  →全部で16*16パターン96+160=256,256*1000しかないため全探索で処理可能

arc001_3 パズルのお手伝い
  →8クイーンで３マス埋まっている状態が初期値
  →8^5試せばよいだけであるため、そこまで計算量が大きくはならない
  →行ったり来たりする必要はないように思う

agc003_c BBuBBBlesort!
  →数列をソートする
  →操作１、連続する２つの数字を選び反転
  →操作２、連続する３つの数字を選び反転
  →ソートする為に必要な操作１の最小回数はいくつか
  →1<=n<=10^5
  →0<=Ai<=10^9
  →3つの数字を反転するということは真ん中の数字の位置は変わらず、一つ飛ばしで値が入れ替わるだけ
  →となると1の操作が必要なのはソート後の位置と奇数分位置が異なっている場合のみ
  →奇数個異なる箇所は偶数個ある
  →奇数個異なる数字の個数/2が答え
  →解説より、奇数番目と偶数番目がひっくり返っているということであるため、片方で奇数番目に現れて、片方で偶数番目に現れる数を数えるで奇数個異なる数字の個数/2と同じになる

arc005_3　器物損壊！高橋君
  →グリッドグラフ、コストは1、通れない場所をコスト2分までなら通れる、スタートからゴールまで行けるか
  →1 <= h,w <= 500
  →途中に通れない場所がない→Yes
  →スタートからBFSでマスを埋めていき通れないところまで到達させる
    →通れないところまで来たらなんらかの値を仮で入れる
      →行けるところ全て終わったら終了
  →ゴールからBFSして通れないところまで到達させる
    →通れないところまで来たらなんらかの値を仮で入れる
      →行けるところ全て終わったら終了
  →何らかの値が縦か横に二個連続しているところがあればYes、なければNo
  →二個連続しているところでは、通れる場所が離れていてなおかつ到達できる場合を満たすことが出来ない
    →それでもなんらかの値を仮で入れた箇所を通ってSからgまでたどり着ければ問題ない

arc006_3 積み重ね
  →トラックから積み荷を降ろす、それぞれの荷物は重さが定義されている。
    →積み荷を重ねることが出来るが、上に乗せた荷物が重い場合、下の荷物がつぶれてしまう→NG
  →全ての荷物を降ろした時に積まれている山の数を最小にしたい。
  →1<=n<=50
  →全部逆順で出てきたときは最大値となる
    →1,2,3,4,5,6,7,....
  →転倒数？
    →5 4 7 6→2
  →最長部分増加列？
    →5 3 4 7 6 8のパターンが反例
  →i,i+1を比較してでかいとき？
    →10 3 4 7 2 6のパターンが反例
  →サイズが50なのでシミュレーションでも行けそう→却下
  →後ろから見る
    →an<a(n-1)が増加している場合は同じ山に配置出来る
      →サイズが50なので取り出したところはフラグを立ててもう一度取らないようにする
        →処理出来る数字がなくなるまでの回数が答え

arc007_3　節約生活
  →oxの配列→o視聴可能な時間、x視聴不可能な時間
    →テレビをつけると視聴パターンが無限に繰り返される、テレビはつけると消せない
      →全ての時間視聴するための最低限なテレビの数を求めよ
  →1<=N<=10
  →少なくともoは一つ含まれる
  →最大10台用意
  →全部の時間に配置して、抜き取って良い場所を抜き取る？
  →1<<10だから全パターン試しても間に合う
  →全てのテレビをつけるまでに視聴出来ない時間があってもいいが、付けたら視聴出来ない時間があってはならない
    →2周目までに全て決まるはず
    →1周目に配置しても２周目に配置してもその次の周の見える時間は変わらないため、１周目のみに全て配置する事を考える
  →1個目は埋まっているためn-1の全パターンでも良さそう

agc040_b Two Contests 難易度青のくせにまだピンと来ていない
  →左端の最大と右端の最小がクロスしているかどうかで答えが変わってくる
    →しかし解説を読むと場合分けせずに答えが出るということらしい。
  →それぞれのコンテストを集合、問題iを解ける人の範囲を区間i、コンテストの楽しさを含まれる区間の共通部分の長さとする
    →半開区間にすることで区間の長さをr-lで表すことが出来る
  →ポイントとしては左側の最大と右側の最大を軸に考えることが出来れば意外とシンプルになる、そこに気が付かないとクリアは難しい
  →あとは解説の通り一つの区間と残りの区間の共通部分を取る(左側の最大と右側の最大が一つの集合に含まれている場合はこれで最大値が得られる)
  →ri-左側の最大=sと右側の最小-li=tをそれぞれ計算してtの昇順、タイブレークはsの降順でソートする
    →すると、この集合を一つ一つ処理していくと、sがだんだん小さく、tがだんだん大きくなっていく、ここでs+tの最大を取る

arc011_3 ダブレット
  →ある単語を別のある単語に変換する。人もずつ変換する過程で別の単語を経由していく、その最小手数を求める
    →最初と最後の単語、1<=N<=1000の経由出来る単語が与えられる
      →変換与えられた単語を経由して変換不可能である場合-1を出力する
  →グラフ化出来ないか？グラフ化出来るならダイクストラで対応可能
    →n^2は可能であるため、一文字違いの単語を全探索してグラフ化することは可能である。
      →グラフはインデックスに置き換えれば良い
      →作られたグラフで最初の単語から最後の単語までの最短路が答えとなる
      
agc024_c Sequence Growing Easy
  →長さNの数列Xがあり最初は全ての要素が0,Xのi項目をxiで表す。長さNの数列Aが与えられる、Aのi項目はAi、以下の操作を行い、XとAを等しく出来るか
    →1<=i<=N-1なる整数iを選ぶ。X(i+1)の値をXiの値に1を足したもので置き換える
  →先頭は0以外ありえないため0でなければ-1
    →先頭の次は0~1以外ありえないためそれ以外なら-1
      →上のように各iのmaxは決定している。
  →前後で2以上の開きがある場合も-1
  →1になっている箇所はその前のところを0の時に操作したものである、
    →例えば011となっている場合前からやると連続しているところで012となってしまうため、後ろから操作する
    →011012212の前の状態は011011010→011012212からは011012332など作成可能
  →各数字から先頭になっている場所を特定することは出来る。しかもその数が操作の回数となっている
    →前の数字と比較して+1されている時は+1、前の数字と比較して=の時は+Ai
    →前の数字と比較して-されている時は+ai
      →以上で反例はないと思われる。
      
codefestival_2016_qualB_d　Greedy customers
  →N人の人が1列に並んでいて、i番目の人の所持金はAi。品物を選んで価格Pを設定し、前の人から順にその品物を見せていく、各ひとは品物を見せられた時、その価格Pがその人の所持金以下だったと気品物を購入しその人の所持金がP減少する
    →出来るだけ多くの品物を売りたい、しかし売った人の所持金が0になるとその人は帰れない。
      →所持金を0にしないように、最大でいくつの品物を売ることが出来るか求める。
  →1<=n<=100000,1<=ai<=1000000000
  →全部1にすると先頭の人から後ろに行かない→×
    →先に先頭を1にして大きい数を後ろに回す？
      →前から考えられる、先頭は1になるまで削る、先頭以外はa(i-1) + 1< aiである場合、最低値段をa(i-1)+1として販売可能
        →割り切れる場合は0になってしまうため、ai/(a(i-1)+1)で割り切れる場合は-1する。（実は先頭も同じ）この和が答え
        
jsc2019_qual_c Cell Inversion コンテスト中に解けなかったやつ
  →2N個のマスが並んでいる、B,Wで埋まっていてBは黒、Wは白を表す。異なる2マスを選んで色を反転する。同じマスは２回以上選べない
    →N回の操作終了後全てのマスを白色にする方法が何通りあるかを確かめる
  →解説では選ばれた２マスが左側か、右側かというのは各マスについてどちらか定まるということである。
    →まず、各マスが左側になるのか右側になるのかを探る
      →BWWBの場合はLLRRとなる
        →この例を見る限り二つ同じものが並んでいる場合は左右決まりそうな気がする
          →BWWWBとなると真ん中は選べないため上の考え方はダメ
        →BWWWBとなった時、LLXRRとなる
        →BWWWWBとなると、LLRLRRとなる
    →左右の端がWの場合はXとなる、つまりB......Bというパターンのみ考えれば良い
    →偶数個並んでいる場合はLRLRLR...とおける
    →奇数個並んでいる場合は..LLXRR..となる？
      →BBBWWWBBBとなるとLXRLXRLXRとなるか？→OK
      →BBBBBの時、LXXXR以外は成立しない→NO
        →LRLXRかLXRLRがある
          →BBBBBBBの時は？LRLRLXR,LRLXRLR,LXRLRLR等が可能、len(m) / 2パターンがある
            →奇数になっているところを集めて後でまとめて掛け算可能
       →BWWBのように挟んでいる場合、対岸がRになる
        →BWWBWWBは?→LLRXLRRで行ける
          →全体を通して偶奇を取る必要がある？
            →BWWBWWBWWBの時はLLRRLRLLRRである
              →BBWWBWWBBは？LRLRLLRXR,LXLRRLRLRとなる、LRのパターンが変わる
      →LRのパターンは一意ではない、LRが決まればそこから求められる組み合わせは一意になる
      →LRからの処理順の計算方法
        →LLRRで考える→1つ目が選べるRは２つある、2つめが選べるRは1つだけになる
          →LRLRLRで考えると1つめが選べるのは3つある、2つめを選んだ場合、3つ目のLが選べるのは２つ、4つめを選んだ場合、3つ目のLが選べるのは１つだけとなる
          →LRLRLRLRで考えると組み合わせはLRLRLRLRとLXXRLXXRとLXXRLRLRとLXXXXRLRとLXXXXXXRとLRLXXRLRとLRLXXXXRとLRLRLXXRがある。
            →奇数の時と合わせると結構な組み合わせの数になる
            →さらに順番も計算する必要がある
          →組み合わせとしては、全てWにするために必要なLRのペア数がそれぞれいくつあるか分かれば、それぞれを階乗倍すれば答えは出る
            →計算量が大きい
  →操作手順は無視できるということ、それはわかるが
    →操作をN回行うということを忘れていた
      →この制約ならばそれはN!一択である、N回までに、であれば難易度は相当上がる(というか不可能？)
        →考えなおし
          
 agc033_c Removing Coins
  →木を用いて二人でゲーム、最適な行動
    →1<=N<=200000
    →N頂点、1~Nが割り振られている、N-1本の辺のうちi本目の辺は頂点aiと頂点biを結んでいる
      →各頂点にコインが一枚ずつ置いてある、操作を行えなくなった方が負け
        →操作、コインが置いてある頂点を一つ選び、その頂点vにおいてあるコインをすべて取り除く
          →その後、木上に残っているコインをすべて、今置いてある頂点に隣接する頂点のうちvに一番近い頂点に移動させる
    →1 2,2 3,2 4で、1を取り除いた場合に頂点１に1枚、頂点2のコインが2枚になる
      →2を取り除くと２にコインが3枚ある状態になる
    →grundy数の問題？
    →コインが置かれている頂点は常に連続している、つまり、コインを取る場所により残りのコインの枚数が変わるのが肝となる
      →端を取るとコインが置かれている場所が一つ減る
      →複数の辺が接続している場所を取るとその分コインが置かれている場所が減る
        →端を取るとその頂点にコインが集まるように移動する
        →端以外を取った場合は、全て同じ盤面になる
          →ある頂点から延びる枝が2以上であり、全ての枝の頂点数が同じである場合、端を取った場合は、その頂点がある辺のみ長さが変わらず、その他の辺は長さが１減る
            →一番長い頂点数を持つ辺の長さ分はゲームが可能？
            →頂点間が一番長い辺でゲームをしているのと変わらない？
              →DFSで一番長い頂点間は求められる
    →枝の伸びている方向を考える 
      →1,2のみであればsecond、1,2,3であればfirst、1,2,3,4の場合は残り2か所にするか3か所にするか選べる
        →残り2か所に出来るのでfirstとなる
      →1 2,2 3,2 4,4 6,6 5の場合はsecondとなる
        →Nは偶数、処理としては、一手目が終わった後、残りの石の位置は1,2,4,5、2,4,5、2,4,5、2,4,5、2,4,5,6となる
          →3になるか4になるかであるため、secondが勝てる
      →1,2,3,4,5の場合、4にするか5にするかを選べる、
       
nikkei2019_2_final_a Count Triplets
  →a1,a2,....anのNの要素
    →ai<aj>akを満たす(i,j,k)の組の個数を求める
      →座圧して1<=ai<=5000の範囲にしてしまう
        →累積和で左と右それぞれからl[5000][5000]、r[5000][5000]の範囲で累積和を取る
          →あとはj=2~n-1までajを処理して、その和を求める
   
nikkei2019_2_final_b NIKKEI String
  →文字列sを6分割して分割後のs1,s2,s3,s4,s5,s6がNIKKEI型(s2=s6,s3=s4)となっている個数を求めよ
    →6≤|s|≤500
    →s1を前からとs6を後ろからの2重ループを軸に考える
      →s6のindexでs1+1~s1+1+indexでs2も作れる
        →s2=s6の時にs5を後ろから取っていく
          →残りの文字列を半分にして同じ文字列が二つ作れればNIKKEI型
            →いちいちsubstringを使うのも計算量的に微妙であるため、500*500のstring配列に事前に格納しておく
            
nikkei2019_2_final_c Largest N
  →H行W列のマス目があり、それぞれのマスは黒または白で塗られている
    →マス(ai,bi)は白で塗られていて、他は黒で塗られている
      →自然数kに対してマス目がサイズkの'N'を含むとは、次の条件を満たすi,jが存在する
        →マス(i+t,j)(0<=t<k)が全て黒
        →マス(i+t,j+t)(0<=t<k)が全て黒
        →マス(i+t,j+k-1)(0<=t<k)が全て黒
      →このマス目に含まれる'N'のサイズの最大値を求める
    →黒マスがNの形になっている箇所を探す、形は全て正方形と考えて良い
      →サイズは3000*3000=9000000
        →正方形の数は
      →サイズa,bがありa<bの場合にaで作れず、bで作れる場合が存在する
        →2分探索では不可能
      →縦、斜めで尺取りを行い、黒で埋まっている範囲を出す、スタート地点のindexで最後まで埋める。
        →それぞれのテーブルを作って事前計算しておく
    →探索は縦か斜めに行えばいい
      →数は？まずスタート地点となるのが3000*3000箇所ある、それぞれに対して3000箇所考えられる→ストレートにやるとTLE
        →Nの最大を常に持っておけば、それ以下の範囲で探索は不要となる
        →縦、横、斜めそれぞれの最大の最小値がNの最大値となる
        →白始まりは存在しないため、白であれば探索は飛ばす
          →配置によってはTLEになりそう
            →Nの左上には情報が下の最大と斜め下の最大の情報が集められる、その小さい方がその左上から作れる最大N
            →Nの右下にもが集められるかもしれないが、不要である
              →探索の範囲は狭まったが、どうしても内部でループをする必要があるところまでしか削れない
              →実はNの左上にNの右側棒の情報が集められる気がする
                →ダメである、ループが必要となる
                  →始点と終点がある限り、これは難しい
                  →上の考え方で処理を作ってみよう

agc005_c　Tree Restoring
  →長さNの数列a1,a2,a3....an
    →頂点iと最も遠い頂点の距離がaiとなる木
      →存在すればPossible,しなければImpossible
    →1<=N<=100
    →出来ないパターンN=3の時1,1,1、N=3の時は1,2,2しか存在出来ない
      →各頂点iはあまり関係なし
      →一番aiが短い所により最大の距離も決まる
        →一番短い所は木の中心となる
          →最大の長さを取る頂点maは確定で二つ以上存在する
            →なければImpossible
          →maが2つ以上存在する時は確実に一つの中心を通っている
            →maが4つ以上の場合に二つの完全な中心が存在すると仮定すると、木なので、maの距離が伸びることになる
          →中心となるのはmaが偶数の場合二つ(どの枝も通る完全な中心は一つ)、奇数の場合一つ
            →完全な中心は一つと仮定して組み立てて良い
    →maの片方をまず配置する
      →次はma-1を一つ選ぶ
        →次はma-2を一つ選ぶ
          →中心oまで来たら、maが偶数の場合、oを選び、奇数の場合、o+1を選ぶ
            →maまで到達する
              →残りの頂点をai-1の場所に追加していく
                →完成すればPossible
    →maが奇数の場合、中心は二つ
    →maが偶数の場合、中心は一つ
      →このパターン以外はImpossible
    →あとは中心より上～maまでが2つ以上あり、中心未満が０個であればPossible
   
agc008_c Tetromino Tiling
  →7種類のテトリミノがある、
    →そのうちK個を組み合わせ縦2マス、横２Kマスの長方形を作ろうとしている。
      →縦横逆でも同じである
    →それぞれのミノが接する部分と偶奇を考える
      →すると数を減らせる
        →ミノは全て使う必要はない
          →T,S,Zは使うと長方形に出来ない？
            →I,O,L,Jのみで考えれば良い？
        →全パターン処理可能となる
          →I型が奇数の場合、J,Lがそれぞれ一つ必要になる
            →I,J,Lが3,2,2となっている場合、I,J,Lで3、I*2で2=5となる→×
              →I*2,j*2,L*2でとると6になる
              →I,j,L*2でも6となる
            →I,J,Lが3,3,2となっている場合、I,J,Lで3,I*2で2,J*2で7となる
              →I*2,j*2,L*2だと6の為上の場合はI,J,Lを取る方が正しい
            →可能な限りI,J,Lの組み合わせでとるのが正しい？      
              →I,J,Lを2個作るのはそれぞれを２個づつ作るのと同じ
                →I,J,Lを一つ作るか０個作るかで場合分けして終わり

agc014_c　Closed Rooms
  →魔法を１回使うと部屋をK回移動できる、また、K個の部屋を開く事が出来る
    →K個の部屋を開く事が出来るので、最初に移動できる範囲で外に一番近い所に移動出来れば良い？
    
agc014_b Unplanned Queries
  →木構造のデータに対してM個のクエリを流す
    →クエリはai,biとして頂点ai~bi上頂点の数字を1増やす
      →最終的に木の数字が全て偶数になっているかチェックする
  →2<=N<=100000,1<=M<=100000
    →共通の親が分かればそこからトップダウン的に処理できる
      →ダブリングしてみよう
    →親子関係があればそのまま処理出来る
      →木が存在するかどうかである、最初から木があるわけではないのでダブリング等は出来ない
    →クエリで偶数回出てきているかどうか？
      →例えば2,2で1 2,1 2の場合は真
      →例えば3,3で1 2,1 3,2 3である場合も真
        →正直Nで出てきていない頂点は考える必要がない
      →例えば4,4で1 2,2 3,3 4,1 4である場合も真
  →解説を見る
    →(ai,bi)の時ルートまで通ってからそれぞれのところまで行くという風に考えると(r,ai),(r,bi)と考えることが出来る
      →(r,ai),(r,bi)を見たときに(ai,bi)のLCMをPとすると(r,P)は２回通るため、(r,ai),(r,bi)としたときに全く同じ状態となる
        →木構造である場所から別の場所に行くときにルートを通るようにするという考え方はまた出てくる可能性がある
  
agc026_c String Coloring
  →2Nの小文字からなる文字列Sが与えられる
    →各文字を赤か青に塗り分ける
      →赤に塗った文字列を左から右、青に塗った文字列を右から左に読んだ文字列が同じ
        →これがいくつあるか
  →1<=N<=18であるため、全探索でも出来る
    →文字列は2*Nであるため、無理
  →32bit整数で表せないこともあるため、普通にカウントするのも無理とわかる
    →最初の文字を赤か青に固定して考える
      →最終的には×2になるためOK
        →文字もそれぞれ２つずつないとだめ
      →違う色の最初の文字は同じ文字になる
        →後ろから探して違う色の最初の文字を見つける
          →そこが違う色の最初の文字になるとは限らない
          →そこが違う色になるとは限らないが、それより右側の文字を反転したものはは違う色が全て持っている文字列にならないとならない
        →それぞれの文字がどの文字と反転しあうかを調べる？ 
          →abccbaであれば1,5の組み合わせ、2,4の組み合わせで行ける
            →1,2,3 1,2,4 1,3,5, 2,3,6 2,4,6 3,5,6がそれぞれ使える
          →abcbcaとなるとacbとcbaの組み合わせが作れる
            →1,3,4 3,4,6のみ
            →文字列が反転している状態であれば、組み合わせはかなり作れる 
          →abbccaだと組み合わせは出来ない
        →aaaaを考える
          →1,2 3,4
          →1,3 2,4
          →1,4 2,3
            →に分けられる
        →baaaabを考える
          →1,2,3 4,5,6
          →1,3,5 2,4,6
          →1,2,4 3,5,6
          →1,4,5 2,3,6
          →1,2,5 3,4,6
          →1,3,4 2,5,6
            →に分けられる
            →aaaaとの違いは開始地点を変えられないところ
        →bbaabbaaを考える
          →1,2,7,8 3,4,5,6
          →以上となる
        →同じ文字が連続しているところはそれぞれ入れ替わる事が出来る
          →baaaabを再度考える
            →1,2,3 だが、これは2,5 3,4を入れ替えることが出来る
            →1,2,5 は2,3 4,5を入れ替えることが出来る
              →しかし1,2,3の入れ替えで1,2,4 1,3,5は出ているため、掛け算するとアウトとなる
              →つまり別の考え方が必要
                →600点程度かつ青パフォ問題ではあるのでもっとシンプルに考える方法があるのではないか？
                  →見落としてる何かはないか？
                    →bbacacbbとなっている時に右側の先頭文字は変えられるか？
                      →1,2,4,5
                      →1,4,5,8で出来る
                        →これは対称になっていて同じ位置に存在する場合、入れ替えが可能ということを示す
                          →上の例では頭から取ると
                            →bbca,bbcaと並ぶ
                              →このbの位置は先頭か後ろへと入れ替わる事が出来る
                                →bcab,cabb
                                →では内部で同じような連続しているところがある場合はどうか
                                  →baaccaab
                                    →baac,baca,bcaaが取れる
                                  →挟んでいて同じ位置にある連続した文字は、挟んでいる文字を軸に位置を入れ替えることが出来る
                            →bbaabbaaはどうなるだろう
                              →bbaa,bbaaとなりaを挟んでいるが...  
                                →挟まれているaは片方にしか存在していない
                                  →bbaaaabbの場合は挟まれているaはどちらにも存在している
  →解説見た
    →やはり600点なのに上のような方法で解くような問題ではなかった
      →文字列を半分にし、文字列の組み合わせを全列挙する
        →そこでマッチングしてクリアである
          →やはりN<18くらいだと全列挙が基本的なアイデアであって、そのまま処理出来るように出来ている
                              
agc037_c Numbers on a Circle                            
  →１～Nの番号がついている、i番目の数はai、i番目の生成数がbiとなるようにしたい
    →1<=i<=Nなる整数iを一つ選ぶ
    →i-1,i,i+1番目の数をそれぞれa,b,cとしたとき、i番目の数をa+b+cに置き換える
      →操作が出来るか判定し、可能である場合は操作解消として考えられる最小の値を求める
  →1<=N<=2*10^5
  →1<=aiなのでiを操作するとき、2<=p増える
    →小さい所から処理していかないと、bにすることは出来ない
      →b1<b2として、b2を先行した場合、b1<a1+b2となるためNGとなる
        →なので小さい数から組み立てると考えてよい
    →効率的な数字の増やし方を求める
      →biはaiが持っている数字からしか組み立てることが出来ない
        →そのため、操作を繰り返すことによりどのような組み合わせになるのかを考える
          →入力例3の 5 6 5 でb2を何回か操作することを考えると 16 26 36 となる 5,5,6 5,5,5,5,6 5,5,5,5,5,5,6と言った風に組み合わせられている
            →5 6 5 2 をb2,b3と操作する 5 16 5 2,5 16 23 2 
            →5 6 5 2 をb3,b2と操作する 5 6 13 2,5 24 13 2
              →もちろん順番が変わると数字が変わる
    →整数系の問題である
      →AGCなのでひらめきで解ける系の問題だと思う
        →操作を行う回数がそこまで大きくならない
          →ai,ai+1を交互に操作するとすぐに数字が大きくなる
            →手続きさえわかればシミュレート可能？
              →手続きが難しい
            →一番数字がでかい所は前の一手は自分のところ-両隣となる
              →そこから逆にシミュレート出来る？
                →逆シミュレートで大丈夫だった
    
arc033_3 データ構造    
  →数の集合Sに対する以下のクエリを処理
    →1.Sに数Xを追加
    →2.Sに含まれる数のうちX番目に小さい数を答え、その数をSから削除
  →1<=Q<=200000
    →セグ木、平方分割、等で可能なように感じる
      →BITはどうだろう？
        →これも行けそうな気がする
          →いいプラクティスになりそうなので全て実装するのもありのように思う
          
      
      
    
            
    
