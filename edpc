C - Vacation
    https://atcoder.jp/contests/dp/tasks/dp_c
    夏休みn日のそれぞれについて、ai,bi,ciのいずれかの行動をする
        ２日連続で同じ活動は出来ない
            幸福度の最大化をする

F - LCS
    https://atcoder.jp/contests/dp/tasks/dp_f
    最長共通部分列を求める問題
        string dp[3010][3010];
        でよさそう
            MLEした
                しっかり復元を使用しよう
                    indexが入れ替わっててwa連発

G - Longest Path
    https://atcoder.jp/contests/dp/tasks/dp_g
    Gは有向グラフ
        xi~yiの最長パスは何か？
            閉路はないため、各頂点から最大のパスを返却していけば良い

H - Grid 1
    https://atcoder.jp/contests/dp/tasks/dp_h
    経路問題
        何通りの経路が存在するか
        右または下の２通りのみ

I - Coins
    https://atcoder.jp/contests/dp/tasks/dp_i
    nを奇数とする
    1,2,3,4,...,nと番号が振られている
    コインiを投げると確率piで表が出る
    表の個数が裏の個数を上回る確率を求めよ
        dp[n]とするdp[1]はpi,dp[0]=1-pi
        ということでこれも下から上にdp可能

K - Stones
    https://atcoder.jp/contests/dp/tasks/dp_k
    ちょうどx個の石を取り続けていく
    1<=k<=100000
    1<=ai<=K
    2,4
    2,3としたとき
     2を見ると
     0=f,1=f,2=t,3=t,4=f,5=f,6=tとなっている
     ここに4を組み合わせると
     0=f,1=f,2=t,3=t,4=t,5=t,6=fとなっていく
        dp[k]がtであればfirst,fであればsecond
            kに対してaiを全て試すのが正解であった、
                なんといっても順番を見るわけなので

L - Deque
    https://atcoder.jp/contests/dp/tasks/dp_l
    往年のゲームdp
        実装練習

M - Candies
    https://atcoder.jp/contests/dp/tasks/dp_m
    ナップサック感ある
        通り数なのでどんどん足しこんでいくタイプ
            aiとkの関係を考えると愚直解ではTLE
        個数制限ナップサックとも言える気がする
            あるpを達成出来る方法は
                累積を使える？
                    使えそう
                        使えた
        今回は20分で行けたので前回よりも大分成長したと言える
            
N - Slimes
    https://atcoder.jp/contests/dp/tasks/dp_n
    隣り合う2匹のスライムを選び、1匹になるまで合体させる
        スライムの大きさはx+yになり、x+yのコストを支払う
            コストの最小を求めよ
                1<=n<=400
                    最小を見ながらくっつけていくだけ

O - Matching
    https://atcoder.jp/contests/dp/tasks/dp_o
    n組のペアを作りたい、a(i,j)が0の場合はダメ
        ペアを作る方法は何通りあるか？
            bitで見ていく
                1<<21
                    埋められるbitを行毎に見て埋めて行く
                bitの立っている数が少ない順番で処理するのが一番速い

Q - Flowers
    https://atcoder.jp/contests/dp/tasks/dp_q
    花の高さはhi、美しさはai
        何本か抜き去る事で単調増加となる
            残りの花の美しさの総和を求めよ
    1<=n<=2*10^5
        高さは全て相異なる
    1<=ai<=10^9
        BITを使用出来るか？
            単調増加が管理出来ない
        高さ1を考えた時
            単調増加1の美しさはa1になる
        高さ2を考えた時
            左に高さ1がある場合はa2+a1となり
            ない場合はa2となる
                BITで処理するのを高さの順にして、位置に対する最大値に対して自分の値を足したもので自分の位置を更新していく
                    どれがmaxかを常に更新していけば良い
                前回はセグ木でやってた

R - Walk   
    https://atcoder.jp/contests/dp/tasks/dp_r
    単純有向グラフ
    1<=n<=50
    1<=k<=10^18
        ai,j
        長さkの有向パスは何通り？
            これは行列べき乗
                蟻本の類題そのまま
                    一応ACしておこう

S - Digit Sum
    https://atcoder.jp/contests/dp/tasks/dp_s
    これは桁dp

T - Permutation
    https://atcoder.jp/contests/dp/tasks/dp_t
    1<=n<=3000
    sは長さn-1の文字列
        <と>からなる
            <の場合pi<p(i+1)
            >の場合pi>p(i+1)
    1~nが一度ずつ登場する
    このような順列は何通りあるか求めよ
        なんどか遭遇している種類の問題
            足しこんでいくタイプのやりかたではいけなかったような気がする
                1~nが一度ずつ登場するという条件が厳しい
    bitも使えない
        同じ数字を使わないようにするのが難しい
        制約の1<=n<=3000を上手く使いたい
            o(n^2)までは許容されている
                それぞれのpi,p(i+1)についてはどれだけの量があるか考えられる
        pi,p(i+1),p(i+2),p(i+3)についてはどうかと考えたが、確かにここまでは可能だ
        ここからpi,p(i+1),p(i+2),p(i+3),p(i+4),p(i+5),p(i+6),p(i+7)
            になるとcombine出来ない
                残りの数のうち何番目に大きいものを取るかという風に置き換えると常に残っている数字の中で考えられる
                    もう一度同じ数字を使っては行けない→残っている数字が減っていく
                        という置き換え

U - Grouping
    https://atcoder.jp/contests/dp/tasks/dp_u
    以前は自力で解いたような気がするが。。。
        bitdpなような気もするが
            bit同士の組み合わせで行けなくはないと思われる
                被らないbitを組み合わせた時の最大値で考える
                    xorで処理していけば良い
                問題は1bitで考えるわけではないため、そこで計算量が大きくなる
        全てのbitの組み合わせを、それぞれ一つのグループに所属しているものとして作る
            ある組み合わせとそれを反転させた状態のbitには値が含まれている
                その論理和は全てのbitが含まれている状態になるため、二つのbitの状態の和と全てのbitが含まれている状態の値どちらが大きいのか比較出来る
                    1<<16であるため、全ての状態を更新出来ないのが厳しい
                反転したbitの組み合わせを列挙して処理するということが出来る事を忘れていた
                    前回やった時はこれが出てきた(蟻本に書いてあったしbit操作の記憶もまだ残っていた)
                        半年経っているということは半年使っていないということなので忘れるのも致し方ないが。。。
                                悔しいものである、まぁ解けなかった時の方が記憶に残りやすいので、一つ得したと考えよう

V - Subtree
    https://atcoder.jp/contests/dp/tasks/dp_v
    どの黒い頂点から黒い頂点へも黒い頂点のみを通って到達出来るようにする
    頂点vが黒であるような頂点の色の組み合わせは何通りか？
        どの黒い頂点から黒い頂点にもなので、黒い頂点は連続した頂点である
    1<=n<=10^5
    2<=m<=10^9
    各頂点毎に出す必要があり、難しさはそこにある
        累積積を使用出来ると考えたが、無理
            ある頂点において、複数方向に伸びる辺が存在するとする
                それぞれの辺の場合の数を掛け合わせたものがその頂点において答えとなるわけだが
                    辺の数が多い頂点が存在する場合、周辺の頂点から何度も計算の依頼をされる
                        ここである頂点aから別の頂点bに依頼をするとき
                            bからはa方向を除いた場合の数を返せば良いのだが、積であるため、bから伸びる辺全体の積からaへの場合の数を使って除算を行い減らす必要がある
                                しかしmodが10^9+7ではなく任意の入力であるため逆元が使用出来ない
                                    このやりかたは無効化された、大きい素数であればmod p計算で可能である
        全体の場合の数からその頂点が白である数を引く？
            これであれば引き算で可能
                やはりウニで負けそうな気はするが
                    負ける
        思い出した。外側から処理していくというやり方をCheatに書いていた
            一番外側を処理する場合、自分の頂点を使用しないという条件で全体の場合の数から引く事が出来る
                全体の場合の数はいくつだろうか
        一か所だけ除いて計算するというのは、累積で出来るということを全く忘れてしまっていた。
            導線がないとこんなにも思いつく能力が下がるのだろうか
        事前計算で任意の頂点から黒になるパターンをまず全て取る
            他の頂点についてもその先が全て黒になるパターンをまず全て取る
        第二段階で、ある頂点vからある頂点tに向かう時他の頂点達の累積積をtに送る事により、tで全てのパターンを得る事が出来る

W - Intervals
    https://atcoder.jp/contests/dp/tasks/dp_w
    0と1からなる文字列
        liからri文字までに1が一つ以上含まれるならばaiを加算する
            文字列のスコアの最大値を求めよ
            5 3
            1 3 10
            2 4 -10
            3 5 10
        aiが-になる箇所があるというところで難易度が上がっている
            ある箇所に1がある事でスコアがどれだけ変動するかを考える
                しかしその総和にならないのも難しい所
                    線形に考えるならば、1がある事でスコアにどれだけ変動があるか前計算
                        左から右に１を使用した場合、aiの使用済みフラグを考えるようなやりかた
                    これはセグ木でやった方が良さそう
                        bitでも行ける？
                            先頭から後ろだと最大増加を逃す可能性がある
                                増加量でソートして処理した方が良さそう
                                    dpっぽくない気もする
        まず両端の位置だけを調べれば良いのは分かる
        全て+になる位置は1にすれば良いのも分かる
        全て-になる位置は0にすれば良いのも分かる
        問題は+と-が入っている場所
            ある場所を1にした時、その場所をまたいでいるaiを高速に取り除ければ話は速いが
                両端の位置li-1とri+1も調べる必要がある
                    例えば 10 20 10
                           7 12  -5
                           15 22 -10
                    のような時に13,14のみが10を取れる
        dpで処理するにはどうしたら良いのか？    
            セグ木で対象の位置の数字は求められはするが
                左から処理をする時に、そこを1にした場合、次はどこまで飛んでいくのか分かればそこに移動させてしまえるわけである
                    そこの一点まで来た時の最大スコアを保持出来る
                        例えば
                            1 10
                            2 11
                            3 12
                            4 13
                            5 15
                        となっている時に1に点の次に点数に関わる場所は2
                        2の次は3,3の次は4,4の次は5で、5の次は16である
                            1 10 -1
                            2 11 1
                        となっている時
                            1を1にすると-1になるこの-1を2に送る
                            2は0点を最低点とする、-1は0を下回る為拒否する
                            このように処理するとlからrに対して最高点を更新していく事が出来るのではないだろうか？
                        次の場所の探し方
                            次に大きいliまで送れば良い？
                                ある場所と次に大きいliにおいて共通しているaiがすぐに求められない限りはこの方向は難しい
                                    例えばある地点において3つの範囲に含まれていた場合
                                        次に大きいliでは上の3つの範囲のうち1つが共通しているとすると
                                            増加量はliのaiになるのだが、結局その地点での最大値においてliだけ増やせば良いのか単純に求められない
                                                ある２点において、共通しているのはいくつなのかを求められればその差分も含めて最大値として更新する事が出来る
                                                    いくつ共通しているのかを高速で求める方法が必要である
                                                        下手すると大量の計算が必要であるが。。。
                                    この考え方であれば左から右にいくに従い数字は増加していく
                                        前の地点から後ろの限定された地点の値を更新していくというのはdpって感じではあるのでこの方向性は間違ってはいなさそうだが。。。
                                            よく考えたら次の左の所までなので、あるi<jかつi<ljにおいてxi<lk<ljなるkは存在しない前提で作る為どれだけが共通した値かというのはすぐに求められる
                                                共通部分がある場合共通部分を含む(そのiを1とする場合)か共通部分を含まない(そのiを0とする場合)でdp[200010][2]というdpテーブルが作れる
                                                    基本的にはあるlの２点間の最大はどこで取れるのかという問題に帰着出来る
                                                        セグ木も不要である
                                                            実装してみよう
                                                                だめだ、結局li,ljを考える時lp<liなるlpの部分も含めて考えないと行けない
                                                                    一個先までであれば共通部分は単純である
                                                                        一個前の部分が1であるならば共通部分は使用されている
                                                                            2個前の部分が1であるならば共通部分はいくつ使用されている？
                                                                        1個前ではなくさらに前の部分の値を保持する場合、どれだけの共通部分が残っているか？
                                                                            それはrで減る分をその共通部分から減らしていくという手続きで可能だが
                                                                                関連するものを保持するのが難しい予感がしている？
                                                                            その最大値に関わる共通部分は常に保持出来るはずである
                                                                                配列で管理可能である
                                                                                    最大値配列と作業中配列の用意が可能
                                                                                        作業中配列の生成コストが高いか？
                                                                                            これは常に最新状態で更新されていくため、問題ないだろう
                                                                                最大値状態配列
                                                                                next最大値状態配列
                                                                                現状配列
                                                                                の3つで保持、next最大値状態配列はtemp領域であり、値が増える所があるのであれば。。。
                            結局
                                1 10 10
                                1 5 -3
                                2 4 -1
                                3 3 -1
                                のような状態に対応出来ない
                                    最初の7を次の2の場所に最大値として入れる
                                        実際には6で最大値10を取るわけだが、既に1で7を取ってしまっている
                                            上のやり方でこれに対応出来るか？
                                                








                        




