B - Robot Arms
  →共通部分をなくしたい
    →最適スケジューリング
      →どっちにも動かせるようにしたい
        
C - Subarray Sum
  →n,k,sが与えられる
    →1<=10^9以下の整数からなる長さNの整数A1,a2,,,anであって
      →1<=l<=r<=nを満たす整数(l,r)であって、al+a(l+1),,+ar=sを満たすものはちょうどk個ある
        →どれか一つを出力すればよい系
      →kがn以下であるためsをk個入れたらいいのではないか？
      
D - Swap and Flip
  →n枚のカード
  →1<=n<=18 bit?
    →ai,biが両面に書かれている
    →1<=ai,bi<=50
    →操作をして単調増加となるようにする
      →可能である場合は必要な操作の回数の最小値を求める
      →操作はiとi+1のカードを入れ替え更にこれら2枚のカードを裏返す
    →隣り合っているカード
      →同じところを二回操作するか？
        →する可能性はある
          →10 5 1
          →10 5 1
            →となっているとき1 2 1と操作するか、2 1 2と操作するかの二種類であるため
              →となるとbitdpで状態を管理しながら動かすという方法では対応できない
     →数字は波を打つように動く
      →どこにでも行けるわけではなく行ける場所は決まっている
        →それで表になる場所も決まっている
          →奇数番目で表の数字は奇数番目で表にしかなれない
          →偶数番目で表の数字は偶数番目で表にしかなれない
          →奇数番目で裏の数字は偶数番目で表になれる
          →偶数番目で裏の数字は奇数番目で表になれる
            →前から決めていくとして
              →1番目を決める時
                →i番目を持ってくる場合1~i-1は全て裏返る
                  →基本的には後ろから前に持ってくる回数を問われる
                    →となるとどれを前に持ってくるかをbitで管理できる気がする
                      →2^18*324‬
                        →8400万だが、内部の計算は次に使用する数字が分かっているのでo(n)で可能ではないだろうか
                          →違う、bitが立ってる場所について、どれが一番前にくるか等は結局全探索になってしまう
        →後ろから前というのは方向を定めるという点について良いとは思う
          →前から後ろも同じではある
            →順番が関係あるか
              →最初の数字を決める時、最低でも一番最初で表になっている数字より小さい数字をもってこなければならない
                →a0>a1となっている時
        →一番でかいのを常に持っておく
          →今の数字がその数字より小さい場合、その数字より大きい数字を探す
            →ない場合一つ前に戻りai>aj
        →組み合わせを取る場合 
          →18c2*16c2*14c2*12c2*10c2*8c2*6c2*4c2*2*2となる
            →順番は関係ないため9!
              →しかし全探索は不可能
        →前から考える場合は、対象の数字についてそれより小さいのを持ってきた場合を考える必要がある
          →それより前の数字との比較を考えると大きいのを持ってくる場合を考える必要もある
            →違う
        →ある数字を対象の場所に持ってくるという手順について基本的には後ろから前と考えていたが前から後ろもあり得るのではないか        
          
                       
    
