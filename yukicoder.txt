No.917 Make One With GCD
  →N個の要素からなる数列A
    →1<=N<=50
    →1<=Ai<=10^8
    →部分列を考える
      →最大公約数が1となるAの部分列の総数を求める
        →部分列として取る必要がある
          →DP?
            →最大公約数の数を保存していく
              →10^8であるため、mapでやる
              
No.939 and or
  →https://yukicoder.me/problems/no/939
    →x<=yかつx and y = A かつ x or y = Bを満たすものの個数を求める
      →0<=A,B<2^31
        →bit毎に考えそう
          →Aのbitはx,yともに全て立っている必要がある
          →Bのbitの組み合わせだけ考えれば良い
            →Aで立っているがBで立っていない場合は0個
            →Bで立っているがAで立っていないbitはxで1,yで1の2パターンある
              →x<=yなので先頭bitのみy固定になるため、出た答えを2で割る
              
No.727 仲介人moko
  →https://yukicoder.me/problems/no/727
  →品物を売ったり買ったり
    →品物の取引の流れの組み合わせの数を10^9+7で割った余りで求める
      →1<=N<=10^6
      →2N人のうち半数が売りたい人、半数が買いたい人
        →DPで行ける？
          →数字の選び方が増えるため難しそう
          →商品がある時にしか買う人は来ない
            →狼と羊の問題によく似ている
              →最初は売る人であり最後は買う人
          →どちらにしろ1000000*1000000のdpテーブルは作れない
      →売りたい人、買いたい人は区別される
        →各パターンに同じ数が掛けられるため問題なし
      →2000000C1000000のうちいくつが削られるのか
        →この考え方も難しい
          →先頭と最後は固定なので(2n-2)C(n-1)となる
        →ダメなパターンは各iで出すことが出来る
          →時間の流れが右から左と考える時 i=1to2N
            →iにおいて品物がない状態で買い物に来るパターンは
              →i-1C(i/2)となる
                →i-1において売られた数x==買われた数yとなるときiは買うものがない状態となる
                  →i+1以降の全てのパターンがダメとなる
                    →i-1まででダメなパターンが現れることがあるため、それを排除出来ないとこの計算は使えない
                      →iの組み合わせからi-1まで出た組み合わせを引いてやる
                        →するとi-1までで正当な数が出る？
                          →出ない(xi<yi)となる数も含まれてしまうため
                →ある地点でダメになる時それよりまえの地点でダメな時を引いて求めるとすると
                  →i-1の地点までの組み合わせ数を決められないためダメである
            →完全マッチングとして考える
              →2N個の中からある二つをマッチさせると残りは(2N-2)
                →2N-2から二つマッチさせると残りは2N-4
                  →といったように選ぶ組み合わせの数である
                    →先頭から選んでいっているのと同じ数え方になる
                      →これにN!を掛ければ終わり
                        →やり直す問題に入れておく

No.595 登山
  →https://yukicoder.me/problems/no/595   
  →N個の地点が並んでいて地点iの標高はHi
    →地点１からスタート
      →全ての地点に一度訪問したい
        →隣接する地点に移動、i→jに移動する時エネルギーmax(0,Hj-Hi)を消費
        →ワープして好きな地点に移動する、ワープ一回につきエネルギーPを消費
    →最小エネルギーを求める
  →2<=N<=200000
  →0<=P<=10^9
  →0<=Hi<=10^9
  →右からと左からでそれぞれ累積する
    →ワープは好きなところに出来る
      →単調減少している場所はエネルギーを0に出来る
        →x1 < x2 > x3となっている場所はどっちから来る方が得かを考える
          →範囲と範囲を比較しようにもN^2かかる
            →後ろにも前にも移動出来るためdpではない
              →ワープする順番は関係ないため順序は考えなくてよい
    →隣に移動する場合でもP<Hj-Hiである場合はワープした方がよい
      →どこまでワープした方がよいのかを考える
        →ワープポイントは決められる
          →1回以上訪問であるため、ワープポイントは何度でも使える
            →基本的には一度しか訪問しない
            →ワープポイントの左と右はコスト0で到達できる
          →単調増加と単調減少がPを超えるところはコストをPに出来る
            →Pを越えないところは普通に移動した方がよい
              →累積をするが単調増加のみの累積を行う
                →そうすることでワープした時にどちらに降りた方がよいかが求められる
                →登りを使用するところはそのままコストに加算する
            →コストの少ない方を足すといった考え方では不十分である
              →ワープが使用されているかどうかを見る必要がある
                →s1ワープポイントを使用する箇所があるかどうか確認
                  →左から来ても右から来てもコストがPを越えている
                    →しかしこれだと細かく上下する場合に見つからないことになる
                      →各地点にワープする場合で考える？
                      →区間で考える？
                        →左から一番右への累積と右端にワープして左端まで行く累積を取っておく
                          →これの小さい方がresultのmax
                        →端から端で処理しない限り区間が出来る
                          →区間が出来るとワープは二度行われることになる
                            →一番右を含む場合は一度だけである
                          →一番左の区間のコストを求める
                            →左から今いるのコストを累積=a
                            →今いる地点から右のコスト+ワープ料*2を累積=b
                              →a>bになったタイミングでワープ確定
                                →次にa<=bとなる場所まででa-bが一番大きい所が区間の境目
                                  →この方法でとるとTLEになる
                                    →ただ最初の区間を取る方法としては良さそう
                          →一番左が下りの場合は下りきったところをスタート地点とする
  →解説によるとDPで処理するようである
    →時間を空けて再度確認しよう

No.948 Bomb vs Dush 
  →https://yukicoder.me/problems/no/948
  →(a(t)-Rcost)^2+(b(t)-Rsint)^2<=r^2
    →(a(t),b(t))の範囲の広がり方を見る問題である
      →t=0から始まる
        →(0,0)から(100^100^100,100^100^100)に到達出来なくなるt=t'を出力する
        →また(a(t),b(t))が埋めた領域の面積を求める
   →a(t),b(t)はそのまま使用できるRは最大100
    →値の移り変わりを確認するのが良さそうだ
      →r^2なのでmaxは10000
        →a(t),b(t)は負の数の扱うのか？
          →となると0,0を囲むようにしないといけないということである
            →式を見ると0,0にはたどり着けないような気もする
              →r^2を超える
            →tによってはcos,sinが+になることもある
              →Rcost^2+Rsint^2を軸に考えると
                →線形に考えられそうだ
                →Rcost^2+Rsint^2-v<=r2
                  →となる最大のvを取ってこれをa(t),b(t)に展開する？
  →解説見た、あとで学習する
    →https://yukicoder.me/problems/no/948/editorial
                    
No.466 ジオラマ
  →https://yukicoder.me/problems/no/466
  →1<=a<=10^4
  →1<=b<=10^4
  →0<=c<=min(a,b)
  →0<=d<=10^5
  →整数a,b,c,dが与えられる
    →aが0からのみ到達可能な場所
    →bが1からのみ到達可能な場所
    →cがa,bから到達可能な場所
    →dが辺の数
  →有向グラフを構築せよ
    →村の数nと水路の本数mを出力
    →ai biはai→biという辺を現す
  →満たす組が存在しない場合-1を出力する
    →まず-1になるパターンを考える
      →a+b-2+(c>0?c+1:0)+>dの場合-1となる
      →dが大きすぎる場合もout
        →aはa同士であれば辺が作れる
        →bはb同士であれば辺が作れる
        →cはc同士であれば辺が作れる
        →a→cは辺が作れる
        →b→cは辺が作れる
          →これは計算するよりも実際に辺を作りながら処理するほうが良さそう
   →まず最小のグラフを構築する
    →0からa-1個の頂点に対して辺を張る
    →1からb-1個の頂点に対して辺を張る
      →0からcの一つの頂点に辺を張る
      →0からcの一つの頂点に辺を張る
        →辺を張られたcの頂点からc-1に対して辺を張る
          →これで最小のグラフが作られた
   →余った辺はa,b,cの順で処理する
    

No.1 道のショートカット 
  →https://yukicoder.me/problems/no/1
  →N個の町があり、道は町Siから町Tiに行くのにYiのコストがかかり、Miの単位時間がかかる
  →1からNまで移動したい
    →C円持っている
      →一番早く着く道を選べた時合計の単位時間は何か
        →到達出来ない場合-1
  →2<=N<=50
  →1<=C<=300
  →1<=V<=1500
    →制約は小さい
    →各町においてコストに対する時間を保持する
      →各町におけるコストを考えた時
        →c1<c2でt1<=t2である場合はc2を考える必要がない
          →c1>c2でt1>t2である場合、速く到着出来る可能性があるため、処理する
        →特殊なダイクストラを実装する

No.2 素因数ゲーム
  →https://yukicoder.me/problems/no/2
  →2以上の自然数N
    →Nに対してNの素因数のどれかで割りその商になる数を渡す
      →同じ数であれば割り切れる限り何回も割って良い
        →渡された数が1になったプレイヤーが負け
  →grunday数に押し込める？
    →取れる数が平等ではない
      →山を素因数毎に分ければnimにすることが出来る
        →grunday数
      
No.6 使いものにならないハッシュ
  →https://yukicoder.me/problems/no/6
  →[k,n]の範囲でハッシュが衝突しない最大の長さを持っている連続した素数列の一番大きい先頭の数字を出力する
    →素数列とハッシュ値の前計算はさほどかからない
      →数字を管理しながらループするだけ
    →少しややこしかった
      →範囲の最初の数が再び出てくるところではなく、重複していない数字の羅列であるので
        →1,2,3,4,2と来た時に1,2,3,4が重複なしの列として使用可能である
          →queueで管理する
        
No.9 モンスターのレベル上げ
  →https://yukicoder.me/problems/no/9
  →集合A,Bに分けられる
    →Aの要素aはBの要素bに対して以下のように処理可能
      →floor(b/2)をaに加算しbを集合Bから取り除く
    →Bの要素は時計回りに並んでいて上の操作を時計回りの順番に行う
    →Aは一番数字が低いものから処理をする
      →それぞれのaに対して上の処理が行われるが、その回数の最大が一番低くなるような最初bの選び方をしたとき最大のaの回数を求める
  →1<=N<=1500
  →bをどこから初めてもN回処理される
  →bの選び方はN
    →O(N^2)なので十分間に合う
      →priority_queue<pii>で処理する
      
No.12 限定された素数
  →https://yukicoder.me/problems/no/12
  →'0'から'9'までの数が重複せずにN個与えられる
    →1<=K<=L<=5000000
    →K<=Lの範囲から素数のみ全て取り出す
      →全ての素数について使われている数字を調べる
        →この数字と最初に与えられた数字を等しくしたい
      →L-Kの最大値を求めよ
        →なければ-1
  →5000000までの素数を出す
    →使われている数字を出す
      →5000000*10の配列で良い
        →使われている数字の判定をしながらしゃくとりする
        
No.13 囲みたい！
  →https://yukicoder.me/problems/no/13
  →w*hで構成されるフィールド
    →囲みが出来ればok
      →上下左右に同じ数字を辿れる
        →やるだけ
  
No.17 2つの地点に泊まりたい
  →https://yukicoder.me/problems/no/17
  →N個の頂点
  →M個の辺
    →滞在コストがある
      →0からN-1に辿りつまでに0とN-1以外の異なる2つの頂点に滞在する必要がある
        →N-1に行くまでになので0→N-1→o→o2→N-1みたいな移動は出来ない
          →0→N-1の辺は削除してよい
            →出来るようだ
    →N-1までで辺の長さが3である場合も考える必要はない
      →1<=N<=50
        →滞在の条件が少しめんどくさい
          →移動コスト、滞在コストpllでダイクストラ
    →同じところは2度通ってもよい、しかし同じところは2度滞在してはいけない
      →という条件だ
        →この場合は50c2で滞在する場所を決め打ちして滞在コストを決めてダイクストラでやるしかなさそうだ
    →2か所滞在すると決めた時に道順は
      →0→s1→s2→n-1か0→s2→s1→n-1である
        →となるとワーシャルフロイドだ
  
No.20 砂漠のオアシス
  →https://yukicoder.me/problems/no/20
  →n*n
  →(ox,oy)に行くとxを2倍に出来る
  →隣接マスに移動可能
    →移動先のl分xを減らす
      →0にならないように移動する
  →(n,n)に到達可能か判定
    →1<=n<=200
    →1<=x<=500
      →最短経路で進む
        →n,nまで到達するのにコストがxを越えないか
        →oにたどり着いた時にコストがxを越えないか
          →oで体力を2倍に出来るのは1度だけ
            →1から最短距離を取り、n,nに到達できるならok
            →oでxを越えていた場合no
            →oでv-cを2倍にし、n,nまでの最短距離を出す
            →到達できるならok

No.23 技の選択
  →https://yukicoder.me/problems/no/23
  →期待値の問題である
    →1回の攻撃の期待値は
      →aとdをそれぞれ選択する確率を1/2とすると
        →dを選択した時に2/3でdとなる
    →1<=h,a,d<=10000
      →全てaで倒す
      →1度dを使用する
      →2度dを使用する。。。。
        →この計算をして最小の期待値を求める
          →dを使用する時の一回の期待値は2/3*dである
    →dの使用回数は3/2となる
      →確率pで起こる事象がx回起こる場合の試行の期待値はx/pとなる
          
No.25 有限小数
  →https://yukicoder.me/problems/no/25
  →n,mが与えられる、n/mが有限小数で表されるか判定する
    →0でない一番小さい桁の数字を出力する
      →普通に処理して出し切れるか
        →2度同じ余りが登場したら循環小数である
          →long long でも桁あふれを起こす
            →...C++で出来るのか謎
          →有限小数になる分母は2と5の倍数であった
            →gcdで分母と分子を割った後に分母に2,5以外の数があると循環小数となる
              →あとは2もしくは5が分子に足りないため割り切れない状態になるため、
              →分母の2か5の多い方と同じ数だけ分子に10を追加していくイメージとなる
                →分子の下1桁だけで考えればよさそう
                  →3桁程度で考えてAC

No.27 板の準備
  →https://yukicoder.me/problems/no/27
  →v0,v1,v2,v3の4つの数字をa,b,cの3つの数字の和として表す
    →a,b,cはそれぞれ何度でも使用可能
      →a,b,cの使用回数を最小にしたい
    →1<=v0,v1,v2,v3<=30
      →全ての数字が異なる場合は最大公約数が必要
        →いずれか2つの数字が同じであれば4つ以下で済む
          →最大公約数を取った時にmin{l=b/gcd(a,b)}が一番小さな数となる
            →2,3,7,15の時が反例
    →これはdpではないだろうか 
      →2,4,8,16で考えると2,4,16,4,4の5枚で済む
      →2,3,5,7で考えると2,3,2,3,7の5枚
        →全部違う場合は最低5枚必要である
          →2,11,17,29で考えると
            →2があるおかげで2,11,2,2,2,11,29で済む
              →5,11,17,29で考えると
                →どの間も偶数であるため、1が必要となっている
                  →29は決め打ちしたとして
                    →5,5,5,1,5,5,5,1,1,29で10
     →a,b,cを全探索した方が良さそうだ
      →30*30*30なので余裕
        →数字3つ決めてdpする方が楽である
          
No.30 たこやき工場
  →https://yukicoder.me/problems/no/30
  →2<=N<=100
  →1<=M<=1500
  →p,q,rはpがq個あるとrを一つ作れるということ
    →nは100程度なので、普通に処理可能
      →これは有向グラフとすることが出来る
        →1~n-1は全て必要であるので、全て足すことにより処理出来る
          →循環がありうる
            →となると厄介である
              →capではないのでフローは流せなさそう
      →どこからくれば最短かを問う問題ではないため、厄介
        →むしろ各素材を作るためのコスト考える方が正しい気がする
          →nだけは全て必要であるが、他はそんなことがないため
            →nも最短で作ればよいので上のは間違い
              →全て最短で作れるようにするのが良い
          →それであればダイクストラで処理出来る
        →循環している場合、始点が定まらないため違う
          →各頂点に一方的に進むことの出来る始点0を作る
        →1.製品iの製造方法が複数書かれている場合は、それらすべての材料が必要です。
        →2.Riの材料(および材料の材料、…)としてRi自身を必要とすることはありません。
          →とのことなので、逆辺を張った方が良さそう
          →2.より循環もしていない
            →お互いに辺が張られているということは制約上ない
          →逆辺を張り、辺がないものを見る
            →辺がないものに張られている辺が次の頂点
              →と思ったが、一概にもそういえない
                →まだ処理されていない辺にたどり着く事がある
                  →そのような頂点はレベルを一つ上げて次の段階で処理するようにする
                  →各頂点についていくつ必要かなので結局nからスタートした方が良さそうである
                  →ACしたがなかなか難問であった
                    →対象の頂点から伸びている辺が全て処理されたら
                      →その頂点に伸びている辺をqueueに入れて処理を進めるといった方法
                        →コーナーケースとしてnからさらに辺が伸びている場合（nから伸びている辺はそもそも集合に入れない)
                        →nに辺を伸ばしているところがほかにも辺を伸ばしている等(辺が伸びていない場所は全てスタート地点とする
        
No.33 アメーバがたくさん
  →https://yukicoder.me/problems/no/33
  →t秒後にアメーバが何匹になっているか
    →全てのアメーバは1秒後に分裂
      →分裂したらx-d,x,x+dに位置する
        →同じところにいるアメーバはくっつく
  →1<=t<=10^9
    →1秒後さえわかれば後は計算可能
      →あるxについて、取りうる点の位置は
        →x-t*d~x+t*dの間で間隔dに全て存在する事になる
          →重なりを見る必要がある
            →ai,ajについてお互いが間隔d上に存在しているか判定
              →判定している場合、同じグループとなる
                →同じグループでソートする
                  →範囲が重複していたら何体分重複しているか計算する
                    →ai<ajである場合
                      →(ai+t*d-(aj-t*d))/d+1が重複している匹数
            →最初に全てで何匹になるか計算して上の重複を消していく
              
No.34 砂漠の行商人
  →https://yukicoder.me/problems/no/34
  →sからtまで到達するための最短距離を出す
    →体力という概念があり、マスに書かれた数分減る
      →0にならないように移動する
        →あるマスに到達した時の残り体力での最短距離を保持しておく
          →体力の最大は10000、dp[100][100][10000]で保持すれば問題ない
   →5秒制限だがTLEとなった
    →sからtまでの最長距離で最大消費体力は実際のところ
      →(100+100)*9=1800程度である
        →体力が1800を超えている場合
          →gx-sy+(gx-sy)で最短距離が出る
    →体力に関して色々と制限を加えることによって短縮できた
      
No.37 遊園地のアトラクション
  https://yukicoder.me/problems/no/37
  Tを上限とし、ciが重さ、viが価値のナップサック
    viは使用するとfloor(vi/2)となる
  1<=T<=10000
  1<=n<=15
  1<=ci<=100,1<=vi<=500
    個数に制限はないが価値は制限があるナップサックともいえる
      各価値が0になるまで繰り返すのが正しい気がする
        viが最大500程度であれば9回
          nt*max{logvi}=10000*15*9
            計算量は余裕である
              
No.38 赤青白ブロック
  https://yukicoder.me/problems/no/38
  a,b,cが10個ずつランダムに並んでいる
  kr,kbが与えられる
  aのkr右とkr左にはaがあってはいけない
  bのkb右とkb左にはbがあってはいけない
  cはせいげんなし
    aかbを抜き出すという操作が出来る
      上の条件を満たす最大の長さを求めよ
  足せないので削るのを考えるだけではあるが
    cは考える必要がないため、実際は1<<20で済むとも考えられる
      1<<20*30程度である
        全探索可能
  
No.41 貯金箱の溜息（EASY）
  https://yukicoder.me/problems/no/41
  1円と6つの数字のゾロ目からなる硬貨の10種類が使われている
  どの硬貨も10^20枚以上持っている
    m円の買い物がしたい
      m円を作れるパターン数を10^9+9で割った余りとして求めよ
  1<=t<=10000
  1<=mi<=10^10
    mimod111111に関しては1円でしか払われない
      あとはmiを111111で割った数に対してdpをすればいいだけである
        10^10を111111で割ると4桁程度になるため、個数無制限dpで処理出来る
        
No.50 おもちゃ箱
  https://yukicoder.me/problems/no/50
  n個の要素がm個の要素に収まるかを計算する問題
    miはnの任意の要素の和以上であれば収まると判定される
  nの要素の大きなものから入れるmを決めていく
    niが入ったらmkはni分だけ小さくなると考えて
      priority_queueで処理出来る
        そのような貪欲で処理するのが正解だろうか
          n={5,3,1} m={9,3,1}とすると
            貪欲で処理すると9の次に4が処理され、その次に3に1が入る
              正解は9ひとつで済むはず
                ただ、一番nはmの一番大きいのに入れればいいというのは間違いない
  1<=N<=10
  1<=M<=10
  であった、これなら6乗程度でも許容されてしまう
    好きに処理したら良い
      全パターンは10^10程度になるため難しい
    以下の時にwaとなる、この時は2である
      3
      4 3 2
      3
      5 4 3
    nの全パターンをmにはめてやれば良さそうである
      
No.53 悪の漸化式
  https://yukicoder.me/problems/no/53
  漸化式で定義される数列の第N項を求めるプログラムを書く
    A0=4,A1=3,4Ak=19Ak-1-12Ak-2,k>=2
    4Ak=19Ak-1-12Ak-2
      Ak=(19A(k-1)-12A(k-2))/4
        Nは100程度
          誤差が気になる
      4Ak=19A(k-1)-12A(k-2)
         =19((19A(k-2)-12A(k-3))/4)-12((19A(k-3)-12A(k-4))/4)
         =19(19A(k-2)-12A(k-3))-12(19A(k-3)-12A(k-4))/4
      ∴
      4*4Ak=19(19A(k-2)-12A(k-3))-12(19A(k-3)-12A(k-4))
        4で割るのは最後で良さそうである
          それとも4で割り切れる値になっている場合は4で割るか
      A(k-2)とA(k-1)では割られる回数が異なるため、最後に割るのは難しい
        やりながら処理するしかないが、計算誤差により途中で-になる
          19/4と3と掛ける方が良いか
            4.75*3-3*4
              3*(4.75-4)
            4.75*(3*(4.75-4))-3*3
              3*(4.75*(4.75-4)-3)
            4.75*(3*(4.75*(4.75-4)-3))-3*(3*(4.75-4))
              3*(4.75*(4.75*(4.75-4)-3)-(3*(4.75-4)))
            4.75*(3*(4.75*(4.75*(4.75-4)-3)-(3*(4.75-4))))-3*(4.75*(4.75-4)-3))
      4A2=19*3-12*4
            4.75*3-3*4
              3*(4.75-4)=3*0.75
            4.75*3*0.75-3*3
              3*0.75*(4.75-3*3/3*0.75)=3*0.75*(4.75-3/0.75)
                =3*0.75*0.75
            4.75*(3*(4.75*(4.75-4)-3))-3*(3*(4.75-4))
              3*(4.75*(4.75*(4.75-4)-3)-(3*(4.75-4)))
            4.75*(3*(4.75*(4.75*(4.75-4)-3)-(3*(4.75-4))))- 
       3に0.75を掛けていくだけ

No.59 鉄道の旅
  https://yukicoder.me/problems/no/59
  始点では0、各中間駅では荷物を積むか下ろすか決まっている
    荷物を積む前にすでにその荷物の重さ以上の荷物がk個以上列車に積まれている場合にはその荷物を積めない
    指定の重さの荷物が一つでもあれば降ろす
      1<=N<=100000
      1<=k<=100000
        最終的に荷物をいくつ積んでいるか
          wの符号はクエリの種類といえる
      -の場合はあれば降ろすので計算量には影響しない
      積む場合をどうするか
        BITで行ける
          今乗っている荷物の数から積まれる荷物未満の数を引いた数がk以上でなければ良いのである
          
No.60 魔法少女
  https://yukicoder.me/problems/no/60
  1<=N<=100000
  1<=K<=100000
  -500<=xk,yk<=500
  1<=Hpk<=10000
  座標を0,1000に修正
    あとはimos法
    
No.61 リベリオン
  https://yukicoder.me/problems/no/61
  w*h
  mの位置(mx,my),hの位置(hx,hy),(hx,hy)から伸びるベクトル(vx,vy)がある
    ベクトルが伸び続け、壁に反射すると入射角と同じ角度で反射する
      (vx,vy)は１秒間に進む距離といえる
        そのまま進む時、D秒以内にmにヒットするか
    愚直に計算するとTLEである
      直線上に(mx,my)が現れればいいわけだが、反射を考慮するのが難しい
        点上を通りすぎるところなので、vx,vyをまず最大公約数で割る
          どの点を通り過ぎるか分かる
            格子点が打てるようになる
              格子点の数はせいぜい15*15程度
                つまり一つ一つ追っても225である
                  交差する事があるため、同じ点にたどり着いた時という判定では難しいが、300も繰り返せば十分に求められるだろう
        最大公約数回進むと1秒である
        あとは次の座標を決める方法を見つければ良い
          下手すると反射回数がかなり多い場合もあり得る
            すると計算回数が増える
              45°で進めるようにグリッドを拡張すると計算が楽になる
                例えば1,3の時はx軸を3倍にすると3,3になる
                2,3の時はx軸を3倍、y軸を2倍にする、すると一回の移動で6,6となる
                  5,5からスタートし、3,3で進むときに6,6にあたる時
                    6,6地点から-2,2で次の地点に進むとなる
                      そこから5,7に衝突するときは
                        次のベクトルは(-1,-1)となる
                          壁に当たる回数によっては計算回数が激増する
                            もっと簡単に計算出来ないか
                            実は間に合う計算量か
                          1進むごとに(-1,-1)される為反射する回数もせいぜい15である
                            225*15=3375で実現可能
                              10000*3375であれば間に合う
    反射して着地する場所は普通に求められる
      例えば2から0に向かって-4進む時
        -2進んで2進むため、2になる
      このように処理することにより、x,yを別で考えることが可能となり簡単となった
        さらに振動する時は0に到達する時
          x<0になっていたらそのままxをpositiveにする
            x>limに行った時に2*lim-xで反射して到達する場所が拾えるのである
              これで良い

No.66 輝け☆全国たこやき杯
  https://yukicoder.me/problems/no/66
  2^m人の選手が出場
    トーナメント形式
      それぞれの選手は強さパラメータsiを持っている
    aとbが対戦する時aが勝つ確率はsa^2/(sa^2+sb^2)、bが勝つ確率は1-p(a)
      n1が優勝する確率を求めよ
    1<=m<=10
      それぞれが勝つ確率を全て出せば良い
        トーナメントの良いプラクティス
          
No.67 よくある棒を切る問題 (1)
  https://yukicoder.me/problems/no/67
  i番目の棒の長さはLi
    同じ長さのk本の棒を作りたい
      長さの最大値を求める
  2分探索の代表的な問題
    つなげられない為、単純に切り出すだけである

No.74 貯金箱の退屈
  https://yukicoder.me/problems/no/74
  n枚の硬貨を円形に並べる
    n枚の硬貨から適当に１枚選ぶ
      d円であれば時計回りと反時計回りにd個先の硬貨をひっくり返す
        全ての硬貨を表向きにしたい
          裏表は0,1で表わされる
  1<=n<=100
  1<=d<=1000
  0が裏、1が表
  YesNo判定問題
    硬貨は時計回りの並びとなっている
      有向グラフにもなっている
        問題は閉路になっている場合である、自己ループもあり得る
          少し厄介である
            自己ループの場合は行先数が1になる為、フラグを立てられる
              入ったら表にして処理を終了可能
      問題文を読み間違えていた
        連鎖するわけではなく、選んだところから+d,-dの場所の硬貨をひっくり返すという処理であった
          グラフではない
    表は一度ひっくり返されているという前提にして
      全て奇数回ひっくり返せれば良いということである
        同じ所を二度使用する事があるのか？
          数字を１ずつ増やすだけと考えると２回増やすのは０回増やすのと同じであるため、ない
      貪欲的な選択が出来るか
        これは出来ない
      順番は関係ない
        ある場所をひっくり返せるのが複数存在するのが厄介
      (x-d)=a,(x+d)=bのペアを考える
        a>bの時はswap
          初期011で
              101
              011
              001
          の時に
              101は使用される
                110となる
                最後に001を使用する
          初期000で
              110
              101
              011
          の時は110でひっくり返せなくなる
            自分の場所は奇数になるようにひっくり返すことが出来るが
              どれを処理するかを決めるのには時間がかかる
        上で考えるのとは別の形でグラフに出来る
          ループするところがないように無向グラフとして張る
            すると始点から伸びる各辺に対してyes、no判定が出来るようになる
              全てyesになるパターンがあればtrueを返せるし
                1→3
                2→3の時にどうするか
                  １→３→２のグラフにする
                    始点1としたとき3→2と進み、2は終点なので一つ戻る
                      3は2を見て、裏であれば３→2の処理を使用する
                        1に戻り同じ事を繰り返す
                          最終的に1が表になれればok
                            これを考えると自己ループはどうするかという問題になる
                              同じ考えで上のやつを処理すると
                                011初期
                                辺1→3
                                  2→3
                                  3→3と構築されている
                                  3を自己ループとしたときに
                                  3につながる頂点は全てどちらにする事も可能となる
                                    これを考えると自己ループを含む場合、全て1に出来るのではないか
        連結成分内で裏が偶数であればokという話、自己ループの場合は偶奇の調節が可能であるためok
          確かに01をひっくり返す場合10になるため、数は変わらないが裏表の移動は一つずつ出来ると考えられる
            すると連結成分内に偶数個0があれば隣接させて両方共1にする事が出来る
          
No.75 回数の期待値の問題
  https://yukicoder.me/problems/no/75
  回数の期待値だが、さいころを複数回振ってその合計をkにするために必要な回数の期待値である
    kを超えたら0にリセットされる
      期待値は和になるためdpな感じもする
        1は1回で到達出来る、それは1/6であるため1/pである
        2は1回で到達できる、それは1/6であるため1/pである
          ここは0から1回で到達できるという意味では確かに1/pである
            1回で到達できる確率は1/6
            2回で到達できる確率は1/36
              この考え方だと3,4,5,6でリセットされる確率も考慮する必要がある
                4/6で0となる
                  試行回数に対する期待値の計算方法とはならない
        9は？
          3~からは1回で到達出来るため1/pだろう
            これは2回で到達出来る期待値
              2回で到達出来る期待値という考えな時点で間違っている気もする
                7に到達出来る期待値である
                  これさえわかってしまえばあとは大体処理出来そうだ
                    単純に2に1/36掛けるとひどい値になる
                    1~6まではリピートしないということを考えないといけない
                      6/6で1~6までが出る
                        確率6/6で1~6、そこから1/6で7に行ける
                          2/(1/6)は12である
          2や3についてもdp的に求められないといけないような気もする
            単純に確率だけを考える
              1の時に0になる確率は5/6、1になる確率は1/6
                反復試行回数の期待値はこの計算方法では考えにくい
          2の時に2回で到達出来る確率は(1/6)(1/6)
            1回で到達出来る確率は(1/6)
              しかし答えは1/(1/6)である
                ここの考え方が重要である気がする
                  0より1回で到達出来る試行回数は1/(1/6)
                        2回で到達出来る試行回数は1/(1/36)
                    この和は6をはるかに超える
                2に到達出来る試行回数であって、2になる確率で試行回数を割ったものが期待値なわけである
                  確かに0からは1/6で到達可能であるし、1からも1/6で到達可能である
                    1/((5/6*1/6)+(1/6*1/6))はどうだろう
                      (5/6*1/6)+(1/6*1/6)=5/36+1/36=1/6である
                        合っていると考えられる
                          0からの確率の5/6を入れるのは間違いではないか
                            反復した場合考えている、これは違う気がする
                              いや、0から1回で到達出来る確率なので、間違っていないのではないか
                                0になるか、2になるかである
                                  それは5/6である
                    3の時を考える0からは(4/6*1/6)
                                1からは(1/6*1/6)
                                2からは(1/6*1/6*1/6)か(1/6*1/6)
                      4/36+1/36+1/216+1/36
                        2からの時に1を経由するところを考えると1/6を超える
                          単純に0から2に行く確率を考えるなら1/6である
                            それであれば3に行く確率も0からのみ考えればよく、1/6となるはずだが
                      1/(1/6)=0.1666666666666667
                        1/0.1666666667
                      1/p=9.94315
                      p=0.1005717504010299‬
  通常の確率dpであるならdp[i]=sum(p=i-6 to i-1,dp[p]+1/6.0)でiの値は決まる
    これが、kを超えたときに0に戻るという条件によりさらに難易度が上がっている
      (yukicoderの星3は応用なので、経験値が足りている、いないがちょうど良い感じに分かる問題が多くてよい)
    サイコロを振る回数cを決め打ちし、c回振った後にまた0から到達するために何回かかるかをみる
      その回数は上のdpで決めるが、すでにc回振っているという前提で処理する
        dp[i<0]はcでi=1の時は(c+1)/6と考える、これをkまで行い、cを超えていた場合、もっと小さいc'が存在すると考える
          超えていない場合は大きいc'が存在すると考える
            これは難しい、dpも応用になるとまだまだ到達していない問題がある

No.76 回数の期待値で練習
  https://yukicoder.me/problems/no/76
  これは上のdpをそのまま使うだけな気もする
    6面それぞれ出る確率が1/6ではないという特殊な条件であった
      愚直に実験してac

No.94 圏外です。(EASY)
  https://yukicoder.me/problems/no/94
  1kmまで会話できる無線機
    中継局を1つ以上挟むことで通信距離を延長できる
      無線機は1km、
      中継器と中継器は10km
    2次元平面上にn本の中継局が立っている
      xi,yi
        無線機aと無線機bの通信出来る最大距離を求める
    10^2までは中継器の通信は可能
    1<=n<=1000
      中継器感で通信可能かn^2で求められる
        グラフにすることが出来る
          中継器間は接続出来るのであれば二点間の最短距離を求められる
            max{ai,ajの最短距離}+2.0が最大？

No.101 ぐるぐる！あみだくじ！
  https://yukicoder.me/problems/no/101
  1,2,...Nという数列をあみだくじでシャッフルすると
    何回か繰り返しているうちに元の数列に戻る
      必要な最小のシャッフル回数を求めよ
    グルーピングされる
      それぞれグループにおいて元の戻る回数があり、その最小公倍数が答え
    同じ高さに横棒は2本存在しない
      1<=N<=100程度であるため全探索可能
      高さは1<=k<=1000
        n*kでよい
          
No.103 素因数ゲーム リターンズ
  https://yukicoder.me/problems/no/103
  n個の整数、いずれかの整数を選び、素因数のどれかで1回割るか、同じ素因数で２回まで割る事が出来る
  n個の全ての数を1にしたプレイヤーが勝ち
    nimに帰着出来そうではある
      素因数が奇数個であれば1と偶数に分ける
        と、思ったが、これは全ての素因数にMを分解出来るということではないか
          それで最大2個まで取得可能なnimに帰着出来る
            nが拡張されるタイプの問題であることに気が付けるかどうかの問題

No.107 モンスター
  https://yukicoder.me/problems/no/107
  初期値100
    最後の数字を最大化したい
      総数は1<=n<=16
        diが正の数であればそれだけ現在の数字を増やせる
        diが負の数であればそれだけ現在の数字が減る
          bitdpっぽい
            最大体力と現在の体力を最大化していけば良いようには思うが
              貪欲でも良くはないだろうか
                しかし制約的にbitdpっぽい
              とりあえず貪欲してみよう
                だめ
              bitdpにする
                最大体力が残るような組み方をすればよい
                  一個手前の状態における悪いモンスター数で最大体力は求められる

No.108 トリプルカードコンプ
  https://yukicoder.me/problems/no/108
  1/Nの確率で1枚手に入る
    ３枚ずつ集めたい
      カードの枚数の期待値は？
        カードコンプの期待値の求め方はどうすれば良いのであろうか
          1<=N<=100であるため、memo化も出来ない
            素直にやり方を学ぼう
              以前に見たdpの典型だったが確か実装してなかった問題である、ここで実装しとこう

No.117 組み合わせの数
  https://yukicoder.me/problems/no/117
  0<=n,k<=10^6

No.124 門松列(3)
  https://yukicoder.me/problems/no/124
  3つの竹の長狭の降順で２番目が左または右側になっているもの
  ３つの長さは全て異なる
  (1,1)→(w,h)に進む
    昇順、降順になっていない３つの並びかつ、全ての長さが異なる
      2<=W<=100
      2<=H<=100
      1<=m(i,j)<=9
        スタートからゴールまでの最短距離を求める
          直近二つの場所と今の場所で門松列になっているか
            ３手分を考えると単純な幅優先では行けない
              真ん中で考える
                1手前は上下左右に存在し、1手後も上下左右に存在するため
                  4*4のループをすれば良い
                    fromとtoの組み合わせ毎に最短を残すように出来る
                      (100,100,4,4)
                      が、toは残さなくて良さそうであるため、(100,100,4)で組み立てられそうである

No.130 XOR Minimax
  https://yukicoder.me/problems/no/130
  a1,a2,...,anが与えられる
    a1 xor x,a2 xor x,...,an xor xの最大値を最小化したい
    0<=ai<=10^9
      あるbitに関して、全てのaiにあれば1にする事によって0に出来る、これはxに採用出来る
        同じく全てのaiについて0であれば0に出来る
          一番上からbitを立てるか立てないかを判定する
            のようにやってみたがいくつかのパターンでwa
              貪欲ではない場合は桁dpだが、とりあえずダメになるbitの組み合わせを見つける必要あり
            それぞれのbitの偶奇も関係
            あくまでも各数字についてxとxorするわけなので、サマリーも出来ない
              戦略として１つ１つの数字の各bitについて見ているわけであるが
                貪欲で行うとどうしても最適にならない場合がある
                  上のbitから考える
                    そこからbitが立っている場合と立っていない場合に分けられる
                      bitを立っている方の要素は立っていない方の要素よりも真に大きい、
                        この時、立っていない方の要素は考える必要がない
                      立っていない方の要素を立てる場合、立っている方の要素のbitは0になるため上の逆になる
                        すると考えるサイズが小さくなり、分割統治法のようにO(nlogn)程度になる
                          後は再帰で処理する

No.134 走れ！サブロー君
  https://yukicoder.me/problems/no/134
  （W+100)/120=T
    1<=N<=13
    0<=xi,yi<=1000
      重さは最大でも1300
        最初が一番重い、全ての荷物を降ろせば軽くなる
    各点への移動は結局のところマンハッタン距離かかる
      13個の移動先について全探索するのが速い気もする
        13!で60億なので不可能
          1000*1000グリッドなので重さについて保持するのも難しい
            となるとbitDPである
              移動元を考えるとbitdpでもない気はする
      荷物を降ろす秒数は確実にかかる為、最終的に全て足される為、処理中は考えなくて良い
    巡回セールスマンか？
      しかし重さの概念があるため、単純ではない
        というか13*13のグラフを張れる
          辺のコストがマンハッタン距離になる
            d[13][1600]である、ダイクストラ可能
            各頂点でのd[i][0]+スタート地点からのコスト+重さ全部が答え
        ダイクストラは出来ない
          再帰のbitdpで行ったが、解説も見て
            ３重ループで集合、現在地、次の位置を決めると普通にbitdp出来る

No.140 みんなで旅行
  https://yukicoder.me/problems/no/140
  1<=N<=555
    グループ分けの総数
      それぞれのグループには夫婦が1組以上属している必要がある
  1グループの時はn-2について考え
  2グループの時はn-4について考える
    この考え方では重複がある
      単純に割れない
        グループ分けについて全体g^2nからそれぞれの夫婦がバラバラに属する数を引く方が楽な気もする
          a,bが同じグループに属さない場合の数は
            g*(g-1)である
            これをそれぞれの夫婦について考えると
          g^n*(g-1)^nにならないだろうか
            違う、例えば夫婦aはバラバラだが夫婦bがそろっている場合がカバーされない
            それだと所属しないグループが生まれる
              グループが名前分けされている場合は有効であるが違う
                包除原理を使用
          人は区別するがグループは区別しないタイプの場合分けであった
            箱の区別をなくすだけである為g!で割るだけとも言える
    どのようにパターンを考えなければならないのか
      スターリング数とパスカルの三角形との組み合わせ
        かなり難しい。。。
        http://mmxsrup.hatenablog.com/entry/2016/09/17/135324
          後で復習

No.145 yukiover
  https://yukicoder.me/problems/no/145
  n個のパネル
    小文字のアルファベットをいくつかの列に分割して並び替える
      辞書順でyukiより大きいと幸福度が1上がる
        幸福度を最大化する
      yより大きいのはzしかない
        yuより大きいのは
          y(v~z)
        yukより大きいのは
          yu(l~z)
        yukiより大きいのは
          yuk(j~z)
      あとは選び方
        列の文字列の長さは関係ないため、zは1文字で作る
        あとはyを探し、なければ終了
          yがある場合
            (v~x)を探す
              あればyと組み合わせ幸福度を上げる
                yが余った場合、uを探す
                  なければ終了
                  あれば(l~t)を探す
                    あれば幸福度を上げる
        (a~h)は全て省く
          ソートしておくと楽そう
            というかそれぞれのアルファベットについていくつあるかサマリしておけばよさそう
        waが残っている
          yuki(a~h)で考えた時に
          y(v~x)を優先的に使った場合に少なくなる事があるか

No.147 試験監督（2）
  https://yukicoder.me/problems/no/147
  ck個の椅子がある机がdk個ある、連続した椅子には座れない
    そのような配置は全部で何パターンあるか
  数え上げ
    机一つで考え方をまとめれば後は乗算するだけ
      椅子の数が最大10^18であるためO(1)もしくはO(logn)程度
      机の数が最大10^200ある
        p(ck)^10^200であるが、余りはループするような気がしてきた
          しかし10^9+7であるため、ループさせるにもTLEはする
            繰り返し二乗法で行ける
              余りの計算はわざわざしないといけないがこれでこっちは行けるだろう
      問題は椅子の配置パターンである
        10^18であるためdp等では処理出来ない
          2^10^18であれば繰り返し2乗法でいけるが。。。
            単純に2度の計算でいけないだろうか
              2^10^18で全パターンから無効なものを引く方法である
                いや、同じ事の繰り返しなので長さを倍、倍にするのは出来る
                  0を使われない、1を使われるとしたとき
                  最初は1,0という状態が考えられる
                  2個になった場合は10,01,00が考えられる
                  3個は10に対して1,0が使用出来
                    01に対して0が使用出来
                    00に対して1,0が使用出来る
                  4個は10に対して10,01,00が使用出来
                    01に対して00,01が使用出来
                    00に対して10,01,00が使用出来る
                  これで長さが倍に出来る
                    パターンとしては端だけを考えればよく
                      11,00,10,01に全て集まる
                    これも繰り返し2乗法でいけないだろうか
                      行ける
                        後は実装するだけである
      机の数の計算はmod-1で割った余りを使用している、繰り返しを考える時にこうなるのだろうか
        
No.153 石の山
  https://yukicoder.me/problems/no/153
  n個の石の山
    交互に石を分けるゲームを行う
      2つの山か３つの山に分ける
        最後に分けられなくなった方が負け
          1<=N<=100
            これはnimではなく小さい方から考えられそう
  a,bがやるとして1の時はa負け、2の時はa勝ち、3の時はa勝ち
    4の時は2,2に分けるか2,1,1に分けるか
      2,2に分けるとaの勝ち、2,1,1に分けると負け、なので勝ち
    5の時は2,3に分けるか2,2,1に分けるか
      2,3に分けた場合はaの勝ち、2,2,1に分けると勝ち、なので勝ち
      2に分けるか3に分けるかは、分け方は決まっている為、勝てる方に行けば良い
    6の場合は3,3か、2,2,2に分けられる
      3，3は勝ちである、2,2,2は負け、なので勝ち
    7の場合は4,3か,3,2,2に分けられる
      4,3は4を2,2に分けた時3を1,1,1にする
           4を2,1,1に分けた時3を2,1にする、すると勝ち
    8の場合は4,4に分けられる
      2,2に分けた時2,2に分ける
      2,1,1に分けた時2,1,1に分ける
      とりあえず小さい数ではそこまで分からないがなんとなく1以外はA必勝な気がしている
    9の時は5,4と3,3,3に分けられる
      5,4から3,2に分けられた時2,2に分けると
        3を2,1にされて負ける
          2,1,1に分けると3を1,1,1にされて負ける
        3を2,1に分けると2,1,2,4となる
          4により偶奇をコントロールされる為負ける
        3,2,4の状態でAになっている場合
          2を11にすると勝てる
      5,4から2,2,4に分けられたら勝てる
      5,4から5,2,2に分けられたら？
        2,2,2,2に分けられる為勝てる
      3,3,3に分けた時
        1,1,1に分けられた時は2,1に分けても1,1,1に分けても負ける
    これは最終的に2,3にいくつ分解出来るかで考えられそうである
      そこまで単純でもなさそうだ
        9は必敗である
          なぜ負けるのか
          aが勝つ時のパターンは？
            分けた先の手が勝っているか負けているかはあまり関係がないと言えそうだが
              そうなるといよいよ難しくなる
          勝ち負けが繰り返される？ 
    10の時は5,5か3,3,4に分けられる
      5,5を3,2に分けられた時
        5を3,2に分けると3が二つある状態になるため勝てる
      5を2,2に分けられた時
        同じように5を2,2に分けると勝てる、10はAの勝ち
    11の時6,5か3,4,4に分けられる
      6を3,3に分けられた時
        5を2,2に分けると勝てる
      6を2,2,2に分けられた時
        5を3,2にしても2,2にしても負ける、つまり6,5にすると負ける
      3,4,4に分けた時
        3を2,1にされたときに2を1,1にすると4,4の状態になる
          つまり勝てる
            3を操作されたときには勝てる偶奇を変えられる為勝てる
        4を2,2にされたときに3を2,1にすると4を2,1,1にされ負ける
          3を111にしても4を2,2にされる為負ける
          2を11にすると3を2,1にするか1,1,1にするか4を2,1にするか2,2にするか
            この時に2,2,4 2,4 3,2,2 3,2,2,2という状態でAの手番になる
              つまり勝てる
      11は勝てるのであるが、何か見えないか
        というか9も勝てる、やっぱり必勝なのではないだろうか
      12を6,6にした時
        6,6から2,2,2にされた場合は2,2,2にすれば勝てる
        3,3にされた場合は3,3にすれば勝てる
      13を7,6にした時
        7,6から3,4にされた場合2,2,2にし
          3,4,2,2,2から3,2,2,2,2,2にすると負ける
          3,4にされた場合3,2,2,6にすると
            結局3,6でAの手番になるのと同じではないか
              となると3を2にするとBは6を2,2,2か3,3にするしかなくなる
                2,2,2,2にされると負け、つまり負け
              3を1にするとB先行の6になるので負け
              6を3,3にすると3，3，3でB手番になる
                3を1,1,1にされた場合は3,3手番になるため負け
                3を2にされた場合は2をつぶせば良いので勝ちとなると
          3,4,6の状態で3を消した場合
            4,6で相手の手番になる
              2,2,6→2,2,3,3→勝ち
              2,6→2,2,2,2→勝ち
              4,2,2,2→勝ち
              4,3,3→2,2,3,3→勝ち
                が考えられる
        今のところ負けるのが1以外考えられない
          試しにsubmitしてみるか
            wa
              grundy数をxorとるだけで、複数のゲームが合わさった状態のgrundy数を考えることができる。蟻本p284に書いてある。
            これもgrundy数だった、この形は初めてだった為解けず

No.158 奇妙なお使い
  https://yukicoder.me/problems/no/158
  ちょうどDb,Dc円払うとおつりがもらえる
    最大1万円である
      dp[11][101][10010]
    合計が10000より大きくなる事はないため、これで可能
      AC、1円玉を多く残すという
        dp[cnt][11][101] = 1円玉の数でも可能との事

No.160 最短経路のうち辞書順最小
  https://yukicoder.me/problems/no/160
  駅Sから駅Gまでの最短経路を求めてその経路のうち辞書順最小のものを出力せよ
    無向グラフ
      2<=N<=200
      移動時間はci
      最短経路を求めるのはただのダイクストラで簡単に出来る
        問題は最短経路のうち辞書順最小のものを出力する方法である
          同じコストである場所まで到達出来るもののうち、最小を保存する
            同じ駅は2度通らない、つまりコストは最大でも200*10000
              d[200][200000]で最短距離コストのうちの最小を求められるが
                基本的にはコストも最小を持っていれば良いため
              pll d[200]で良さそうだ
                後はダイクストラして復元
                  辞書順最小を取るにはゴールからスタートへの経路を見なければならかった
                    
              
                        

          
          
      
          

            
          









