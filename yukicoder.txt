No.917 Make One With GCD
  →N個の要素からなる数列A
    →1<=N<=50
    →1<=Ai<=10^8
    →部分列を考える
      →最大公約数が1となるAの部分列の総数を求める
        →部分列として取る必要がある
          →DP?
            →最大公約数の数を保存していく
              →10^8であるため、mapでやる
              
No.939 and or
  →https://yukicoder.me/problems/no/939
    →x<=yかつx and y = A かつ x or y = Bを満たすものの個数を求める
      →0<=A,B<2^31
        →bit毎に考えそう
          →Aのbitはx,yともに全て立っている必要がある
          →Bのbitの組み合わせだけ考えれば良い
            →Aで立っているがBで立っていない場合は0個
            →Bで立っているがAで立っていないbitはxで1,yで1の2パターンある
              →x<=yなので先頭bitのみy固定になるため、出た答えを2で割る
              
No.727 仲介人moko
  →https://yukicoder.me/problems/no/727
  →品物を売ったり買ったり
    →品物の取引の流れの組み合わせの数を10^9+7で割った余りで求める
      →1<=N<=10^6
      →2N人のうち半数が売りたい人、半数が買いたい人
        →DPで行ける？
          →数字の選び方が増えるため難しそう
          →商品がある時にしか買う人は来ない
            →狼と羊の問題によく似ている
              →最初は売る人であり最後は買う人
          →どちらにしろ1000000*1000000のdpテーブルは作れない
      →売りたい人、買いたい人は区別される
        →各パターンに同じ数が掛けられるため問題なし
      →2000000C1000000のうちいくつが削られるのか
        →この考え方も難しい
          →先頭と最後は固定なので(2n-2)C(n-1)となる
        →ダメなパターンは各iで出すことが出来る
          →時間の流れが右から左と考える時 i=1to2N
            →iにおいて品物がない状態で買い物に来るパターンは
              →i-1C(i/2)となる
                →i-1において売られた数x==買われた数yとなるときiは買うものがない状態となる
                  →i+1以降の全てのパターンがダメとなる
                    →i-1まででダメなパターンが現れることがあるため、それを排除出来ないとこの計算は使えない
                      →iの組み合わせからi-1まで出た組み合わせを引いてやる
                        →するとi-1までで正当な数が出る？
                          →出ない(xi<yi)となる数も含まれてしまうため
                →ある地点でダメになる時それよりまえの地点でダメな時を引いて求めるとすると
                  →i-1の地点までの組み合わせ数を決められないためダメである
            →完全マッチングとして考える
              →2N個の中からある二つをマッチさせると残りは(2N-2)
                →2N-2から二つマッチさせると残りは2N-4
                  →といったように選ぶ組み合わせの数である
                    →先頭から選んでいっているのと同じ数え方になる
                      →これにN!を掛ければ終わり
                        →やり直す問題に入れておく

No.595 登山
  →https://yukicoder.me/problems/no/595   
  →N個の地点が並んでいて地点iの標高はHi
    →地点１からスタート
      →全ての地点に一度訪問したい
        →隣接する地点に移動、i→jに移動する時エネルギーmax(0,Hj-Hi)を消費
        →ワープして好きな地点に移動する、ワープ一回につきエネルギーPを消費
    →最小エネルギーを求める
  →2<=N<=200000
  →0<=P<=10^9
  →0<=Hi<=10^9
  →右からと左からでそれぞれ累積する
    →ワープは好きなところに出来る
      →単調減少している場所はエネルギーを0に出来る
        →x1 < x2 > x3となっている場所はどっちから来る方が得かを考える
          →範囲と範囲を比較しようにもN^2かかる
            →後ろにも前にも移動出来るためdpではない
              →ワープする順番は関係ないため順序は考えなくてよい
    →隣に移動する場合でもP<Hj-Hiである場合はワープした方がよい
      →どこまでワープした方がよいのかを考える
        →ワープポイントは決められる
          →1回以上訪問であるため、ワープポイントは何度でも使える
            →基本的には一度しか訪問しない
            →ワープポイントの左と右はコスト0で到達できる
          →単調増加と単調減少がPを超えるところはコストをPに出来る
            →Pを越えないところは普通に移動した方がよい
              →累積をするが単調増加のみの累積を行う
                →そうすることでワープした時にどちらに降りた方がよいかが求められる
                →登りを使用するところはそのままコストに加算する
            →コストの少ない方を足すといった考え方では不十分である
              →ワープが使用されているかどうかを見る必要がある
                →s1ワープポイントを使用する箇所があるかどうか確認
                  →左から来ても右から来てもコストがPを越えている
                    →しかしこれだと細かく上下する場合に見つからないことになる
                      →各地点にワープする場合で考える？
                      →区間で考える？
                        →左から一番右への累積と右端にワープして左端まで行く累積を取っておく
                          →これの小さい方がresultのmax
                        →端から端で処理しない限り区間が出来る
                          →区間が出来るとワープは二度行われることになる
                            →一番右を含む場合は一度だけである
                          →一番左の区間のコストを求める
                            →左から今いるのコストを累積=a
                            →今いる地点から右のコスト+ワープ料*2を累積=b
                              →a>bになったタイミングでワープ確定
                                →次にa<=bとなる場所まででa-bが一番大きい所が区間の境目
                                  →この方法でとるとTLEになる
                                    →ただ最初の区間を取る方法としては良さそう
                          →一番左が下りの場合は下りきったところをスタート地点とする
  →解説によるとDPで処理するようである
    →時間を空けて再度確認しよう

No.948 Bomb vs Dush 
  →https://yukicoder.me/problems/no/948
  →(a(t)-Rcost)^2+(b(t)-Rsint)^2<=r^2
    →(a(t),b(t))の範囲の広がり方を見る問題である
      →t=0から始まる
        →(0,0)から(100^100^100,100^100^100)に到達出来なくなるt=t'を出力する
        →また(a(t),b(t))が埋めた領域の面積を求める
   →a(t),b(t)はそのまま使用できるRは最大100
    →値の移り変わりを確認するのが良さそうだ
      →r^2なのでmaxは10000
        →a(t),b(t)は負の数の扱うのか？
          →となると0,0を囲むようにしないといけないということである
            →式を見ると0,0にはたどり着けないような気もする
              →r^2を超える
            →tによってはcos,sinが+になることもある
              →Rcost^2+Rsint^2を軸に考えると
                →線形に考えられそうだ
                →Rcost^2+Rsint^2-v<=r2
                  →となる最大のvを取ってこれをa(t),b(t)に展開する？
  →解説見た、あとで学習する
    →https://yukicoder.me/problems/no/948/editorial
                    
No.466 ジオラマ
  →https://yukicoder.me/problems/no/466
  →1<=a<=10^4
  →1<=b<=10^4
  →0<=c<=min(a,b)
  →0<=d<=10^5
  →整数a,b,c,dが与えられる
    →aが0からのみ到達可能な場所
    →bが1からのみ到達可能な場所
    →cがa,bから到達可能な場所
    →dが辺の数
  →有向グラフを構築せよ
    →村の数nと水路の本数mを出力
    →ai biはai→biという辺を現す
  →満たす組が存在しない場合-1を出力する
    →まず-1になるパターンを考える
      →a+b-2+(c>0?c+1:0)+>dの場合-1となる
      →dが大きすぎる場合もout
        →aはa同士であれば辺が作れる
        →bはb同士であれば辺が作れる
        →cはc同士であれば辺が作れる
        →a→cは辺が作れる
        →b→cは辺が作れる
          →これは計算するよりも実際に辺を作りながら処理するほうが良さそう
   →まず最小のグラフを構築する
    →0からa-1個の頂点に対して辺を張る
    →1からb-1個の頂点に対して辺を張る
      →0からcの一つの頂点に辺を張る
      →0からcの一つの頂点に辺を張る
        →辺を張られたcの頂点からc-1に対して辺を張る
          →これで最小のグラフが作られた
   →余った辺はa,b,cの順で処理する
    
    
