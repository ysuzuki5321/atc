No.917 Make One With GCD
  →N個の要素からなる数列A
    →1<=N<=50
    →1<=Ai<=10^8
    →部分列を考える
      →最大公約数が1となるAの部分列の総数を求める
        →部分列として取る必要がある
          →DP?
            →最大公約数の数を保存していく
              →10^8であるため、mapでやる
              
No.939 and or
  →https://yukicoder.me/problems/no/939
    →x<=yかつx and y = A かつ x or y = Bを満たすものの個数を求める
      →0<=A,B<2^31
        →bit毎に考えそう
          →Aのbitはx,yともに全て立っている必要がある
          →Bのbitの組み合わせだけ考えれば良い
            →Aで立っているがBで立っていない場合は0個
            →Bで立っているがAで立っていないbitはxで1,yで1の2パターンある
              →x<=yなので先頭bitのみy固定になるため、出た答えを2で割る
              
No.727 仲介人moko
  →https://yukicoder.me/problems/no/727
  →品物を売ったり買ったり
    →品物の取引の流れの組み合わせの数を10^9+7で割った余りで求める
      →1<=N<=10^6
      →2N人のうち半数が売りたい人、半数が買いたい人
        →DPで行ける？
          →数字の選び方が増えるため難しそう
          →商品がある時にしか買う人は来ない
            →狼と羊の問題によく似ている
              →最初は売る人であり最後は買う人
          →どちらにしろ1000000*1000000のdpテーブルは作れない
      →売りたい人、買いたい人は区別される
        →各パターンに同じ数が掛けられるため問題なし
      →2000000C1000000のうちいくつが削られるのか
        →この考え方も難しい
          →先頭と最後は固定なので(2n-2)C(n-1)となる
        →ダメなパターンは各iで出すことが出来る
          →時間の流れが右から左と考える時 i=1to2N
            →iにおいて品物がない状態で買い物に来るパターンは
              →i-1C(i/2)となる
                →i-1において売られた数x==買われた数yとなるときiは買うものがない状態となる
                  →i+1以降の全てのパターンがダメとなる
                    →i-1まででダメなパターンが現れることがあるため、それを排除出来ないとこの計算は使えない
                      →iの組み合わせからi-1まで出た組み合わせを引いてやる
                        →するとi-1までで正当な数が出る？
                          →出ない(xi<yi)となる数も含まれてしまうため
                →ある地点でダメになる時それよりまえの地点でダメな時を引いて求めるとすると
                  →i-1の地点までの組み合わせ数を決められないためダメである
            →完全マッチングとして考える
              →2N個の中からある二つをマッチさせると残りは(2N-2)
                →2N-2から二つマッチさせると残りは2N-4
                  →といったように選ぶ組み合わせの数である
                    →先頭から選んでいっているのと同じ数え方になる
                      →これにN!を掛ければ終わり
                        →やり直す問題に入れておく

No.595 登山
  →https://yukicoder.me/problems/no/595   
  →N個の地点が並んでいて地点iの標高はHi
    →地点１からスタート
      →全ての地点に一度訪問したい
        →隣接する地点に移動、i→jに移動する時エネルギーmax(0,Hj-Hi)を消費
        →ワープして好きな地点に移動する、ワープ一回につきエネルギーPを消費
    →最小エネルギーを求める
  →2<=N<=200000
  →0<=P<=10^9
  →0<=Hi<=10^9
  →右からと左からでそれぞれ累積する
    →ワープは好きなところに出来る
      →単調減少している場所はエネルギーを0に出来る
        →x1 < x2 > x3となっている場所はどっちから来る方が得かを考える
          →範囲と範囲を比較しようにもN^2かかる
            →後ろにも前にも移動出来るためdpではない
              →ワープする順番は関係ないため順序は考えなくてよい
    →隣に移動する場合でもP<Hj-Hiである場合はワープした方がよい
      →どこまでワープした方がよいのかを考える
        →ワープポイントは決められる
          →1回以上訪問であるため、ワープポイントは何度でも使える
            →基本的には一度しか訪問しない
            →ワープポイントの左と右はコスト0で到達できる
          →単調増加と単調減少がPを超えるところはコストをPに出来る
            →Pを越えないところは普通に移動した方がよい
              →累積をするが単調増加のみの累積を行う
                →そうすることでワープした時にどちらに降りた方がよいかが求められる
                →登りを使用するところはそのままコストに加算する
            →コストの少ない方を足すといった考え方では不十分である
              →ワープが使用されているかどうかを見る必要がある
                →s1ワープポイントを使用する箇所があるかどうか確認
                  →左から来ても右から来てもコストがPを越えている
                    →しかしこれだと細かく上下する場合に見つからないことになる
                      →各地点にワープする場合で考える？
                      →区間で考える？
                        →左から一番右への累積と右端にワープして左端まで行く累積を取っておく
                          →これの小さい方がresultのmax
                        →端から端で処理しない限り区間が出来る
                          →区間が出来るとワープは二度行われることになる
                            →一番右を含む場合は一度だけである
                          →一番左の区間のコストを求める
                            →左から今いるのコストを累積=a
                            →今いる地点から右のコスト+ワープ料*2を累積=b
                              →a>bになったタイミングでワープ確定
                                →次にa<=bとなる場所まででa-bが一番大きい所が区間の境目
                                  →この方法でとるとTLEになる
                                    →ただ最初の区間を取る方法としては良さそう
                          →一番左が下りの場合は下りきったところをスタート地点とする
  →解説によるとDPで処理するようである
    →時間を空けて再度確認しよう

No.948 Bomb vs Dush 
  →https://yukicoder.me/problems/no/948
  →(a(t)-Rcost)^2+(b(t)-Rsint)^2<=r^2
    →(a(t),b(t))の範囲の広がり方を見る問題である
      →t=0から始まる
        →(0,0)から(100^100^100,100^100^100)に到達出来なくなるt=t'を出力する
        →また(a(t),b(t))が埋めた領域の面積を求める
   →a(t),b(t)はそのまま使用できるRは最大100
    →値の移り変わりを確認するのが良さそうだ
      →r^2なのでmaxは10000
        →a(t),b(t)は負の数の扱うのか？
          →となると0,0を囲むようにしないといけないということである
            →式を見ると0,0にはたどり着けないような気もする
              →r^2を超える
            →tによってはcos,sinが+になることもある
              →Rcost^2+Rsint^2を軸に考えると
                →線形に考えられそうだ
                →Rcost^2+Rsint^2-v<=r2
                  →となる最大のvを取ってこれをa(t),b(t)に展開する？
  →解説見た、あとで学習する
    →https://yukicoder.me/problems/no/948/editorial
                    
No.466 ジオラマ
  →https://yukicoder.me/problems/no/466
  →1<=a<=10^4
  →1<=b<=10^4
  →0<=c<=min(a,b)
  →0<=d<=10^5
  →整数a,b,c,dが与えられる
    →aが0からのみ到達可能な場所
    →bが1からのみ到達可能な場所
    →cがa,bから到達可能な場所
    →dが辺の数
  →有向グラフを構築せよ
    →村の数nと水路の本数mを出力
    →ai biはai→biという辺を現す
  →満たす組が存在しない場合-1を出力する
    →まず-1になるパターンを考える
      →a+b-2+(c>0?c+1:0)+>dの場合-1となる
      →dが大きすぎる場合もout
        →aはa同士であれば辺が作れる
        →bはb同士であれば辺が作れる
        →cはc同士であれば辺が作れる
        →a→cは辺が作れる
        →b→cは辺が作れる
          →これは計算するよりも実際に辺を作りながら処理するほうが良さそう
   →まず最小のグラフを構築する
    →0からa-1個の頂点に対して辺を張る
    →1からb-1個の頂点に対して辺を張る
      →0からcの一つの頂点に辺を張る
      →0からcの一つの頂点に辺を張る
        →辺を張られたcの頂点からc-1に対して辺を張る
          →これで最小のグラフが作られた
   →余った辺はa,b,cの順で処理する
    

No.1 道のショートカット 
  →https://yukicoder.me/problems/no/1
  →N個の町があり、道は町Siから町Tiに行くのにYiのコストがかかり、Miの単位時間がかかる
  →1からNまで移動したい
    →C円持っている
      →一番早く着く道を選べた時合計の単位時間は何か
        →到達出来ない場合-1
  →2<=N<=50
  →1<=C<=300
  →1<=V<=1500
    →制約は小さい
    →各町においてコストに対する時間を保持する
      →各町におけるコストを考えた時
        →c1<c2でt1<=t2である場合はc2を考える必要がない
          →c1>c2でt1>t2である場合、速く到着出来る可能性があるため、処理する
        →特殊なダイクストラを実装する

No.2 素因数ゲーム
  →https://yukicoder.me/problems/no/2
  →2以上の自然数N
    →Nに対してNの素因数のどれかで割りその商になる数を渡す
      →同じ数であれば割り切れる限り何回も割って良い
        →渡された数が1になったプレイヤーが負け
  →grunday数に押し込める？
    →取れる数が平等ではない
      →山を素因数毎に分ければnimにすることが出来る
        →grunday数
      
No.6 使いものにならないハッシュ
  →https://yukicoder.me/problems/no/6
  →[k,n]の範囲でハッシュが衝突しない最大の長さを持っている連続した素数列の一番大きい先頭の数字を出力する
    →素数列とハッシュ値の前計算はさほどかからない
      →数字を管理しながらループするだけ
    →少しややこしかった
      →範囲の最初の数が再び出てくるところではなく、重複していない数字の羅列であるので
        →1,2,3,4,2と来た時に1,2,3,4が重複なしの列として使用可能である
          →queueで管理する
        
No.9 モンスターのレベル上げ
  →https://yukicoder.me/problems/no/9
  →集合A,Bに分けられる
    →Aの要素aはBの要素bに対して以下のように処理可能
      →floor(b/2)をaに加算しbを集合Bから取り除く
    →Bの要素は時計回りに並んでいて上の操作を時計回りの順番に行う
    →Aは一番数字が低いものから処理をする
      →それぞれのaに対して上の処理が行われるが、その回数の最大が一番低くなるような最初bの選び方をしたとき最大のaの回数を求める
  →1<=N<=1500
  →bをどこから初めてもN回処理される
  →bの選び方はN
    →O(N^2)なので十分間に合う
      →priority_queue<pii>で処理する
      
No.12 限定された素数
  →https://yukicoder.me/problems/no/12
  →'0'から'9'までの数が重複せずにN個与えられる
    →1<=K<=L<=5000000
    →K<=Lの範囲から素数のみ全て取り出す
      →全ての素数について使われている数字を調べる
        →この数字と最初に与えられた数字を等しくしたい
      →L-Kの最大値を求めよ
        →なければ-1
  →5000000までの素数を出す
    →使われている数字を出す
      →5000000*10の配列で良い
        →使われている数字の判定をしながらしゃくとりする
        
No.13 囲みたい！
  →https://yukicoder.me/problems/no/13
  →w*hで構成されるフィールド
    →囲みが出来ればok
      →上下左右に同じ数字を辿れる
        →やるだけ
  
No.17 2つの地点に泊まりたい
  →https://yukicoder.me/problems/no/17
  →N個の頂点
  →M個の辺
    →滞在コストがある
      →0からN-1に辿りつまでに0とN-1以外の異なる2つの頂点に滞在する必要がある
        →N-1に行くまでになので0→N-1→o→o2→N-1みたいな移動は出来ない
          →0→N-1の辺は削除してよい
            →出来るようだ
    →N-1までで辺の長さが3である場合も考える必要はない
      →1<=N<=50
        →滞在の条件が少しめんどくさい
          →移動コスト、滞在コストpllでダイクストラ
    →同じところは2度通ってもよい、しかし同じところは2度滞在してはいけない
      →という条件だ
        →この場合は50c2で滞在する場所を決め打ちして滞在コストを決めてダイクストラでやるしかなさそうだ
    →2か所滞在すると決めた時に道順は
      →0→s1→s2→n-1か0→s2→s1→n-1である
        →となるとワーシャルフロイドだ
  
No.20 砂漠のオアシス
  →https://yukicoder.me/problems/no/20
  →n*n
  →(ox,oy)に行くとxを2倍に出来る
  →隣接マスに移動可能
    →移動先のl分xを減らす
      →0にならないように移動する
  →(n,n)に到達可能か判定
    →1<=n<=200
    →1<=x<=500
      →最短経路で進む
        →n,nまで到達するのにコストがxを越えないか
        →oにたどり着いた時にコストがxを越えないか
          →oで体力を2倍に出来るのは1度だけ
            →1から最短距離を取り、n,nに到達できるならok
            →oでxを越えていた場合no
            →oでv-cを2倍にし、n,nまでの最短距離を出す
            →到達できるならok

No.23 技の選択
  →https://yukicoder.me/problems/no/23
  →期待値の問題である
    →1回の攻撃の期待値は
      →aとdをそれぞれ選択する確率を1/2とすると
        →dを選択した時に2/3でdとなる
    →1<=h,a,d<=10000
      →全てaで倒す
      →1度dを使用する
      →2度dを使用する。。。。
        →この計算をして最小の期待値を求める
          →dを使用する時の一回の期待値は2/3*dである
    →dの使用回数は3/2となる
      →確率pで起こる事象がx回起こる場合の試行の期待値はx/pとなる
          
No.25 有限小数
  →https://yukicoder.me/problems/no/25
  →n,mが与えられる、n/mが有限小数で表されるか判定する
    →0でない一番小さい桁の数字を出力する
      →普通に処理して出し切れるか
        →2度同じ余りが登場したら循環小数である
          →long long でも桁あふれを起こす
            →...C++で出来るのか謎
          →有限小数になる分母は2と5の倍数であった
            →gcdで分母と分子を割った後に分母に2,5以外の数があると循環小数となる
              →あとは2もしくは5が分子に足りないため割り切れない状態になるため、
              →分母の2か5の多い方と同じ数だけ分子に10を追加していくイメージとなる
                →分子の下1桁だけで考えればよさそう
                  →3桁程度で考えてAC

No.27 板の準備
  →https://yukicoder.me/problems/no/27
  →v0,v1,v2,v3の4つの数字をa,b,cの3つの数字の和として表す
    →a,b,cはそれぞれ何度でも使用可能
      →a,b,cの使用回数を最小にしたい
    →1<=v0,v1,v2,v3<=30
      →全ての数字が異なる場合は最大公約数が必要
        →いずれか2つの数字が同じであれば4つ以下で済む
          →最大公約数を取った時にmin{l=b/gcd(a,b)}が一番小さな数となる
            →2,3,7,15の時が反例
    →これはdpではないだろうか 
      →2,4,8,16で考えると2,4,16,4,4の5枚で済む
      →2,3,5,7で考えると2,3,2,3,7の5枚
        →全部違う場合は最低5枚必要である
          →2,11,17,29で考えると
            →2があるおかげで2,11,2,2,2,11,29で済む
              →5,11,17,29で考えると
                →どの間も偶数であるため、1が必要となっている
                  →29は決め打ちしたとして
                    →5,5,5,1,5,5,5,1,1,29で10
     →a,b,cを全探索した方が良さそうだ
      →30*30*30なので余裕
        →数字3つ決めてdpする方が楽である
          
No.30 たこやき工場
  →https://yukicoder.me/problems/no/30
  →2<=N<=100
  →1<=M<=1500
  →p,q,rはpがq個あるとrを一つ作れるということ
    →nは100程度なので、普通に処理可能
      →これは有向グラフとすることが出来る
        →1~n-1は全て必要であるので、全て足すことにより処理出来る
          →循環がありうる
            →となると厄介である
              →capではないのでフローは流せなさそう
      →どこからくれば最短かを問う問題ではないため、厄介
        →むしろ各素材を作るためのコスト考える方が正しい気がする
          →nだけは全て必要であるが、他はそんなことがないため
            →nも最短で作ればよいので上のは間違い
              →全て最短で作れるようにするのが良い
          →それであればダイクストラで処理出来る
        →循環している場合、始点が定まらないため違う
          →各頂点に一方的に進むことの出来る始点0を作る
        →1.製品iの製造方法が複数書かれている場合は、それらすべての材料が必要です。
        →2.Riの材料(および材料の材料、…)としてRi自身を必要とすることはありません。
          →とのことなので、逆辺を張った方が良さそう
          →2.より循環もしていない
            →お互いに辺が張られているということは制約上ない
          →逆辺を張り、辺がないものを見る
            →辺がないものに張られている辺が次の頂点
              →と思ったが、一概にもそういえない
                →まだ処理されていない辺にたどり着く事がある
                  →そのような頂点はレベルを一つ上げて次の段階で処理するようにする
                  →各頂点についていくつ必要かなので結局nからスタートした方が良さそうである
                  →ACしたがなかなか難問であった
                    →対象の頂点から伸びている辺が全て処理されたら
                      →その頂点に伸びている辺をqueueに入れて処理を進めるといった方法
                        →コーナーケースとしてnからさらに辺が伸びている場合（nから伸びている辺はそもそも集合に入れない)
                        →nに辺を伸ばしているところがほかにも辺を伸ばしている等(辺が伸びていない場所は全てスタート地点とする
        
No.33 アメーバがたくさん
  →https://yukicoder.me/problems/no/33
  →t秒後にアメーバが何匹になっているか
    →全てのアメーバは1秒後に分裂
      →分裂したらx-d,x,x+dに位置する
        →同じところにいるアメーバはくっつく
  →1<=t<=10^9
    →1秒後さえわかれば後は計算可能
      →あるxについて、取りうる点の位置は
        →x-t*d~x+t*dの間で間隔dに全て存在する事になる
          →重なりを見る必要がある
            →ai,ajについてお互いが間隔d上に存在しているか判定
              →判定している場合、同じグループとなる
                →同じグループでソートする
                  →範囲が重複していたら何体分重複しているか計算する
                    →ai<ajである場合
                      →(ai+t*d-(aj-t*d))/d+1が重複している匹数
            →最初に全てで何匹になるか計算して上の重複を消していく
              
No.34 砂漠の行商人
  →https://yukicoder.me/problems/no/34
  →sからtまで到達するための最短距離を出す
    →体力という概念があり、マスに書かれた数分減る
      →0にならないように移動する
        →あるマスに到達した時の残り体力での最短距離を保持しておく
          →体力の最大は10000、dp[100][100][10000]で保持すれば問題ない
   →5秒制限だがTLEとなった
    →sからtまでの最長距離で最大消費体力は実際のところ
      →(100+100)*9=1800程度である
        →体力が1800を超えている場合
          →gx-sy+(gx-sy)で最短距離が出る
    →体力に関して色々と制限を加えることによって短縮できた
      
No.37 遊園地のアトラクション
  https://yukicoder.me/problems/no/37
  Tを上限とし、ciが重さ、viが価値のナップサック
    viは使用するとfloor(vi/2)となる
  1<=T<=10000
  1<=n<=15
  1<=ci<=100,1<=vi<=500
    個数に制限はないが価値は制限があるナップサックともいえる
      各価値が0になるまで繰り返すのが正しい気がする
        viが最大500程度であれば9回
          nt*max{logvi}=10000*15*9
            計算量は余裕である
              
No.38 赤青白ブロック
  https://yukicoder.me/problems/no/38
  a,b,cが10個ずつランダムに並んでいる
  kr,kbが与えられる
  aのkr右とkr左にはaがあってはいけない
  bのkb右とkb左にはbがあってはいけない
  cはせいげんなし
    aかbを抜き出すという操作が出来る
      上の条件を満たす最大の長さを求めよ
  足せないので削るのを考えるだけではあるが
    cは考える必要がないため、実際は1<<20で済むとも考えられる
      1<<20*30程度である
        全探索可能
  
No.41 貯金箱の溜息（EASY）
  https://yukicoder.me/problems/no/41
  1円と6つの数字のゾロ目からなる硬貨の10種類が使われている
  どの硬貨も10^20枚以上持っている
    m円の買い物がしたい
      m円を作れるパターン数を10^9+9で割った余りとして求めよ
  1<=t<=10000
  1<=mi<=10^10
    mimod111111に関しては1円でしか払われない
      あとはmiを111111で割った数に対してdpをすればいいだけである
        10^10を111111で割ると4桁程度になるため、個数無制限dpで処理出来る
        
No.50 おもちゃ箱
  https://yukicoder.me/problems/no/50
  n個の要素がm個の要素に収まるかを計算する問題
    miはnの任意の要素の和以上であれば収まると判定される
  nの要素の大きなものから入れるmを決めていく
    niが入ったらmkはni分だけ小さくなると考えて
      priority_queueで処理出来る
        そのような貪欲で処理するのが正解だろうか
          n={5,3,1} m={9,3,1}とすると
            貪欲で処理すると9の次に4が処理され、その次に3に1が入る
              正解は9ひとつで済むはず
                ただ、一番nはmの一番大きいのに入れればいいというのは間違いない
  1<=N<=10
  1<=M<=10
  であった、これなら6乗程度でも許容されてしまう
    好きに処理したら良い
      全パターンは10^10程度になるため難しい
    以下の時にwaとなる、この時は2である
      3
      4 3 2
      3
      5 4 3
    nの全パターンをmにはめてやれば良さそうである
      
No.53 悪の漸化式
  https://yukicoder.me/problems/no/53
  漸化式で定義される数列の第N項を求めるプログラムを書く
    A0=4,A1=3,4Ak=19Ak-1-12Ak-2,k>=2
    4Ak=19Ak-1-12Ak-2
      Ak=(19A(k-1)-12A(k-2))/4
        Nは100程度
          誤差が気になる
      4Ak=19A(k-1)-12A(k-2)
         =19((19A(k-2)-12A(k-3))/4)-12((19A(k-3)-12A(k-4))/4)
         =19(19A(k-2)-12A(k-3))-12(19A(k-3)-12A(k-4))/4
      ∴
      4*4Ak=19(19A(k-2)-12A(k-3))-12(19A(k-3)-12A(k-4))
        4で割るのは最後で良さそうである
          それとも4で割り切れる値になっている場合は4で割るか
      A(k-2)とA(k-1)では割られる回数が異なるため、最後に割るのは難しい
        やりながら処理するしかないが、計算誤差により途中で-になる
          19/4と3と掛ける方が良いか
            4.75*3-3*4
              3*(4.75-4)
            4.75*(3*(4.75-4))-3*3
              3*(4.75*(4.75-4)-3)
            4.75*(3*(4.75*(4.75-4)-3))-3*(3*(4.75-4))
              3*(4.75*(4.75*(4.75-4)-3)-(3*(4.75-4)))
            4.75*(3*(4.75*(4.75*(4.75-4)-3)-(3*(4.75-4))))-3*(4.75*(4.75-4)-3))
      4A2=19*3-12*4
            4.75*3-3*4
              3*(4.75-4)=3*0.75
            4.75*3*0.75-3*3
              3*0.75*(4.75-3*3/3*0.75)=3*0.75*(4.75-3/0.75)
                =3*0.75*0.75
            4.75*(3*(4.75*(4.75-4)-3))-3*(3*(4.75-4))
              3*(4.75*(4.75*(4.75-4)-3)-(3*(4.75-4)))
            4.75*(3*(4.75*(4.75*(4.75-4)-3)-(3*(4.75-4))))- 
       3に0.75を掛けていくだけ

No.59 鉄道の旅
  https://yukicoder.me/problems/no/59
  始点では0、各中間駅では荷物を積むか下ろすか決まっている
    荷物を積む前にすでにその荷物の重さ以上の荷物がk個以上列車に積まれている場合にはその荷物を積めない
    指定の重さの荷物が一つでもあれば降ろす
      1<=N<=100000
      1<=k<=100000
        最終的に荷物をいくつ積んでいるか
          wの符号はクエリの種類といえる
      -の場合はあれば降ろすので計算量には影響しない
      積む場合をどうするか
        BITで行ける
          今乗っている荷物の数から積まれる荷物未満の数を引いた数がk以上でなければ良いのである
          
No.60 魔法少女
  https://yukicoder.me/problems/no/60
  1<=N<=100000
  1<=K<=100000
  -500<=xk,yk<=500
  1<=Hpk<=10000
  座標を0,1000に修正
    あとはimos法
    
No.61 リベリオン
  https://yukicoder.me/problems/no/61
  w*h
  mの位置(mx,my),hの位置(hx,hy),(hx,hy)から伸びるベクトル(vx,vy)がある
    ベクトルが伸び続け、壁に反射すると入射角と同じ角度で反射する
      (vx,vy)は１秒間に進む距離といえる
        そのまま進む時、D秒以内にmにヒットするか
    愚直に計算するとTLEである
      直線上に(mx,my)が現れればいいわけだが、反射を考慮するのが難しい
        点上を通りすぎるところなので、vx,vyをまず最大公約数で割る
          どの点を通り過ぎるか分かる
            格子点が打てるようになる
              格子点の数はせいぜい15*15程度
                つまり一つ一つ追っても225である
                  交差する事があるため、同じ点にたどり着いた時という判定では難しいが、300も繰り返せば十分に求められるだろう
        最大公約数回進むと1秒である
        あとは次の座標を決める方法を見つければ良い
          下手すると反射回数がかなり多い場合もあり得る
            すると計算回数が増える
              45°で進めるようにグリッドを拡張すると計算が楽になる
                例えば1,3の時はx軸を3倍にすると3,3になる
                2,3の時はx軸を3倍、y軸を2倍にする、すると一回の移動で6,6となる
                  5,5からスタートし、3,3で進むときに6,6にあたる時
                    6,6地点から-2,2で次の地点に進むとなる
                      そこから5,7に衝突するときは
                        次のベクトルは(-1,-1)となる
                          壁に当たる回数によっては計算回数が激増する
                            もっと簡単に計算出来ないか
                            実は間に合う計算量か
                          1進むごとに(-1,-1)される為反射する回数もせいぜい15である
                            225*15=3375で実現可能
                              10000*3375であれば間に合う
    反射して着地する場所は普通に求められる
      例えば2から0に向かって-4進む時
        -2進んで2進むため、2になる
      このように処理することにより、x,yを別で考えることが可能となり簡単となった
        さらに振動する時は0に到達する時
          x<0になっていたらそのままxをpositiveにする
            x>limに行った時に2*lim-xで反射して到達する場所が拾えるのである
              これで良い

No.66 輝け☆全国たこやき杯
  https://yukicoder.me/problems/no/66
  2^m人の選手が出場
    トーナメント形式
      それぞれの選手は強さパラメータsiを持っている
    aとbが対戦する時aが勝つ確率はsa^2/(sa^2+sb^2)、bが勝つ確率は1-p(a)
      n1が優勝する確率を求めよ
    1<=m<=10
      それぞれが勝つ確率を全て出せば良い
        トーナメントの良いプラクティス
          
No.67 よくある棒を切る問題 (1)
  https://yukicoder.me/problems/no/67
  i番目の棒の長さはLi
    同じ長さのk本の棒を作りたい
      長さの最大値を求める
  2分探索の代表的な問題
    つなげられない為、単純に切り出すだけである

No.74 貯金箱の退屈
  https://yukicoder.me/problems/no/74
  n枚の硬貨を円形に並べる
    n枚の硬貨から適当に１枚選ぶ
      d円であれば時計回りと反時計回りにd個先の硬貨をひっくり返す
        全ての硬貨を表向きにしたい
          裏表は0,1で表わされる
  1<=n<=100
  1<=d<=1000
  0が裏、1が表
  YesNo判定問題
    硬貨は時計回りの並びとなっている
      有向グラフにもなっている
        問題は閉路になっている場合である、自己ループもあり得る
          少し厄介である
            自己ループの場合は行先数が1になる為、フラグを立てられる
              入ったら表にして処理を終了可能
      問題文を読み間違えていた
        連鎖するわけではなく、選んだところから+d,-dの場所の硬貨をひっくり返すという処理であった
          グラフではない
    表は一度ひっくり返されているという前提にして
      全て奇数回ひっくり返せれば良いということである
        同じ所を二度使用する事があるのか？
          数字を１ずつ増やすだけと考えると２回増やすのは０回増やすのと同じであるため、ない
      貪欲的な選択が出来るか
        これは出来ない
      順番は関係ない
        ある場所をひっくり返せるのが複数存在するのが厄介
      (x-d)=a,(x+d)=bのペアを考える
        a>bの時はswap
          初期011で
              101
              011
              001
          の時に
              101は使用される
                110となる
                最後に001を使用する
          初期000で
              110
              101
              011
          の時は110でひっくり返せなくなる
            自分の場所は奇数になるようにひっくり返すことが出来るが
              どれを処理するかを決めるのには時間がかかる
        上で考えるのとは別の形でグラフに出来る
          ループするところがないように無向グラフとして張る
            すると始点から伸びる各辺に対してyes、no判定が出来るようになる
              全てyesになるパターンがあればtrueを返せるし
                1→3
                2→3の時にどうするか
                  １→３→２のグラフにする
                    始点1としたとき3→2と進み、2は終点なので一つ戻る
                      3は2を見て、裏であれば３→2の処理を使用する
                        1に戻り同じ事を繰り返す
                          最終的に1が表になれればok
                            これを考えると自己ループはどうするかという問題になる
                              同じ考えで上のやつを処理すると
                                011初期
                                辺1→3
                                  2→3
                                  3→3と構築されている
                                  3を自己ループとしたときに
                                  3につながる頂点は全てどちらにする事も可能となる
                                    これを考えると自己ループを含む場合、全て1に出来るのではないか
        連結成分内で裏が偶数であればokという話、自己ループの場合は偶奇の調節が可能であるためok
          確かに01をひっくり返す場合10になるため、数は変わらないが裏表の移動は一つずつ出来ると考えられる
            すると連結成分内に偶数個0があれば隣接させて両方共1にする事が出来る
          


                  
        
  
  
  
  
            

  
          
